<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>@Import中使用ImportBeanDefinitionRegistrar的原理</title>
    <url>/2019/07/02/Import%E4%B8%AD%E4%BD%BF%E7%94%A8ImportBeanDefinitionRegistrar%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>使用@Import注解向容器中注入组件时,可以传入Configuration,ImportSelector, ImportBeanDefinitionRegistrar.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment">	 * or regular component classes to import.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>今天就讨论<code>ImportBeanDefinitionRegistrar</code></p>
<p>看其源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment">	 * the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment">	 * registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment">	 * class processing.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其方法<code>registerBeanDefinitions</code>有两个传参:</p>
<ul>
<li><code>AnnotationMetadata</code>是当前类的一些注解信息</li>
<li><code>BeanDefinitionRegistry</code>为bean定义的注册类，所有bean的定义都在这里进行注册。所以可以通过它来给容器中注册bean组件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register a new bean definition with this registry.</span></span><br><span class="line"><span class="comment">	 * Must support RootBeanDefinition and ChildBeanDefinition.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean instance to register</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanDefinition definition of the bean instance to register</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if the BeanDefinition is invalid</span></span><br><span class="line"><span class="comment">	 * or if there is already a BeanDefinition for the specified bean name</span></span><br><span class="line"><span class="comment">	 * (and we are not allowed to override it)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> RootBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ChildBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关键 -&gt; 往注册表中注册一个新的 BeanDefinition 实例 </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Remove the BeanDefinition for the given name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean instance to register</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">   <span class="comment">// 移除注册表中已注册的 BeanDefinition 实例</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the BeanDefinition for the given bean name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName name of the bean to find a definition for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the BeanDefinition for the given name (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> NoSuchBeanDefinitionException if there is no such bean definition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">   <span class="comment">// 从注册中取得指定的 BeanDefinition 实例</span></span><br><span class="line">	<span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check if this registry contains a bean definition with the given name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> if this registry contains a bean definition with the given name</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">   <span class="comment">// 判断 BeanDefinition 实例是否在注册表中（是否注册）</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the names of all beans defined in this registry.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the names of all beans defined in this registry,</span></span><br><span class="line"><span class="comment">	 * or an empty array if none defined</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">   <span class="comment">// 取得注册表中所有 BeanDefinition 实例的 beanName（标识）</span></span><br><span class="line">	String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the number of beans defined in the registry.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the number of beans defined in the registry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">   <span class="comment">// 返回注册表中 BeanDefinition 实例的数量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given bean name is already in use within this registry,</span></span><br><span class="line"><span class="comment">	 * i.e. whether there is a local bean or alias registered under this name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the given bean name is already in use</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// beanName（标识）是否被占用</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionRegistry 继承了 AliasRegistry 接口，其核心子类有三个：SimpleBeanDefinitionRegistry、DefaultListableBeanFactory、GenericApplicationContext。<br><img src="Import%E4%B8%AD%E4%BD%BF%E7%94%A8ImportBeanDefinitionRegistrar%E7%9A%84%E5%8E%9F%E7%90%86/3.png" alt="BeanDefinition"></p>
<p>其<code>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code>方法中的BeanDefinition参数(是一个接口)，有多个实现类:<br><img src="Import%E4%B8%AD%E4%BD%BF%E7%94%A8ImportBeanDefinitionRegistrar%E7%9A%84%E5%8E%9F%E7%90%86/1.png" alt="BeanDefinition"></p>
<p>以<code>RootBeanDefinition</code>为例,注册一个bean时可以:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//..省略部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个BeanDefinition,其类型为RainBow.class</span></span><br><span class="line"> RootBeanDefinition rainBowRootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow.class);</span><br><span class="line"><span class="comment">//使用registerBeanDefinition方法将上面的bean注册到容器中</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">&quot;rainBow&quot;</span>,rainBowRootBeanDefinition);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring中还有很多地方用到了registerBeanDefinition，这里仅做简单的介绍。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA+JAVA编写HDFS代码</title>
    <url>/2018/07/25/IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>使用JAVA API操作HDFS文件</p>
<ul>
<li>IDEA+Maven创建Java工程</li>
<li>添加HDFS相关依赖</li>
<li>开发JAVA API操作HDFS文件</li>
</ul>
<h1 id="IDEA环境配置"><a href="#IDEA环境配置" class="headerlink" title="IDEA环境配置"></a>IDEA环境配置</h1><p>首先打开IDEA,选择Maven项目，选择quickstart接着下一步<br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/1.png"></p>
<p>输入一些基本信息</p>
<p><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/2.png"></p>
<p>这里IDEA有自己集成的Maven版本,在<code>User settings file</code>可以使用系统自带的xml文件，也可以选择自己下载的Maven。<br>可以在网上下载一个Maven压缩包，解压到指定的文件夹，在使用的时候选择这个文件夹下的<code>settings.xml</code>就行了。</p>
<p>同样的<code>Local repository</code>也可以自己选择一个本地目录。<br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/4.png"></p>
<p>下一步填一些基本信息<br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/5.png"></p>
<p>然后等待Maven初始化完成，可以看到下面console窗口的SUCCESS信息。<br>初始的项目集成了单元测试<code>junit</code>包。</p>
<p><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/6.png"><br>接着配置开发hadoop需要的依赖。<br>如图，添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>这里我配置的hadoop依赖版本是2.9.0,根据自己的实际版本进行修改<br>另外，这里的<code>$&#123;hadoop.version&#125;</code>在上面的<code>&lt;properties&gt;&lt;/properties&gt;</code>标签中进行了配置，其实和上面的代码的效果是一样的。</p>
<p>然后Maven会自己下载相应的依赖，可以看到在右侧已经下载成功所需的依赖。<br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/7.png"><br>然后在右侧栏的<code>hadoop.hdfs</code>中新加一个包，然后新建一个类进行测试</p>
<p><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/8.png"></p>
<p>以下是单元测试代码，其中的路径参数是我自己系统上的路径，在开发时自行替换为自己的开发测试路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hadoop.hdfs.hdfs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Progressable;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hadoop HDFS java API 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HDFS_PATH = <span class="string">&quot;hdfs://localhost:9000&quot;</span>;</span><br><span class="line"></span><br><span class="line">    FileSystem fileSystem = <span class="keyword">null</span>;</span><br><span class="line">    Configuration configuration = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建hdfs目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        fileSystem.mkdirs(<span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FSDataOutputStream out = fileSystem.create(<span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test/a.txt&quot;</span>));</span><br><span class="line">        out.write(<span class="string">&quot;hello hdfs&quot;</span>.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看hdfs文件的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FSDataInputStream in = fileSystem.open(<span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test/a.txt&quot;</span>));</span><br><span class="line">        IOUtils.copyBytes(in,System.out,<span class="number">1024</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *重命名文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renameFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Path oldPath = <span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test/a.txt&quot;</span>);</span><br><span class="line">        Path newPath = <span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test/b.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fileSystem.rename(oldPath,newPath))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;rename success!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从本地拷贝一个文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Path localPath = <span class="keyword">new</span> Path(<span class="string">&quot;/home/hadoop/study/data/hello.txt&quot;</span>);</span><br><span class="line">        Path hdfsPath = <span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test&quot;</span>);</span><br><span class="line">        fileSystem.copyFromLocalFile(localPath,hdfsPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从本地拷贝一个大文件，并且带进度条</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFromLocalFileWithProgress</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(</span><br><span class="line">                        <span class="keyword">new</span> File(<span class="string">&quot;/home/hadoop/下载/hadoop-2.9.0.tar.gz&quot;</span>)));</span><br><span class="line">        FSDataOutputStream out = fileSystem.create(</span><br><span class="line">                <span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test/hadoop-2.9.0.tar.gz&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Progressable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">progress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        IOUtils.copyBytes(in,out,<span class="number">4096</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载HDFS文件到本地</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Path localpath = <span class="keyword">new</span> Path(<span class="string">&quot;/home/hadoop/study/data/b.txt&quot;</span>);</span><br><span class="line">        Path hdfspath = <span class="keyword">new</span> Path(<span class="string">&quot;/hdfsapi/test/b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fileSystem.copyToLocalFile(hdfspath,localpath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目录下的所有文件和文件夹</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileStatus[] fileStatus = fileSystem.listStatus(<span class="keyword">new</span> Path(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(FileStatus filestatus : fileStatus)&#123;</span><br><span class="line">            String Status = filestatus.isDirectory() ? <span class="string">&quot;文件夹&quot;</span> : <span class="string">&quot;文件&quot;</span>;</span><br><span class="line">            <span class="keyword">short</span> replication = filestatus.getReplication(); <span class="comment">//副本数</span></span><br><span class="line">            <span class="keyword">long</span> len = filestatus.getLen(); <span class="comment">//文件大小</span></span><br><span class="line">            String path = filestatus.getPath().toString();</span><br><span class="line"></span><br><span class="line">            System.out.println(Status + <span class="string">&quot; &quot;</span> + replication+ <span class="string">&quot; &quot;</span> +len+ <span class="string">&quot; &quot;</span> +path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        fileSystem.delete(<span class="keyword">new</span> Path(<span class="string">&quot;&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有的单元测试之前执行的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HDFS setUp&quot;</span>);</span><br><span class="line">        configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        fileSystem = FileSystem.newInstance(<span class="keyword">new</span> URI(HDFS_PATH),configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在所有的单元测试执行完之后执行的,释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        configuration = <span class="keyword">null</span>;</span><br><span class="line">        fileSystem = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;HDFS tearDown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="HDFS工作流程"><a href="#HDFS工作流程" class="headerlink" title="HDFS工作流程"></a>HDFS工作流程</h1><p>下面是在网上看到的漫画版的解释HDFS的工作流程，值得反复阅读，这里贴上来感谢作者！</p>
<p><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-1.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-2.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-3.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-4.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-5.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-6.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-7.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-8.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-9.jpg"><br><img src="IDEA+JAVA%E7%BC%96%E5%86%99HDFS%E4%BB%A3%E7%A0%81/m-10.jpg"></p>
]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL</title>
    <url>/2019/02/27/AVL/</url>
    <content><![CDATA[<h1 id="AVL的定义和平衡因子"><a href="#AVL的定义和平衡因子" class="headerlink" title="AVL的定义和平衡因子"></a>AVL的定义和平衡因子</h1><p>AVL树即平衡二叉树。AVL树的定义首先要求该树是二叉查找树（满足排序规则），并在此基础上增加了每个节点的平衡因子的定义，一个节点的平衡因子是该节点的左子树树高减去右子树树高的值。<br>特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树</p>
<p><img src="AVL/1.png" alt="左边为AVL树"></p>
<p>平衡因子BF：该节点的左子树的深度减去它的右子树深度。</p>
<p><img src="AVL/2.png" alt="计算平衡因子即用左子树的高度减右子树的高度,红色表示该节点的深度,蓝色表示平衡因子"></p>
<p>可见图中的平衡因子有2,那么这棵树不是一个平衡二叉树。</p>
<h1 id="计算节点的高度和平衡因子"><a href="#计算节点的高度和平衡因子" class="headerlink" title="计算节点的高度和平衡因子"></a>计算节点的高度和平衡因子</h1><p>由上面的定义可以知道，如果想保持二分搜索树的平衡，那么要计算每个节点的高度值，以便计算平衡因子，根据平衡因子对二分搜索树进行一定操作，以便保持平衡。</p>
<p>在之前BST的基础上进行改写(BST见附录),实现新的AVL.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> heigth; <span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            heigth = <span class="number">1</span>; <span class="comment">//初始化时为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断该二叉树是否是一棵二分搜索树</span></span><br><span class="line">    <span class="comment">//二分搜索树的一个性质之一：在进行中序遍历时，遍历的结果所有元素是按顺序排列的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;K&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root,keys);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; keys.size() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(keys.get(i - <span class="number">1</span>).compareTo(keys.get(i)) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node,ArrayList&lt;K&gt; keys)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inOrder(node.left,keys);</span><br><span class="line">        keys.add(node.key);</span><br><span class="line">        inOrder(node.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断该二叉树是否是一棵平衡二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断以Node为根的二叉树是否是一颗平衡二叉树,递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(balanceFactor) &gt; <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(node.left) &amp;&amp; isBalanced(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得节点node的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> node.heigth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获得节点的平衡因子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向以node为根的二分搜索树中插入元素(key, value)，递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后二分搜索树的根</span></span><br><span class="line">    <span class="comment">//在这个函数中要对height进行维护</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新height</span></span><br><span class="line">        node.heigth = <span class="number">1</span> + Math.max(getHeight(node.left),getHeight(node.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(balanceFactor) &gt; <span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;unbalanced :&quot;</span> + balanceFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对AVL树的基本操作进行了编写,其中省略了部分和BST相同的代码</p>
<h1 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h1><p>在进行了插入节点的操作后，才有可能破坏当前树的平衡性。这时候需要重新计算其父节点和祖先节点的平衡因子，并判断是否失去了平衡性。因为本身插入节点的<code>add</code>操作就是用递归实现的，所以在递归代码中进行改写。</p>
<h2 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h2><p>如果平衡因子大于一并且是在树的左侧的左侧添加</p>
<p>如图所示，是两种最简单的向左添加破坏了树的平衡性的情况，以绿色表示的节点其整体向左倾斜.左子树的高度大于其右子树的高度并且其左孩子也是如此。</p>
<p><img src="AVL/3.png"></p>
<p>这时候的解决方法是进行右旋转。</p>
<p><img src="AVL/4.png" alt="右旋转"></p>
<p>在<code>add</code>函数中进行修改:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对节点y进行向右旋转操作，返回旋转后的新的根节点x</span></span><br><span class="line"><span class="comment">//        y                              x</span></span><br><span class="line"><span class="comment">//       / \                           /   \</span></span><br><span class="line"><span class="comment">//      x   T4     向右旋转 (y)        z     y</span></span><br><span class="line"><span class="comment">//     / \       - - - - - - - -&gt;    / \   / \</span></span><br><span class="line"><span class="comment">//    z   T3                       T1  T2 T3 T4</span></span><br><span class="line"><span class="comment">//   / \</span></span><br><span class="line"><span class="comment">// T1   T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span></span>&#123;</span><br><span class="line">    Node x = y.left;</span><br><span class="line">    Node T3 = x.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向右旋转</span></span><br><span class="line">    x.right = y;</span><br><span class="line">    y.left = T3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新height</span></span><br><span class="line">    y.heigth = Math.max(getHeight(y.left),getHeight(y.right));</span><br><span class="line">    x.heigth = Math.max(getHeight(x.left),getHeight(x.right));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">        node.left = add(node.left, key, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">        node.right = add(node.right, key, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">        node.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新height</span></span><br><span class="line">    node.heigth = <span class="number">1</span> + Math.max(getHeight(node.left),getHeight(node.right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算平衡因子</span></span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">    <span class="comment">// if(Math.abs(balanceFactor) &gt; 1)</span></span><br><span class="line">    <span class="comment">//     System.out.println(&quot;unbalanced :&quot; + balanceFactor);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///平衡维护</span></span><br><span class="line">    <span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> rightRotate(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h2><p>同理，当插入的元素在不平衡的节点的右侧的右侧时，进行坐旋转操作以满足平衡性。即左旋转的情况是和右旋转完全对称的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对节点y进行向左旋转操作，返回旋转后新的根节点x</span></span><br><span class="line"><span class="comment">//    y                             x</span></span><br><span class="line"><span class="comment">//  /  \                          /   \</span></span><br><span class="line"><span class="comment">// T1   x      向左旋转 (y)       y     z</span></span><br><span class="line"><span class="comment">//     / \   - - - - - - - -&gt;   / \   / \</span></span><br><span class="line"><span class="comment">//   T2  z                     T1 T2 T3 T4</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     T3 T4</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span></span>&#123;</span><br><span class="line">    Node x = y.right;</span><br><span class="line">    Node T2 = x.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向左旋转</span></span><br><span class="line">    x.left = y;</span><br><span class="line">    y.right = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新height</span></span><br><span class="line">    y.heigth = Math.max(getHeight(y.left),getHeight(y.right)) + <span class="number">1</span>;</span><br><span class="line">    x.heigth = Math.max(getHeight(x.left),getHeight(x.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//平衡维护</span></span><br><span class="line">    <span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) <span class="comment">//左子树比右子树高</span></span><br><span class="line">       <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    <span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) <span class="comment">//右子树比左子树高</span></span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LR和RL"><a href="#LR和RL" class="headerlink" title="LR和RL"></a>LR和RL</h1><h2 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h2><p>当插入的元素在不平衡节点的左侧的右侧(即LR)，这时候不能仅仅使用右旋转。<br><img src="AVL/5.png" alt="LR的情况"></p>
<p><img src="AVL/6.png" alt="LR的情况"></p>
<p>这时候需要先对x进行左旋转，转化为LL的情况</p>
<p><img src="AVL/7.png" alt="x进行左旋转，转化为LL的情况"></p>
<p>到了这种情况继续对y进行右旋转就可以了。<br>继续完善平衡维护的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//..省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//平衡维护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LL</span></span><br><span class="line"><span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) <span class="comment">//左子树比右子树高</span></span><br><span class="line">    <span class="keyword">return</span> rightRotate(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RR</span></span><br><span class="line"><span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) <span class="comment">//右子树比左子树高</span></span><br><span class="line">    <span class="keyword">return</span> leftRotate(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LR</span></span><br><span class="line"><span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">    node.left = leftRotate(node.left); <span class="comment">//转换为LL</span></span><br><span class="line">    <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//..省略代码</span></span><br></pre></td></tr></table></figure>

<h2 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h2><p>RL是LR对称的一种情况，先将其转化为RR的情况，在进行左旋转。就不在赘述了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RL</span></span><br><span class="line"><span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node.right = rightRotate(node.right); <span class="comment">//转化为RR</span></span><br><span class="line">    <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p>删除元素也和添加元素类似，在删除元素后有可能会破坏原树的平衡性，所以在删除元素后要进行向上递归的操作，逐层判断，调整树的平衡。</p>
<p>在平衡二叉树的删除操作中，<code>node.left</code>或者<code>node.right</code>接到了递归操作的新的node节点后，当前的node节点的平衡性有可能已经遭到了破坏，所以不能直接返回当前的node，要先维护node的平衡，不能这么早的<code>return node;</code>,所以先用<code>retNode</code>暂存一下要返回的node.这样就有机会对<code>retNode</code>进行平衡维护，然后再返回。同理,<code> key.compareTo(node.key) == 0</code>时,待删除节点左子树或者右子树为空时返回的node也暂时赋值给<code>retNode</code>.同样<code>待删除节点左右子树均不为空的情况</code>也是用<code>retNode</code>暂存。</p>
<p>这样,<code>retNode</code>中存储的就是删除了节点后要返回的新的node.所以在得到了<code>retNode</code>后要对retNode进行判断，然后维护平衡。这时候的维护平衡操作其实和添加是一样的，先更新height，然后计算平衡因子，最后根据不同情况进行旋转。只是这时候处理的对象是<code>retNode</code>。</p>
<p>要注意在<code>removeMin(Node node)</code>函数操作时也有可能打破平衡，所以也要在这个函数中进行平衡维护。其实可以改写为<code>successor.right = remove(node.right,successor.key);</code>因为<code>remove()</code>函数添加了对平衡性的处理，所以这里的删除最小值操作这样改写是可以的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 从二分搜索树中删除键为key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        root = remove(root, key);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node retNode;</span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        node.left = remove(node.left , key);</span><br><span class="line">        retNode = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        node.right = remove(node.right, key);</span><br><span class="line">        retNode = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            retNode = rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            retNode = leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">                <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">                Node successor = minimum(node.right);</span><br><span class="line">                successor.right = remove(node.right, successor.key);</span><br><span class="line">                successor.left = node.left;</span><br><span class="line"></span><br><span class="line">                node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                retNode = successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断为空的情况，以免访问height会出错</span></span><br><span class="line">    <span class="keyword">if</span>(retNode == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新height</span></span><br><span class="line">    retNode.heigth = <span class="number">1</span> + Math.max(getHeight(retNode.left),getHeight(retNode.right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算平衡因子</span></span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(retNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//平衡维护</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL</span></span><br><span class="line">    <span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &gt;= <span class="number">0</span>) <span class="comment">//左子树比右子树高</span></span><br><span class="line">        <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR</span></span><br><span class="line">    <span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &lt;= <span class="number">0</span>) <span class="comment">//右子树比左子树高</span></span><br><span class="line">        <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR</span></span><br><span class="line">    <span class="keyword">if</span>(balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.left) &lt; <span class="number">0</span>)  &#123;</span><br><span class="line">        retNode.left = leftRotate(retNode.left); <span class="comment">//转换为LL</span></span><br><span class="line">        <span class="keyword">return</span> rightRotate(retNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL</span></span><br><span class="line">    <span class="keyword">if</span>(balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(retNode.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        retNode.right = rightRotate(retNode.right); <span class="comment">//转化为RR</span></span><br><span class="line">        <span class="keyword">return</span> leftRotate(retNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于AVL树的set和map"><a href="#基于AVL树的set和map" class="headerlink" title="基于AVL树的set和map"></a>基于AVL树的set和map</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K key,V value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;            <span class="comment">//删除key对应的键值对,并返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>;  <span class="comment">//是否存已在key</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;               <span class="comment">//获得key对应的value值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key,V newValue)</span></span>; <span class="comment">//更新值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AVLTree&lt;K,V&gt; avl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        avl = <span class="keyword">new</span> AVLTree&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        avl.add(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.contains(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key,V newValue)</span></span>&#123;</span><br><span class="line">        avl.set(key,newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containes</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AVLTree&lt;E, Object&gt; avl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        avl = <span class="keyword">new</span> AVLTree&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containes</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.contains(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        avl.add(e, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        avl.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向二分搜索树中添加新的元素(key, value)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        root = add(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向以node为根的二分搜索树中插入元素(key, value)，递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根节点的二分搜索树中，key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root, key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">&quot; doesn&#x27;t exist!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = remove(root, key);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.left = remove(node.left , key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.right = remove(node.right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line"></span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sorcerers.stone.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(FileOperation.readFile(<span class="string">&quot;sorcerers.stone.txt&quot;</span>, words)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total words: &quot;</span> + words.size());</span><br><span class="line"></span><br><span class="line">            BST&lt;String, Integer&gt; map = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.contains(word))</span><br><span class="line">                    map.set(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    map.add(word, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Total different words: &quot;</span> + map.getSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;Frequency of go: &quot;</span> + map.get(<span class="string">&quot;go&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Frequency of stone: &quot;</span> + map.get(<span class="string">&quot;stone&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中使用trigger(触发器)</title>
    <url>/2019/05/24/MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<p>最近有一个项目提出新需求,有一个表由之前的一对一变成一对多,为了不影响使用原表的视图(为了进行统计汇总等),所以打算为这个表拓展子表,在子表上定义触发器,在子表改变的时候对应改变母表.所以这里记录一下定义使用trigger的过程.</p>
<p>在此之前提醒一下：</p>
<p><font color="red">！！尽量少使用触发器,不建议使用。</font></p>
<p>假设触发器触发每次执行1s,insert table 500条数据,那么就需要触发500次触发器,光是触发器执行的时间就花费了500s,而insert 500条数据一共是1s,那么这个insert的效率就非常低了。因此我们特别需要注意的一点是触发器的begin end;之间的语句的执行效率一定要高,资源消耗要小。<br>触发器尽量少的使用,因为不管如何,它还是很消耗资源,如果使用的话要谨慎的使用,确定它是非常高效的：触发器是针对每一行的；对增删改非常频繁的表上切记不要使用触发器,因为它会非常消耗资源。</p>
<h1 id="MySQL触发器创建"><a href="#MySQL触发器创建" class="headerlink" title="MySQL触发器创建"></a>MySQL触发器创建</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>　[DEFINER <span class="operator">=</span> &#123; <span class="string">&#x27;user&#x27;</span> <span class="operator">|</span> <span class="built_in">CURRENT_USER</span> &#125;]</span><br><span class="line"><span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">[trigger_order]</span><br><span class="line">trigger_body</span><br></pre></td></tr></table></figure>

<p>其中一些字段含义:<br>|字段|含义|可能的值|<br>| – | – | – |<br>|DEFINER=|可选参数,指定创建者,默认为当前登录用户(CURRENT_USER);该触发器将以此参数指定的用户执行,所以需要考虑权限问题；|DEFINER=‘root@%’<br>DEFINER=CURRENT_USER|<br>|trigger_name|触发器名称,最好由表名+触发事件关键词+触发时间关键词组成；||<br>|trigger_time|触发时间,在某个事件之前还是之后|BEFORE、AFTER|<br>|trigger_event|触发事件,如插入时触发、删除时触发；<br><code>INSERT</code>：插入操作触发器,INSERT、LOAD DATA、REPLACE时触发;<br><code>UPDATE</code>：更新操作触发器,UPDATE操作时触发;<code>DELETE</code>：删除操作触发器,DELETE、REPLACE操作时触发;|INSERT、UPDATE、DELETE|<br>|table_name |触发操作事件的表名||<br>|trigger_order|可选参数,如果定义了多个具有相同触发事件和触法时间的触发器时(如：BEFORE UPDATE),默认触发顺序与触发器的创建顺序一致,可以使用此参数来改变它们触发顺序。<br>mysql 5.7.2起开始支持此参数。<br>FOLLOWS：当前创建触发器在现有触发器之后激活；<br>PRECEDES：当前创建触发器在现有触发器之前激活|FOLLOWS、PRECEDES|<br>|trigger_body|触发执行的SQL语句内容,一般以begin开头,end结尾|begin .. end|</p>
<p>在trigger_body中,我们可以使用NEW表示将要插入的新行(相当于MS SQL的INSERTED),OLD表示将要删除的旧行(相当于MS SQL的DELETED)。通过OLD,NEW中获取它们的字段内容,方便在触发操作中使用,下面是对应事件是否支持OLD、NEW的对应关系：<br>|事件|OLD|NEW|<br>|– | – | – |<br>|INSERT|×|√|<br>|DELETE|√|×|<br>|UPDATE|√|√|由于UPDATE相当于删除旧行(OLD),然后插入新行(NEW),所以UPDATE同时支持OLD、NEW；</p>
<ul>
<li>MySQL分隔符(DELIMITER):</li>
</ul>
<p>MySQL默认使用”;”作为分隔符，SQL语句遇到”;”就会提交。而我们的触发器中可能会有多个”;”符，为了防止触发器创建语句过早的提交，我们需要临时修改MySQL分隔符，创建完后，再将分隔符改回来。使用DELIMITER可以修改分隔符，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">... --触发器创建语句;</span><br><span class="line">$   --提交创建语句;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MySQL触发器中使用变量：<br>MySQL触发器中变量变量前面加‘@’，无需定义，可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 变量直接赋值</span><br><span class="line">set @num=999;</span><br><span class="line"> </span><br><span class="line">-- 使用select语句查询出来的数据方式赋值，需要加括号：</span><br><span class="line">set @name =(select name from table);</span><br></pre></td></tr></table></figure></li>
<li><p>MySQL触发器中使用if语做条件判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 简单的if语句：</span><br><span class="line">set sex = if (new.sex=1, &#x27;男&#x27;, &#x27;女&#x27;);</span><br><span class="line"> </span><br><span class="line">-- 多条件if语句：</span><br><span class="line">if old.type=1 then</span><br><span class="line">    update table ...;</span><br><span class="line">elseif old.type=2 then</span><br><span class="line">    update table ...;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>由于项目中的表过于复杂,这里就只用比较简单的表作为例子进行记录。</p>
<p>创建母表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employ` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">char</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `salary2` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>
<p>创建子表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employ_copy` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `employ_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">char</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `salary2` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">7</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p>母表自表之间没有用外键连接,但是子表(employ_copy)根据<code>employ_id</code>与母表(employ)的id进行匹配.</p>
<p>为了更直观,这里使用Navicat进行操作：<br>首先插入一条数据:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/1.png" alt="插入数据"></p>
<p>在employ_copy中定义插入时的触发器:</p>
<p>在Navicat中直接这样写就可以了:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/2.png" alt="插入数据时的触发器"></p>
<p>现在在employ_copy表中插入一条数据,然后看employ表中数据的对应改变:<br>插入的数据:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/4.png" alt="插入数据"><br>数据改变:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/5.png" alt="数据改变"></p>
<p>当向employ_copy中插入数据时,让employ中的salary和salary2字段等于原来的字段加上新插入的值.由于原来都是0,插入的两个值为100,插入后employ中的两个值变为100</p>
<p>然后定义更新时的触发器:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/3.png" alt="更新数据时的触发器"></p>
<p>将刚才employ_copy中的数据进行修改:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/6.png" alt="更新"></p>
<p>然后查看新值:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/7.png" alt="数据改变"></p>
<p>思路是employ中的值等于减去update之前的旧值然后再加上update之后的新值.</p>
<p>最后定义删除时的触发器:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/8.png" alt="删除数据时的触发器"></p>
<p>将刚才employ_copy中的数据进行删除:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/9.png" alt="删除"></p>
<p>然后查看新值:<br><img src="MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8trigger-%E8%A7%A6%E5%8F%91%E5%99%A8/10.png" alt="数据改变"></p>
<p>employ_copy中删除数据后,employ中对应数据也进行了删除</p>
<p>这次只是简单的trigger使用,做一个简单的记录</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://www.cnblogs.com/geaozhang/p/6819648.html">https://www.cnblogs.com/geaozhang/p/6819648.html</a></p>
</li>
<li><p><a href="https://aiezu.com/article/mysql_trigger_syntax.html">https://aiezu.com/article/mysql_trigger_syntax.html</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce的补充和WordCount简单实战(一)</title>
    <url>/2018/07/28/MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/</url>
    <content><![CDATA[<p>官网介绍：<a href="http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html">http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html</a></p>
<p>首先回顾一些MapReduce的基础知识：<br><a href="https://homxuwang.github.io/2018/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/">https://homxuwang.github.io/2018/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/</a></p>
<ul>
<li>Hadoop MapReduce是Google MapReduce的实现</li>
<li>MapReduce的优点： 海量数据离线处理 易开发(JAVA API) 易运行</li>
<li>MapReduce的缺点：<br>  实时流式计算（MR是根据请求服务的方式进行计算；多个应用程序存在依赖关系，MR的作业，数据需要落地到HDFS或者磁盘。所以不能实现实时流式计算）</li>
</ul>
<h1 id="MapReduce的执行过程"><a href="#MapReduce的执行过程" class="headerlink" title="MapReduce的执行过程"></a>MapReduce的执行过程</h1><blockquote>
<p>参考：<a href="https://www.cnblogs.com/ahu-lichang/p/6645074.html">https://www.cnblogs.com/ahu-lichang/p/6645074.html</a></p>
</blockquote>
<p>官网的介绍：</p>
<blockquote>
<p>A MapReduce job usually splits the input data-set into independent chunks which are processed by the map tasks in a completely parallel manner. The framework sorts the outputs of the maps, which are then input to the reduce tasks. Typically both the input and the output of the job are stored in a file-system. The framework takes care of scheduling tasks, monitoring them and re-executes the failed tasks.</p>
</blockquote>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/1.png"></p>
<ul>
<li>Input –&gt; Spliting 一个文件被分成很多个块（默认情况下一个split对应HDFS中的一个block，用户可以进行修改）</li>
<li>Spliting –&gt; Mapping 一个块交由一个Map任务处理，处理完的结果写到本地</li>
<li>Mapping –&gt; Shuffling –&gt; Reducing写到本地的文件通过Shuffle后进行传输，把相同的key写到一个Reduce中,在Reduce中进行统计</li>
<li>Reducing统计的结果最终写到文件系统上</li>
</ul>
<p>看看官网的解释：</p>
<blockquote>
<p>The MapReduce framework operates exclusively on &lt;key, value&gt; pairs, that is, the framework views the input to the job as a set of &lt;key, value&gt; pairs and produces a set of &lt;key, value&gt; pairs as the output of the job, conceivably of different types.</p>
<p>The key and value classes have to be serializable by the framework and hence need to implement the Writable interface. Additionally, the key classes have to implement the WritableComparable interface to facilitate sorting by the framework.</p>
<p>Input and Output types of a MapReduce job:</p>
<p>(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</p>
</blockquote>
<h2 id="关于Writable接口"><a href="#关于Writable接口" class="headerlink" title="关于Writable接口"></a>关于Writable接口</h2><p>在上面的介绍中看到，key和value需要实现<code>Writable</code>接口，并且key还需要实现<code>WritableComparable</code>接口</p>
<p>这个接口需要反复阅读</p>
<p>关于<code>Writable</code>接口的介绍：<a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html">http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html</a></p>
<p>关于<code>WritableComparable</code>接口的介绍：<br><a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/WritableComparable.html">http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/WritableComparable.html</a></p>
<p>在<code>Writable</code>接口中主要实现<code>write</code>和<code>readFields</code>方法。</p>
<p>再看上文面的wordcount的图和<code>(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</code>这个过程：</p>
<p>其中<code>k1</code>就是<code>偏移量</code>。第一行的第一个字符从0开始，<code>v1</code>就是这一行的数据<code>Deer Bear River</code>。那么第二行的偏移量就是第一行的字符的长度相加，值就是<code>Car Car River</code>。以此类推</p>
<p>经过一层转换<code>k2</code>就是上面每一行的单词,每个单词相当于是从<code>v1</code>中拆分出来(Split(“ “))，是一个<code>Text</code>类型，每个单词就是一个1。<code>v2</code>就是一个<code>IntWritable</code>或<code> LongWritable</code>类型。</p>
<p>reduce输出的就是每个单词输出的总和。<code>k3</code>就是每个单词，<code>v3</code>就是单词出现的总和。</p>
<h2 id="JAVA-API的简单介绍"><a href="#JAVA-API的简单介绍" class="headerlink" title="JAVA API的简单介绍"></a>JAVA API的简单介绍</h2><p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/3_1.png"></p>
<ol>
<li>看上图，首先读取文件使用<code>InputFormat</code>类，它是一个接口，在源码中描述为<blockquote>
<p><code>InputFormat</code> describes the input-specification for a  Map-Reduce job.<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/3.png" alt="InputFormat的实现类"></p>
</blockquote>
</li>
<li><code>InputFormat</code>的实现类中，用的比较多的是<code>FileInputFormat</code>类.这是一个读取文件系统的基本的类.但是<code>FileInputFormat</code>类仍然是个抽象类。<br>那么继续找它的子类<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/4.png" alt="FileInputFormat的实现类"><br>可以看到<code>TextInputFormat</code>类.这时候它就是一个实现的类了</li>
</ol>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/5.png" alt="TextInputFormat类"></p>
<p>官方文档的介绍：</p>
<blockquote>
<p>An {@link InputFormat} for plain text files.  Files are broken into lines.<br> Either linefeed or carriage-return are used to signal end of line.  Keys are<br> the position in the file, and values are the line of text.. </p>
</blockquote>
<p>其中<code>InputFormat</code>中有几个关键的方法：</p>
<ol>
<li><code>InputSplit[] getSplits(JobConf job, int numSplits) throws IOException;</code><br>即将一个输入文件分成很多Split，每一个Split交给一个MapTask处理的方法。它的返回值是一个数组，可见一个输入文件可能会的到好几个<code>InputSplit</code></li>
</ol>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/6.png" alt="getSplits方法"></p>
<ol start="2">
<li><code>RecordReader&lt;K, V&gt; getRecordReader(InputSplit split,JobConf job,Reporter reporter) throws IOException;</code><br>它是一个记录读取的方法，从参数可以看到，它从<code>InputSplit[]</code>数组中读进数据，可以知道每一行的数据是什么。</li>
</ol>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/7.png" alt="getRecordReader方法"></p>
<p>在<code>InputFormat</code>读进数据后(对于文本就是使用<code>TextInputFormat</code>），从图中可以看出，被拆分成好多个<code>Split</code>。拿到<code>Split</code>后，使用RR(RecordReader)把每个<code>Split</code>中的数据读取出来,一行一行的读，每读一行，交由一个<code>map</code>处理.<code>Partitioner</code>将相同的<code>key</code>交到同一个<code>Reduce</code>上，从图中可以看出，<code>key</code>可能会被发送到node1或者node2.中间有一个<code>shuffle</code>的过程，结果交由<code>reduce</code>处理。处理完的结果交给<code>OutputFormat</code>。</p>
<ol start="3">
<li><code>OutputFormat</code></li>
</ol>
<blockquote>
<p><code>OutputFormat</code> describes the output-specification for a  Map-Reduce job.</p>
</blockquote>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/8.png" alt="OutputFormat的方法"></p>
<p>其中<code>getRecordWriter</code>方法就对应<code>InputFormat</code>的<code>getRecordReader</code>方法</p>
<p>继续寻找它的实现类-&gt;<code>FileOutputFormat</code>-&gt;<code>TextOutputFormat</code></p>
<blockquote>
<p>An {@link OutputFormat} that writes plain text files.<br>将数据以文本的方式写出去</p>
</blockquote>
<h2 id="几个核心概念"><a href="#几个核心概念" class="headerlink" title="几个核心概念"></a>几个核心概念</h2><ul>
<li><p><code>Split</code><br>  Split是交由MapReduce作业来处理的数据块，是MapReduce中最小的计算单元<br>  HDFS：blocksize是HDFS中最小的存储单元 128M（或者自己设定）<br>  默认情况下：它们两个一一对应（也可以手动设置）</p>
</li>
<li><p><code>InputFormat</code><br>InputFormat将输入数据进行分片(split)：<code>InputSplit[] getSplits(JobConf job, int numSplits) throws IOException</code><br>默认实用比较多的是<code>TextInputFormat</code>,处理文本格式的数据</p>
</li>
<li><p><code>OutputFormat</code><br>  和InputFormat对应</p>
</li>
<li><p><code>Combiner</code></p>
</li>
<li><p><code>Partitioner</code></p>
</li>
</ul>
<p>在通过一张图对以上内容进行梳理：<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/9.png" alt="Mapreduce原理"></p>
<h1 id="MapReduce架构"><a href="#MapReduce架构" class="headerlink" title="MapReduce架构"></a>MapReduce架构</h1><h2 id="MapReduce1-x架构"><a href="#MapReduce1-x架构" class="headerlink" title="MapReduce1.x架构"></a>MapReduce1.x架构</h2><p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/10.png" alt="MapReduce1.x架构"></p>
<ol>
<li>JobTracker:JT<br> 作业的管理者<br> 将作业分解成一堆任务：Task（包括MapTask和ReduceTask)<br> 将任务分派给TaskTracker运行<br> 作业的监控、容错处理（task作业挂了，重启task）<br> 在一定时间间隔内，JT没有收到TT的心跳信息,则将任务分配到其他TT上执行</li>
<li>TaskTracker：TT<br> 任务的执行者<br> 在TT上执行Task（MapTask和ReduceTask）<br> 会与JT进行交互：执行/启动/停止作业，发送心跳信息给JT</li>
<li>MapTask<br> 自己开发的map任务交由该Task来处理<br> 解析每条记录的数据，交给自己的map方法处理<br> 将map的输出结果写到本地磁盘（有些作业只有Map，则写到HDFS）<br>4） ReduceTadk<br> 将MapTask输出的数据进行读取<br> 按照数据进行分组传给自己编写的reduce方法处理<br> 处理结果输出</li>
</ol>
<h2 id="MapReduce2-x架构"><a href="#MapReduce2-x架构" class="headerlink" title="MapReduce2.x架构"></a>MapReduce2.x架构</h2><p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%981/1.jpeg" alt="MapReduce2.x架构"></p>
<p>和yarn中的流程类似,MapReduce可以在YARN上跑。</p>
<p>下一篇实战。</p>
]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记-一</title>
    <url>/2018/11/19/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Mybatis架构图"><a href="#Mybatis架构图" class="headerlink" title="Mybatis架构图"></a>Mybatis架构图</h1><p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/1.png" alt="Mybatis架构图"></p>
<h1 id="准备测试数据库"><a href="#准备测试数据库" class="headerlink" title="准备测试数据库"></a>准备测试数据库</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Navicat MySQL Data Transfer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Source Server         : localhost_3306</span></span><br><span class="line"><span class="comment">Source Server Version : 50521</span></span><br><span class="line"><span class="comment">Source Host           : localhost:3306</span></span><br><span class="line"><span class="comment">Source Database       : mybatis</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Target Server Type    : MYSQL</span></span><br><span class="line"><span class="comment">Target Server Version : 50521</span></span><br><span class="line"><span class="comment">File Encoding         : 65001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date: 2015-04-09 16:03:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for `orders`</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `orders`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `orders` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单用户id&#x27;</span>,</span><br><span class="line">  `number` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单号&#x27;</span>,</span><br><span class="line">  `createtime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建订单时间&#x27;</span>,</span><br><span class="line">  `note` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `FK_orders_1` (`user_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `FK_orders_id` <span class="keyword">FOREIGN</span> KEY (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> UPDATE <span class="keyword">NO</span> ACTION</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of orders</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `orders` <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1000010&#x27;</span>, <span class="string">&#x27;2015-02-04 13:22:35&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `orders` <span class="keyword">VALUES</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1000011&#x27;</span>, <span class="string">&#x27;2015-02-03 13:22:41&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `orders` <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;1000012&#x27;</span>, <span class="string">&#x27;2015-02-12 16:13:23&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for `user`</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">  `birthday` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;2014-07-10&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;北京市&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;张小明&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;陈小明&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;陈小明&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;26&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>导入所需依赖包：<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/2.png" alt="依赖包"></p>
<p>根据1中的架构图，首先准备配置文件：<br><code>SqlMapConfig.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 用于配置数据库连接环境  和spring整合后 environments配置将废除    --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 使用jdbc事务管理 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">					<span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12345&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中<code>environments</code>标签是用来配置数据库连接环境的，因为这里是单独是mybatis工程，所以要进行配置。后期在整合Spring工程时，数据库的配置由Spring来负责，可以将environments标签除掉。</p>
<p>在<code>src</code>包下创建<code>log4j.properties</code>.<br><code>log4j.properties</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>

<p>创建<code>user</code>表中对应的pojo类.pojo类作为mybatis进行sql映射使用，po类通常与数据库表对应.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String sex;</span><br><span class="line">	<span class="keyword">private</span> Date birthday;</span><br><span class="line">	<span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略get和set方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;User [id=&quot;</span> + id + <span class="string">&quot;, username=&quot;</span> + username + <span class="string">&quot;, sex=&quot;</span> + sex</span><br><span class="line">				+ <span class="string">&quot;, birthday=&quot;</span> + birthday + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>my.study.mapper</code>包下创建<code>user.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 书写sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在xml中引入约束后，其根标签就是<code>&lt;mapper&gt;&lt;/mapper&gt;</code>,用来在其中书写sql语句。</p>
<p>在这里定义了<code>user.xml</code>文件后，根据架构图，需要和核心配置文件结合，所以要在核心配置文件中使用<code>&lt;mappers&gt;&lt;/mappers&gt;</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mapper的位置  Mapper.xml 写Sql语句的文件的位置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;my/study/mapper/User.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样准备工作就基本完成了，接下来就要进行架构中的第二部，创建工厂和session并进行测试。</p>
<h1 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h1><h2 id="在配置文件中书写sql"><a href="#在配置文件中书写sql" class="headerlink" title="在配置文件中书写sql"></a>在配置文件中书写sql</h2><p>在<code>User.xml</code>配置文件中书写查询sql:</p>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/3.png" alt="标签列表"><br>其中<code>&lt;&gt;cache</code>和<code>&lt;&gt;cache-ref</code>表示缓存,它们和<code>&lt;&gt;parameterMap</code>都很少用到.<code>&lt;&gt;sql</code>表示sql片段,<code>&lt;&gt;result</code>表示手动映射。剩下的增删改查和更新。</p>
<p>书写查询sql：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询用户 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user where id = #&#123;v&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>标签中的<code>id</code>表示这条sql语句在配置文件中的唯一标识;<br><code>parameterType</code>表示传参的类型;<br><code>resultType</code>表示自动映射查询到的结果，填写pojo的全路径.自动映射要求所创建的类要和数据库表中的各个字段和类型相对应,如果不对应则需要手动映射.<br><code>#&#123;&#125;</code>表示占位符，类似于jdbc中的?,大括号中的值可以随便写.</p>
<p>如果有另一个配置文件中的查询语句的id和已存在的重复，这时候可以在<code>&lt;mapper&gt;</code>添加<code>namespace=&quot;&quot;</code>,<code>namespace</code>表示命名空间，用于隔离sql,避免发生这种情况.<br>比如修改为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时候可以使用<code>user.findUserById</code>访问这个sql.</p>
<h2 id="书写测试类"><a href="#书写测试类" class="headerlink" title="书写测试类"></a>书写测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.执行Sql语句</span></span><br><span class="line">		User user = sqlSession.selectOne(<span class="string">&quot;user.findUserById&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/4.png" alt="参数"><br>这里<code> sqlSession.selectOne()</code>方法的第一个参数就是传入<code>&lt;mapper&gt;</code>的namespace+sql语句的id;第二个就是传入要进行查询的参数(也就是占位符位置的值);</p>
<p>测试结果:<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/5.png" alt="测试结果"><br>因为加入了log日志，这里会打印出各个信息</p>
<h2 id="实现模糊查询"><a href="#实现模糊查询" class="headerlink" title="实现模糊查询"></a>实现模糊查询</h2><p>书写sql语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模糊查询 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUsername&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user where username like &#x27;%$&#123;value&#125;%&#x27;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，这里的模糊查询中不是用占位符<code>#&#123;&#125;</code>，而是使用<code>$&#123;&#125;</code>。<br>类比jdbc中的占位符，<code>#&#123;&#125;</code>相当于<code>?</code><br>而在需要使用字符串拼接功能时，使用<code>$&#123;&#125;</code>.并且其中要填写<code>value</code>,而<code>#&#123;&#125;</code>则没有这种限制。<br>占位符可以防止sql注入，而字符串拼接不能防止sql注入，<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>也是一个道理。<br>在测试类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现模糊查询</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.执行Sql语句</span></span><br><span class="line">		List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;user.findUserByUsername&quot;</span>, <span class="string">&quot;五&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(User user2:users) &#123;</span><br><span class="line">			System.out.println(user2);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>因为模糊查询查出来的可能有很多结果，所以用<code>List&lt;&gt;</code>.<br>测试结果:<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/6.png" alt="测试结果"></p>
<p>上面提了这样不能防止sql注入，所以可以这样写select标签中的sql语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from user where username like &quot;%&quot;#&#123;v&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/7.png" alt="测试结果"><br>可以看到打印结果中成功出现了占位符，其实最终的sql语句相当于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> &quot;%&quot;<span class="string">&#x27;五&#x27;</span>&quot;%&quot; </span><br></pre></td></tr></table></figure>
<p>这种写法是正确的，只是平时很少这么用</p>
<h2 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h2><p>书写sql语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新增用户 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		insert into user (username,birthday,address,sex)</span><br><span class="line">		values</span><br><span class="line">		(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;address&#125;,#&#123;sex&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>#&#123;&#125;</code>中的参数要和<code>User.java</code>类中的字段对应，这样才能知道传参是和哪个字段对应</p>
<p>测试类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增用户</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.执行Sql语句</span></span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		u.setUsername(<span class="string">&quot;李雷&quot;</span>);</span><br><span class="line">		u.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">		u.setAddress(<span class="string">&quot;火星&quot;</span>);</span><br><span class="line">		u.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> i =sqlSession.insert(<span class="string">&quot;user.insertUser&quot;</span>, u);	</span><br><span class="line">    sqlSession.commit();	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中insert的返回值为int型，表示影响的行数.注意最后要提交事务才能成功插入.<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/8.png" alt="测试结果"></p>
<h2 id="新增数据后返回主键ID"><a href="#新增数据后返回主键ID" class="headerlink" title="新增数据后返回主键ID"></a>新增数据后返回主键ID</h2><p>如果想实现在新增完用户后立刻返回这条新增数据的主键，则需要在<code>&lt;insert&gt;</code>语句中再嵌套一层<code>&lt;selectKey&gt;</code>用来查询主键.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">	select LAST_INSERT_ID()</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>keyProperty</code>表示返回值为<code>User</code>的<code>id</code>属性，<code>resultType</code>表示类型是Integer型;<br>注意：在sql中，如果主键是自增的int型，那么主键是在数据插入完成后再生成主键;如果不是自增类型，比如如果是varchar类型，则会先插入主键，再插入数据。<br><code>order</code>表示执行顺序,所以这里要用<code>AFTER</code><br>其中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LAST_INSERT_ID()</span><br></pre></td></tr></table></figure>
<p>是由sql提供的查询语句，它跟在insert语句后面的话，会返回刚插入的数据的主键,比如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ....</span><br><span class="line"><span class="keyword">select</span> LAST_INSERT_ID()</span><br></pre></td></tr></table></figure>
<p>在上面的测试类中添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(u.getId());</span><br></pre></td></tr></table></figure>
<p>即可查看到已经获取到最新插入的主键ID<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/9.png" alt="测试结果"></p>
<h2 id="修改-更新数据"><a href="#修改-更新数据" class="headerlink" title="修改/更新数据"></a>修改/更新数据</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 更新 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		update user</span><br><span class="line">		set username = #&#123;username&#125;,sex =#&#123;sex&#125;,address = #&#123;address&#125;,birthday = #&#123;birthday&#125;</span><br><span class="line">		where id =#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新用户</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.执行Sql语句</span></span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		u.setId(<span class="number">29</span>);</span><br><span class="line">		u.setUsername(<span class="string">&quot;李雷update&quot;</span>);</span><br><span class="line">		u.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">		u.setAddress(<span class="string">&quot;火星update&quot;</span>);</span><br><span class="line">		u.setSex(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> i =sqlSession.update(<span class="string">&quot;user.updateUserById&quot;</span>, u);</span><br><span class="line">		sqlSession.commit();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/10.png" alt="测试结果"><br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/11.png" alt="测试结果"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span>&gt;</span></span><br><span class="line">		delete from user</span><br><span class="line">		where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除用户</span></span><br><span class="line">		<span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testdelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">			String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">			InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">			<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">			SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">			<span class="comment">//3.创建SqlSession</span></span><br><span class="line">			SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">			<span class="comment">//4.执行Sql语句			</span></span><br><span class="line">			<span class="keyword">int</span> d = sqlSession.delete(<span class="string">&quot;user.deleteUserById&quot;</span>, <span class="number">29</span>);</span><br><span class="line">			sqlSession.commit();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/12.png" alt="测试结果"><br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/13.png" alt="测试结果"></p>
<h1 id="Mapper动态代理开发"><a href="#Mapper动态代理开发" class="headerlink" title="Mapper动态代理开发"></a>Mapper动态代理开发</h1><p>使用动态代理方式，动态生成代码，避免书写重复代码.<br>原始Dao开发中存在以下问题：<br>Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法<br>调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不便于开发维护。</p>
<p>Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象。</p>
<p>Mapper接口开发需要遵循以下规范：<br>1、Mapper.xml文件中的namespace与mapper接口的类路径相同。<br>2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同<br>3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同<br>4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p>
<p>这里定义一个<code>UserMapper</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">	<span class="comment">//遵循四个原则</span></span><br><span class="line">	<span class="comment">//接口方法名 == User.xml 中的 id名</span></span><br><span class="line">	<span class="comment">//返回值类型 与 User.xml文件中返回值的类型一致</span></span><br><span class="line">	<span class="comment">//方法的入参类型与User.xml中入参的类型一致</span></span><br><span class="line">	<span class="comment">//mapper标签的命名空间绑定此接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名空间与接口绑定：<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/14.png" alt="命名空间与接口绑定"></p>
<p>书写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> my.study.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisMapperTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">		UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">		</span><br><span class="line">		User user = mapper.findUserById(<span class="number">10</span>);</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/15.png" alt="测试结果"></p>
<p>这样使用动态开发，只需要书写一个接口和一个mapper.xml配置文件就可以了.</p>
<h1 id="Mybatis相比于JDBC的优点"><a href="#Mybatis相比于JDBC的优点" class="headerlink" title="Mybatis相比于JDBC的优点"></a>Mybatis相比于JDBC的优点</h1><p>1、数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。<br>解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。<br>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。<br>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。<br>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</p>
<h1 id="Mybatis和Hibernate区别"><a href="#Mybatis和Hibernate区别" class="headerlink" title="Mybatis和Hibernate区别"></a>Mybatis和Hibernate区别</h1><p>Mybatis和hibernate不同，它不完全是一个ORM框架，因为<code>MyBatis需要程序员自己编写Sql语句</code>。mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p>
<p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是<code>mybatis无法做到数据库无关性</code>，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p>
<p>Hibernate对象/关系映射能力强，<code>数据库无关性好</code>，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce的补充和WordCount简单实战(二)</title>
    <url>/2018/07/29/MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/</url>
    <content><![CDATA[<h1 id="MapReduce编程之WordCount"><a href="#MapReduce编程之WordCount" class="headerlink" title="MapReduce编程之WordCount"></a>MapReduce编程之WordCount</h1><p>基于JAVA开发</p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/1.png"></p>
<p><code>Text</code>参数继承了<code>BinaryComparable</code>并实现了<code>WritableComparable</code>接口，可以把它理解为JAVA里面的字符串。</p>
<p>首先看一些基本的知识：</p>
<ol>
<li><code>Mapper</code>类</li>
</ol>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/2.png"><br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/3.png"></p>
<ul>
<li><code>Context</code>代表的上下文</li>
<li><code>setup</code>代表任务开始的时候执行的操作，且只执行一次。可以在这里进行数据库链接等操作</li>
<li><code>map</code>方法，对于输入的input在每个键值对出发的时候就调用</li>
<li><code>cleanup</code>方法是表示在任务结束的时候执行一次</li>
<li><code>run</code>方法不需要手动调用</li>
</ul>
<p>关键点是重写<code>map</code>方法</p>
<ol start="2">
<li><code>Reducer类</code></li>
</ol>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/4.png"><br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/5.png"></p>
<ul>
<li><code>setup</code>和<code>cleanup</code>方法同<code>mapper</code>方法类似</li>
<li><code>reduce</code>方法，每个键值对都会被调用一次</li>
<li><code>run</code>是写好的模板模式</li>
</ul>
<p>关键点是重写<code>reduce</code>方法</p>
<p>先写好基本框架<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/6.png"></p>
<p>然后复写<code>map</code>和<code>reduce</code>方法</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hadoop.hdfs.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用MapReduce开发WordCount应用程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map:读取输入的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个count</span></span><br><span class="line">        LongWritable plusone = <span class="keyword">new</span> LongWritable(<span class="number">1</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//先读入每一行数据</span></span><br><span class="line">            String line = value.toString();</span><br><span class="line">            <span class="comment">//然后按照指定分隔符分割</span></span><br><span class="line">            String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">                <span class="comment">//使用上下文context进行输出</span></span><br><span class="line">                context.write(<span class="keyword">new</span> Text(word),plusone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reduce:归并操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//Iterable&lt;LongWritable&gt; values是一个集合，因为一个单词交到一个reduce去处理，所以会出现多次</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(LongWritable value:values)&#123;</span><br><span class="line">                sum += value.get();<span class="comment">//通过get()转化为java中的类型</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最终统计结果的输出      写入上下文</span></span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义Driver方法，封装MapReduce作业的所有信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step1 创建configuration()(org.apache.hadoop.conf.Configuration)</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step2 Job.getInstance()拿到一个实例 (org.apache.hadoop.mapreduce.Job;)</span></span><br><span class="line">        Job job = Job.getInstance(configuration,<span class="string">&quot;wordcount&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step3 设置job的处理类(即创建的这个类)</span></span><br><span class="line">        job.setJarByClass(WordCountApp.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step4 设置作业处理的输入路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job,<span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step5 设置Map相关参数</span></span><br><span class="line">        <span class="comment">//step5.1 设置map处理类</span></span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        <span class="comment">//step5.2 设置map的key输出的类型和map的value输出的类型那个</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step6 设置reduce相关参数</span></span><br><span class="line">        <span class="comment">//step6.1 设置reduce处理类</span></span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line">        <span class="comment">//step6.2 设置reduce的key输出类型和value输出类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(LongWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step7 设置作业处理的输出路径</span></span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step8 提交作业并输出结果</span></span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进行打包编译<br>切换到项目目录运行<code>mvn clean package -DskipTests</code><br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/7.png"></p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/8.png"><br>可以看到构建成功</p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/9.png"><br>编译成功后在target目录下</p>
<p>如果mvn命令不能使用需要安装相应环境</p>
<p>这里由于网络原因我下了好久 orz</p>
<p>将jar包拷贝到指定目录<br><code>scp hdfs-1.0-SNAPSHOT.jar ~/lib</code><br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/10.png"></p>
<p>查看hdfs上的文件,并查看全路径</p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/11.png"></p>
<p>运行 jar包<br><code>hadoop jar jar包目录 组类 (在idea中右键选中然后 CopyReference) 要传入的文件路径 要输出的文件路径 </code></p>
<p>我的机器上的指令：<br><code>hadoop jar /home/hadoop/lib/hdfs-1.0-SNAPSHOT.jar hadoop.hdfs.mapreduce.WordCountApp hdfs://localhost:9000/hello.txt hdfs://localhost:9000/hdfsapi/wordcountresult</code></p>
<p>输入文件的内容：<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/14.png"></p>
<p>可以在浏览器 <a href="http://localhost:8088/cluster">http://localhost:8088/cluster</a> 查看yarn的作业</p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/12.png"></p>
<p>查看结果，操作成功<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/13.png"></p>
<p>相同的代码和脚本再次运行会报错，因为在MR中，输出文件是不能存在的。<br>所以要在每次运行后换新的路径或者删除旧的文件<br>可以手工建一个shell脚本或者在JAVA代码中进行操作<br>shell 脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs dfs rm -r 文件路径</span><br><span class="line">hadoop jar jar包目录 组类 (在idea中右键选中然后 CopyReference) 要传入的文件路径 要输出的文件路径</span><br></pre></td></tr></table></figure>
<p>要给脚本加上相应权限<code>chmod u+x 脚本名称</code></p>
<p>在JAVA中完成自动删除功能<br>在//step1 和 //step2 中间清理已经存在的目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//step1.5 准备删除已经存在的文件目录</span></span><br><span class="line">       Path outputPath = <span class="keyword">new</span> Path(args[<span class="number">1</span>]);</span><br><span class="line">       FileSystem fileSystem = FileSystem.get(configuration);</span><br><span class="line">       <span class="keyword">if</span>(fileSystem.exists(outputPath))&#123;</span><br><span class="line">           fileSystem.delete(outputPath,<span class="keyword">true</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;filePath exists,but it has deleted&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>重新编译代码执行，就可以了</p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/15.png"><br>可以看到又一行输出<code>ilePath exists,but it has deleted</code>,同时执行成功</p>
<h1 id="MapReduce编程之Combiner"><a href="#MapReduce编程之Combiner" class="headerlink" title="MapReduce编程之Combiner"></a>MapReduce编程之Combiner</h1><ul>
<li>本地的reducer</li>
<li>减少MapTask输出的数据量及网络传输量</li>
</ul>
<p>在Map过程中先对key相同的值进行一个归并，然后在传输到reduce上，这样就减少了传输的数据数量。可以看成是在map端的一个小的reduce操作。</p>
<p>在上面代码的基础上，在step5的<code>map</code>操作和step6的<code>reduce</code>操作中间价一个<code>combiner</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//step5.5 设置Combiner处理类，其实在逻辑上和reduce是一样的</span><br><span class="line">job.setCombinerClass(MyReducer.class);</span><br></pre></td></tr></table></figure>

<p>重新编译，拷贝到hdfs目录下，执行</p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/16.png"><br>可以看到执行过程中有<code>Combine</code>信息，<code>Combin input records=6</code>和<code>Combin output records=5</code>,说明是生效了的<br>(可以对比之前的操作，combine操作records=0)</p>
<p>虽然它减少了一些数据量，但是它是有适应场景的。<br>在<code>求和</code>、<code>求次数</code>的时候适用，但是在求<code>平均数</code>等操作的时候，结果就会有问题，这里要注意</p>
<h1 id="MapReduce编程之Partitioner"><a href="#MapReduce编程之Partitioner" class="headerlink" title="MapReduce编程之Partitioner"></a>MapReduce编程之Partitioner</h1><ul>
<li>Partitioner决定MapTask输出的数据交由哪个ReduceTask处理</li>
<li>默认实现：分发的key的hash值对ReduceTask个数取模</li>
</ul>
<p>新建一个用来测试的文档：<code>animal.txt</code></p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/18.png"></p>
<p>上传到hdfs中：<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/17.png"></p>
<p>在ieda中，拷贝一份<code>WordCountApp</code>的代码，命名为<code>PartitionerApp</code>.<br>按照空格拆分其实就是<code>动物名字</code>和<code>动物数量</code>，所以在<code>Mapper</code>类的<code>map</code>方法中修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Map:读取输入的文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">           <span class="comment">//先读入每一行数据</span></span><br><span class="line">           String line = value.toString();</span><br><span class="line">           <span class="comment">//然后按照指定分隔符分割</span></span><br><span class="line">           String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">           context.write(<span class="keyword">new</span> Text(words[<span class="number">0</span>]),<span class="keyword">new</span> LongWritable(Long.parseLong(words[<span class="number">1</span>])));</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>还要新建一个<code>Partition</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Text key, LongWritable value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(key.equals(<span class="string">&quot;cat&quot;</span>))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (key.equals(<span class="string">&quot;dog&quot;</span>))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(key.equals(<span class="string">&quot;bird&quot;</span>))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>step6</code> 和 <code>step7</code>之间添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//step6.5 设置job的Partition</span></span><br><span class="line">       job.setPartitionerClass(MyPartitioner.class);</span><br><span class="line">       <span class="comment">//step6.5.1 设置reduce的数量，不然不生效,这里设置4个，因为MyPartitioner类中有4种情况</span></span><br><span class="line">       job.setNumReduceTasks(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>然后编译，将执行的类名和输入的数据改一下<code>hadoop jar /home/hadoop/lib/hdfs-1.0-SNAPSHOT.jar hadoop.hdfs.mapreduce.PartitionerApphadoop.hdfs.mapreduce.PartitionerApp hdfs://localhost:9000//hdfsapi/animal.txt hdfs://localhost:9000/hdfsapi/Partitionresult</code></p>
<p>运行后查看结果<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/19.png"></p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/20.png"></p>
<p>Partition会把符合规则的key送到指定的reduce处理，分别生成相应的结果。</p>
<h1 id="配置jobHistory"><a href="#配置jobHistory" class="headerlink" title="配置jobHistory"></a>配置jobHistory</h1><p>默认情况下这个功能是不开启的<br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/21.png"></p>
<p>找到mapreduce的配置<code>mapred-site.xml</code></p>
<p>在<code>&lt;configuration&gt;&lt;/configuration&gt;</code>中间增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;localhost:10020&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;MR JobHistory Server管理的日志的存放位置&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;localhost:19888&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;查看历史服务器已经运行完的Mapreduce作业记录的web地址，需要启动该服务才行&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobhistory.done-dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mr-history/done&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;MR JobHistory Server管理的日志的存放位置,默认:/mr-history/done&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobhistory.intermediate-done-dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mr-history/mapred/tmp&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;MapReduce作业产生的日志存放位置，默认值:/mr-history/tmp&lt;/description&gt;</span><br></pre></td></tr></table></figure>

<p>保存后先停掉yarn再重启，启动之后还要再启动<code>mr-jobhistory-daemon.sh</code>使用<code>mr-jobhistory-daemon.sh start historyserver</code><br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/22.png"><br>这样就启动成功了<br>可以看到这时候多了一个进程<code>JobHistoryServer</code><br><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/23.png"></p>
<p>还要配置<code>yarn-site.xml</code>.在<code>&lt;configuration&gt;&lt;/configuration&gt;</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;  </span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt; </span><br></pre></td></tr></table></figure>

<p>再次重新启动yarn</p>
<p>使用mapreduce下的例子进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/hadoop/share/hadoop/mapreduce$ hadoop jar hadoop-mapreduce-examples-2.9.0.jar pi 2 3</span><br></pre></td></tr></table></figure>

<p>我在启动后仍然出现问题，重启了hdfs和yarn都没用，不过后来尝试关闭<code>jobhistory</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sbin/mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure>
<p>再重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>
<p>竟然可以了</p>
<p><img src="MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/24.png"></p>
]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习笔记-二</title>
    <url>/2018/11/21/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="parameterType-输入类型"><a href="#parameterType-输入类型" class="headerlink" title="parameterType(输入类型)"></a>parameterType(输入类型)</h1><h2 id="传递简单类型和传递pojo对象"><a href="#传递简单类型和传递pojo对象" class="headerlink" title="传递简单类型和传递pojo对象"></a>传递简单类型和传递pojo对象</h2><p>简单类型：使用#{}占位符，或者${}进行sql拼接。</p>
<p>opjo对象：Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。</p>
<h2 id="传递pojo包装对象"><a href="#传递pojo包装对象" class="headerlink" title="传递pojo包装对象"></a>传递pojo包装对象</h2><p>开发中通过可以使用pojo传递查询条件。<br>查询条件可能是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如查询用户信息的时候，将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</p>
<p>包装对象：Pojo类中的一个属性是另外一个pojo。</p>
<p>需求：根据用户名模糊查询用户信息，查询条件放到QueryVo的user属性中。</p>
<p>在<code>Mybatis学习笔记-一</code>的基础上，继续编写<code>QueryVo</code>类进行开发:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">	<span class="comment">//包含其他的pojo</span></span><br><span class="line">	<span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.user = user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>my.study.mapper</code>包下的<code>User.xml</code>中书写sql语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用包装类型查询用户 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByQueryVo&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.pojo.QueryVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user where username like &quot;%&quot;#&#123;user.username&#125;&quot;%&quot;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>UserMapper.java</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.pojo.QueryVo;</span><br><span class="line"><span class="keyword">import</span> my.study.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">	<span class="comment">//添加方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByQueryVo</span><span class="params">(QueryVo vo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfindUserByQueryVo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">	String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">	InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">	<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">	SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">	<span class="comment">//3.创建SqlSession</span></span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">	<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">	UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">	</span><br><span class="line">	QueryVo vo =<span class="keyword">new</span> QueryVo();</span><br><span class="line">	User u = <span class="keyword">new</span> User();</span><br><span class="line">	u.setUsername(<span class="string">&quot;五&quot;</span>);</span><br><span class="line">	vo.setUser(u);</span><br><span class="line">	List&lt;User&gt; us = mapper.findUserByQueryVo(vo);</span><br><span class="line">	<span class="keyword">for</span>(User user:us) &#123;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/1.png" alt="结果"></p>
<h1 id="resultType-输出类型"><a href="#resultType-输出类型" class="headerlink" title="resultType(输出类型)"></a>resultType(输出类型)</h1><h2 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h2><p>需求：查询user的数量</p>
<p>在<code>UserMapper.java</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">//查询数据条数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">findUserCount</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Mapper.xml中添加查询语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询用户条数 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Integer&quot;</span>&gt;</span></span><br><span class="line">		select count(*) from user</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>书写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询用户条数</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfindUserCount</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">	String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">	InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">	<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">	SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">	<span class="comment">//3.创建SqlSession</span></span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">	<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">	UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">	</span><br><span class="line">	Integer count = mapper.findUserCount();</span><br><span class="line">	System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/2.png" alt="结果"></p>
<h2 id="输出pojo对象和对象列表"><a href="#输出pojo对象和对象列表" class="headerlink" title="输出pojo对象和对象列表"></a>输出pojo对象和对象列表</h2><p>见 <a href="https://homxuwang.github.io/2018/11/19/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/">https://homxuwang.github.io/2018/11/19/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</a></p>
<h1 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h1><p>resultType可以指定将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。</p>
<p>如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。</p>
<p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p>
<p>需求：查询订单表order的所有数据,订单表创建见:<a href="https://homxuwang.github.io/2018/11/19/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/">Mybatis学习笔记-一</a><br>sql：SELECT id, user_id, number, createtime, note FROM <code>order</code></p>
<p>创建POJO类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span>  <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String number;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String note;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">  添加 get/set 方法</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Orders [id=&quot;</span> + id + <span class="string">&quot;, userId=&quot;</span> + userId + <span class="string">&quot;, number=&quot;</span> + number + <span class="string">&quot;, createtime=&quot;</span> + createtime</span><br><span class="line">        + <span class="string">&quot;, note=&quot;</span> + note + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到类中<code>userId</code>字段和数据库表中的<code>user_id</code>字段名不一致<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/3.png" alt="user_id不同"></p>
<p>在<code>my.study.mapper</code>包中添加<code>OrderMapper</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.pojo.Orders;</span><br><span class="line"><span class="keyword">import</span> my.study.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> </span>&#123;	</span><br><span class="line">	<span class="comment">//	查询订单表order的所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Orders&gt; <span class="title">selectOrdersList</span><span class="params">()</span></span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义<code>OrderMapper.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;my.study.mapper.OrderMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 查询所有的订单数据 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrdersList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.Orders&quot;</span>&gt;</span></span><br><span class="line">		SELECT id, user_id,</span><br><span class="line">		number,</span><br><span class="line">		createtime, note FROM orders</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>记得在核心配置文件中引入<code>OrderMapper.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;my/study/mapper/User.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;my/study/mapper/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>书写测试类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询订单表的所有数据</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfindUserCount</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">		OrderMapper mapper =  sqlSession.getMapper(OrderMapper.class);</span><br><span class="line">		</span><br><span class="line">		List&lt;Orders&gt; orderlist = mapper.selectOrdersList();</span><br><span class="line">		<span class="keyword">for</span>(Orders order:orderlist) &#123;</span><br><span class="line">			System.out.println(order);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/4.png" alt="测试结果"><br>可以看到，对于POJO类中和数据库表中字段不一致的，将会查询出null.<br>除了修改为一样的字段值外，可以使用<code>resultMap</code>:<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/5.png" alt="测试结果"><br>其实，与数据库字段不一样的只有<code>user_id</code>和<code>userId</code>，没有必要都写出来，所以可以简写为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;my.study.pojo.Orders&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span>&gt;</span>		</span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<p><code>column</code>对应数据库表字段;<code>property</code>对应POJO字段;<code>javaType</code>对应java类型(可以省略);<code>jdbcType</code>对应数据库中的类型(可以省略)</p>
<p>再次执行测试代码:<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/6.png" alt="测试结果"></p>
<h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><p>通过mybatis提供的各种标签方法实现动态拼接sql</p>
<h2 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h2><p>需求：根据性别和名字查询用户<br>查询sql：<br>SELECT id, username, birthday, sex, address FROM <code>user</code> WHERE sex = 1 AND username LIKE ‘%张%’</p>
<p>在<code>UserMapper.java</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//根据性别和名称查询用户</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUserBySexAndUsername</span><span class="params">(User user)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在<code>User.xml</code>中书写sql语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用if和where标签 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserBySexAndUsername&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user </span><br><span class="line">		where</span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			sex = #&#123;sex&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and username = #&#123;username&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>书写测试类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询用户条数</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testselectUserBySexAndUsername</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">		UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		u.setSex(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		u.setUsername(<span class="string">&quot;张小明&quot;</span>);</span><br><span class="line">		List&lt;User&gt; users = mapper.selectUserBySexAndUsername(u);</span><br><span class="line">		<span class="keyword">for</span>(User user:users) &#123;</span><br><span class="line">			System.out.println(user);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果：<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/7.png" alt="测试结果"></p>
<p>因为通过user实例查询的sex和username字段都不为空，所以可以看到sql语句是正常的.</p>
<p>如果注释掉<code>u.setUsername(&quot;张小明&quot;);</code>再进行测试 :<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/8.png" alt="测试结果"><br>可以看到查询出的是sex为1的所有数据，因为username=null，所以在if标签中没有添加后面的<code>and username = #&#123;username&#125;</code></p>
<p>但是如果注释掉<code>u.setSex(&quot;1&quot;);</code>，将<code>u.setUsername(&quot;张小明&quot;);</code>还原，再次进行测试：<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/9.png" alt="测试结果"><br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/10.png" alt="测试结果"><br>可以看到，查询错误，sql语句是拼接错误的.<br>这时候就需要用到<code>where</code>标签</p>
<h2 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h2><p>where标签可以自动添加where，同时处理sql语句中第一个<code>前</code>and关键字<br>对上面的查询语句做处理:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserBySexAndUsername&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">	select * from user </span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		sex = #&#123;sex&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and username = #&#123;username&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span>		</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再次进行测试：<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/11.png" alt="测试结果"><br>上面提到where标签可以处理sql语句中第一个<code>前</code>and关键字</p>
<h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><p>Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的。<br>先定义一个用于共用的sql片段,然后使用include进行引用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFromUser&quot;</span>&gt;</span></span><br><span class="line">	select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用sql片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserBySexAndUsername&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFromUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		sex = #&#123;sex&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and username = #&#123;username&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span>		</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h2><p>需求：根据多个id查询用户信息<br>在<code>UserMapper</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据多个id查询用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUserByIds</span><span class="params">(QueryVo vo)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<code>QueryVo</code>中改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; idsList;</span><br><span class="line"><span class="comment">//添加get/set方法</span></span><br></pre></td></tr></table></figure>
<p>书写sql：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.pojo.QueryVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFromUser&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		id in</span><br><span class="line">		<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;idsList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">			#&#123;id&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>collection：遍历的集合，这里是QueryVo的idsList属性<br>item：遍历的项目，可以随便写，但是和后面的#{}里面要一致<br>open：在前面添加的sql片段<br>close：在结尾处添加的sql片段<br>separator：指定遍历的元素之间使用的分隔符<br><code>注意</code>:如果接口的方法参数处传递的是数组类型的参数，则需要将collection处值设置为<code>array</code>;同理，如果接口的方法参数处传递的是list类型的参数，则需要将collection处值设置为<code>list</code><br>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多个id</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testselectUserByidsList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">		String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		<span class="comment">//3.创建SqlSession</span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">		UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">		List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		ids.add(<span class="number">16</span>);</span><br><span class="line">		ids.add(<span class="number">22</span>);</span><br><span class="line">		ids.add(<span class="number">24</span>);</span><br><span class="line">		QueryVo vo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">		vo.setIdsList(ids);</span><br><span class="line">		List&lt;User&gt; users = mapper.selectUserByIds(vo);</span><br><span class="line">		<span class="keyword">for</span>(User user:users) &#123;</span><br><span class="line">			System.out.println(user);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果:<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/12.png" alt="测试结果"></p>
<h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/13.png" alt="测试结果"></p>
<h2 id="一对一关联查询"><a href="#一对一关联查询" class="headerlink" title="一对一关联查询"></a>一对一关联查询</h2><p>改造<code>UserMapper</code>,在接口中添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一对一关联 查询  以订单为中心 关联用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Orders&gt; <span class="title">selectOrders</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在<code>User.xml</code>中书写sql(需要用到嵌套映射):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;my.study.pojo.Orders&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderUserResultMap&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;number&quot;</span> <span class="attr">property</span>=<span class="string">&quot;number&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;createtime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createtime&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span>  <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- association ：配置一对一属性 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- property:order里面的User属性名 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- javaType:属性类型 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;my.study.pojo.User&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- id:声明主键，表示user_id是关联查询对象的唯一标识--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderUserResultMap&quot;</span>&gt;</span></span><br><span class="line">		select </span><br><span class="line">		o.id,</span><br><span class="line">		o.user_id,</span><br><span class="line">		o.number,</span><br><span class="line">		o.createtime,</span><br><span class="line">		o.note,</span><br><span class="line">		u.username </span><br><span class="line">		from orders o </span><br><span class="line">		LEFT JOIN user u </span><br><span class="line">		on o.user_id = u.id</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一对一</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testselectOrders</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">	String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">	InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">	<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">	SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">	<span class="comment">//3.创建SqlSession</span></span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">	<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">	UserMapper mapper =  sqlSession.getMapper(UserMapper.class);</span><br><span class="line">	</span><br><span class="line">	List&lt;Orders&gt; orderlist = mapper.selectOrders();</span><br><span class="line">	<span class="keyword">for</span>(Orders order:orderlist) &#123;</span><br><span class="line">		System.out.println(order);</span><br><span class="line">		System.out.println(order.getUser());</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果:<br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/15.png" alt="测试结果"><br><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/14.png" alt="测试结果"></p>
<h2 id="一对多关联查询"><a href="#一对多关联查询" class="headerlink" title="一对多关联查询"></a>一对多关联查询</h2><p>一个用户有可能对应多个订单，所以以user表作为左表进行查询，是一对多的关系。</p>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/16.png" alt="查询结果"></p>
<p>在<code>User</code>类中添加订单列表属性字段,并添加get和set方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> List&lt;Orders&gt; ordersList;</span><br><span class="line"><span class="comment">//get/set</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>OrderMapper</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一对多关联</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<code>OrderMapper.xml</code>中书写sql代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;my.study.pojo.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置一对多属性  </span></span><br><span class="line"><span class="comment">			ofType是指List中每个元素的类型</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;ordersList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;my.study.pojo.Orders&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;number&quot;</span> <span class="attr">property</span>=<span class="string">&quot;number&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;createtime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createtime&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">		select </span><br><span class="line">		o.id,</span><br><span class="line">		o.user_id,</span><br><span class="line">		o.number,</span><br><span class="line">		o.createtime,</span><br><span class="line">		o.note,</span><br><span class="line">		u.username </span><br><span class="line">		from  user u </span><br><span class="line">		LEFT JOIN orders o</span><br><span class="line">		on o.user_id = u.id</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一对多</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testselectUserList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="comment">//1.加载核心配置文件</span></span><br><span class="line">	String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">	InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">	<span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">	SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">	<span class="comment">//3.创建SqlSession</span></span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">	<span class="comment">//4.SqlSession根据接口生成一个实现类</span></span><br><span class="line">	OrderMapper mapper =  sqlSession.getMapper(OrderMapper.class);</span><br><span class="line">	</span><br><span class="line">	List&lt;User&gt; userlist = mapper.selectUserList();</span><br><span class="line">	<span class="keyword">for</span>(User user:userlist) &#123;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">		System.out.println(user.getOrdersList());</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/17.png" alt="测试结果"></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React.js简书项目总结笔记</title>
    <url>/2020/11/05/React-js%E7%AE%80%E4%B9%A6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>前些日子视频学习了用react.js(16.4版本)简单实现简书前端项目的视频，由于拖延症，一直没有把笔记和总结写下来，导致很多细节都遗忘了，今天算是亡羊补牢，把学习过程中的知识点和感受总结一下。</p>
<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>项目以ReactJS为主，结合redux做状态管理，用<code>styled-components</code>做样式组件，axios做异步操作等，来实现一个模仿简书前端项目的单页面应用。项目相对来说比较简单，但“麻雀虽小，五脏俱全”，基本涵盖了对ReactJS操作和使用的知识点。<br>在mock后端数据时，使用了charles做为工具。</p>
<h1 id="用到的组件"><a href="#用到的组件" class="headerlink" title="用到的组件"></a>用到的组件</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@testing-library/jest-dom&quot;</span>: <span class="string">&quot;^4.2.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@testing-library/react&quot;</span>: <span class="string">&quot;^9.5.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@testing-library/user-event&quot;</span>: <span class="string">&quot;^7.2.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;axios&quot;</span>: <span class="string">&quot;^0.20.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;immutable&quot;</span>: <span class="string">&quot;^4.0.0-rc.12&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^16.13.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^16.13.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-redux&quot;</span>: <span class="string">&quot;^7.2.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-router-dom&quot;</span>: <span class="string">&quot;^5.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-scripts&quot;</span>: <span class="string">&quot;3.4.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-transition-group&quot;</span>: <span class="string">&quot;^4.4.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;redux&quot;</span>: <span class="string">&quot;^4.0.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;redux-immutable&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;redux-thunk&quot;</span>: <span class="string">&quot;^2.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;styled-components&quot;</span>: <span class="string">&quot;^5.2.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="项目过程中遇到的问题和总结"><a href="#项目过程中遇到的问题和总结" class="headerlink" title="项目过程中遇到的问题和总结"></a>项目过程中遇到的问题和总结</h1><ol>
<li><p>在管理css样式时，引入styled-components模块。不同组件之间的css互不影响。创建style.js。<br>全局样式引入时，在styled-components的v4版本开始，引入createGlobalStyle。之前的injectGlobal 已被弃用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Globalstyle=createGlobalStyle <span class="string">`</span></span><br><span class="line"><span class="string">    body &#123;</span></span><br><span class="line"><span class="string">        margin: 0;</span></span><br><span class="line"><span class="string">        font-family: -apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;Roboto&#x27;, &#x27;Oxygen&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;Ubuntu&#x27;, &#x27;Cantarell&#x27;, &#x27;Fira Sans&#x27;, &#x27;Droid Sans&#x27;, &#x27;Helvetica Neue&#x27;,</span></span><br><span class="line"><span class="string">        sans-serif;</span></span><br><span class="line"><span class="string">        -webkit-font-smoothing: antialiased;</span></span><br><span class="line"><span class="string">        -moz-osx-font-smoothing: grayscale;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure>
<p>然后在对应的App组件中，作为一个组件引入即可</p>
</li>
<li><p>使用reset.css.不同浏览器的内核，显示内容时，会有略微的差别，例如默认的margin值不同，使用①的全局方案，结合reset.css，设置各种原生html标签的默认值。地址：<a href="https://meyerweb.com/eric/tools/css/reset/">https://meyerweb.com/eric/tools/css/reset/</a></p>
</li>
<li><p>尽量不要在UI组建中写过多的业务逻辑，例如可以将业务逻辑代码写在组件外，然后在生命周期函数中调用外部代码。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.changeHomeData()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑代码主要写在UI组件外，在钩子函数中调用</span></span><br><span class="line"><span class="keyword">const</span> mapStateToDispatch = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="function"><span class="title">changeHomeData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&#x27;/api/home.json&#x27;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = res.data.data</span><br><span class="line">      <span class="keyword">const</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;change_home_data&#x27;</span>,</span><br><span class="line">        <span class="attr">topicList</span>: result.topicList,</span><br><span class="line">        <span class="attr">articleList</span>: result.articleList,</span><br><span class="line">        <span class="attr">recommendList</span>: result.recommendList</span><br><span class="line">      &#125;      </span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;).catch()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>有异步请求的代码，尽量将其使用react-thunk进行管理。</p>
</li>
<li><p>可以使用PureComponent组件替代Component组件，它自己内置了shouldComponentUpdate方法。需要注意的是，<strong>PureComponent组件和immutable.js组件结合使用，才能保证数据一定没有问题</strong>，如果没有使用immutable管理数据，可能会出现坑(不易发觉的错误)。</p>
</li>
<li><p>后台获取参数的方式：</p>
</li>
</ol>
<ul>
<li><p>动态路由:可通过this.props.match.params获取到对应参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js 设置</span></span><br><span class="line">&lt;Route path=<span class="string">&#x27;/detail/:id&#x27;</span>  exact component=&#123;Detail&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用参数的形式（url+?id=xxx）<br>可通过this.props.location.search 对参数进行解析<br><img src="./React-js%E7%AE%80%E4%B9%A6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/1.png" alt="1"></p>
</li>
</ul>
<ol start="7">
<li><p>使用Redirect from ‘react-router-dom’ ，来实现页面跳转</p>
</li>
<li><p>使用react-loadable导出异步组件，做component的异步加载。默认情况下，所有的组件都打包到一个bundle.js文件中，一次加载所有组件，如果组件数量过多，效率会很慢。<br>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">&#x27;react-loadable&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoadableComponent = Loadable(&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./&#x27;</span>), <span class="comment">//代表当前目录下的index.js</span></span><br><span class="line">  <span class="function"><span class="title">loading</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125; <span class="comment">//在加载时，默认显示的内容</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; <span class="xml"><span class="tag">&lt;<span class="name">LoadableComponent</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">&#x27;./pages/detail/loadable.js&#x27;</span></span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// detail/index.js</span></span><br><span class="line"> <span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapStateToDispatch)(withRouter(Detail))</span><br></pre></td></tr></table></figure>
<p><img src="./React-js%E7%AE%80%E4%B9%A6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/2.png" alt="2"><br>使用后，切换网页会异步加载x.chunk.js，说明该异步组件是放在该js文件中，只有访问这个组件的时候才会被加载</p>
<ol start="10">
<li>在使用redux管理数据时，如果store中的文件过多，可以将其分为多个store，然后在根目录将各个store引入，使用时按照规则寻找和使用对应的store即可：<br><img src="./React-js%E7%AE%80%E4%B9%A6%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/3.png" alt="3"></li>
</ol>
<p>这里对sotre文件夹中的各个文件作简要介绍：</p>
<ul>
<li><p>actionCreators.js<br>用于定义action方法，各个方法返回值为一个action对象，这样在使用时直接调用对应方法即可，书写也简洁</p>
</li>
<li><p>constants.js<br>将<code>action</code>中的type定义为<code>常量</code>，在各个文件中使用和书写type时，约定都使用这个文件中定义的常量值，可以避免因拼写错误而难以发现问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> GET_LIST = <span class="string">&#x27;header/GET_LIST&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>index.js<br>仅做导出功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">&#x27;./actionCreators&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;reducer,actionCreators,constants&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>reducer.js<br>在其中定义和初始化state，并且根据sotre传来的action，判断和返回新的store.</p>
</li>
</ul>
<p>这是组件中各个文件的作用，而全局的store，也只是对各组件的sotre做一个规则，类似于统领各个模块的“统帅”，例如本项目中的reducer.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-immutable&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> headerReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;../common/header/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> homeReducer&#125;  <span class="keyword">from</span> <span class="string">&#x27;../pages/home/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> detailReducer&#125;  <span class="keyword">from</span> <span class="string">&#x27;../pages/detail/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">    <span class="attr">header</span>: headerReducer,</span><br><span class="line">    <span class="attr">home</span>: homeReducer,</span><br><span class="line">    <span class="attr">detail</span>: detailReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</span><br></pre></td></tr></table></figure>
<p>本项目中全局sotre中的index.js的作用也是作为默认的引入文件，并对store做一些初始化操作。</p>
<h1 id="使用react-js的感受"><a href="#使用react-js的感受" class="headerlink" title="使用react.js的感受"></a>使用react.js的感受</h1><p>好久之前就想学习一下react，但是由于各种原因（其实就是懒）也迟迟没能付诸行动。由于这是与react.js的初识，并没有在源码和更深入的层面上去探究react，因此只从使用感受方面做一些总结。</p>
<p>ReactJS很好的贯彻了“面向对象编程”的思想，特别而是与Vue框架相比，这种感觉更为明显。因视频中项目使用的版本是<code>React.js 16.4</code>，还未引入React-Hooks，所以在视频学习时，我创建模板时，大部分是以class形式继承React.Component来创建。当然这个版本也支持使用无状态函数来创建组件，在项目中也有应用。</p>
<p>ReactJS与Vue相比，“自由度”很高，但随之带来的也是难度的提升，特别是一些ES6语法和知识点。</p>
<p>要用好ReactJS写好应用，要熟悉ES6的一些语法，并且对于要做的应用，要合理划分模块。</p>
<p>ReactJS的整体使用感受还是很好的，只是随着ReactJS的版本不断迭新，也要不断吸取新的知识，特别是现在React-Hooks也火了起来，后续也将学习一下使用React-Hooks。</p>
<p>本文是使用学习时记下的笔记，并在本文做了整合和整理，仅做自己的学习记录，有不对的地方还往指正~</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Singleton Mode learning Summery</title>
    <url>/2019/08/19/Singleton-Mode-learning-Summery/</url>
    <content><![CDATA[<p>单例模式可以说是最常见的设计模式之一。其实现方式有很多，在此做一些小结。</p>
<p><strong>推荐的实现方法一-静态构造函数</strong></p>
<p>最简单的实现方式，使用静态构造函数(饿汉式)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span></span>&#123;</span><br><span class="line">  <span class="comment">//在类加载的时候进行初始化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造器私有化</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//提供公有的获取方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式在类一开始被装载的时候进行初始化，使用final关键字进行修饰不用担心线程安全问题。但是缺点也很明显，就算不是用这个类它依然会占用内存空间。</p>
<p><strong>实现方法二-双重检查模式</strong></p>
<p>实现按需创建实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// volatile声明作用即是内存变量共享的作用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造器私有化</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      sychronized (Singleton2.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双重检查的写法其实是通过声明了 volatile和 <strong>双重加锁</strong>的方式实现了单例模式，有的人可能会问，为什么锁的内部还要再加一层判断，其实在考虑多线程同时进入了第一层 if判断中时，都在等待着锁的释放，但是释放之后其他线程已经进入了第一层，那么单例模式的结构就会被打乱了，其实锁也可以加在方法上，只不过锁的粒度问题，节省了一点内存。</p>
</blockquote>
<p>如果只进行一次判断:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sychronized (Singleton2.class)&#123;</span><br><span class="line">   <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">     instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果只进行一次同步判断操作，会导致效率很慢，因为在一个时刻只有一个线程能够获得同步锁，当地一个线程获取到锁时，第二个线程只能等待，第一个线程如果发现实例没有创建，它会进行创建实例的操作。接着第一个线程释放同步锁，第二个线程获取到锁，并且运行下面的代码，这时候看到实例已经被第一个线程创建出来了，那么第二个线程就能够获取到对应的单例。<br>每一次通过属性Instance获取单例时，都会视图加上一个同步锁，而加锁又是一个很耗时的操作，所以使用了<strong>双重检查</strong>的方法。</p>
<p><strong>实现方法三-静态内部类实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span></span>&#123;</span><br><span class="line">  <span class="comment">//构造函数私有化</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态内部类不会在一开始被装载，所以不会有方法一的内存消耗问题</span></span><br><span class="line">  <span class="comment">//JVM装载静态内部类是线程安全的 只有在使用内部类的时候才会去装载 所以线程是安全的</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 singleton3 = <span class="keyword">new</span> Singleton3();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//提供静态公有获取方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.singleton3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM装载内部类并不是程序启动就装载(静态内部类和非静态内部类一样，都是在被调用时才会被加载)，而且装载内部类是线程安全的，所以这个单例模式真正意义上实现了<strong>懒加载</strong>与<strong>线程安全</strong>且<strong>节省了内存</strong>.</p>
<p>关于<strong>静态内部类</strong>的一些补充：</p>
<ul>
<li>外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。</li>
<li>实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。</li>
<li>直接调用静态内部类时，外部类不会加载。<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><a href="https://mp.weixin.qq.com/s/OHVMyZJzKIjk3fA7FzDTvg">https://mp.weixin.qq.com/s/OHVMyZJzKIjk3fA7FzDTvg</a><br>《剑指Offer》</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot打包为JAR包后访问不到Resources下的文件问题</title>
    <url>/2019/12/26/SpringBoot%E6%89%93%E5%8C%85%E4%B8%BAJAR%E5%8C%85%E5%90%8E%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0Resources%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近使用SpringBoot进行开发时，需要读取一个本地的文件，所以将文件放到了SpringBoot项目的<code>Resources/static</code>目录下，在使用IDEA运行且访问时，没有问题，但是当发布为JAR包后，却报错，无法找到文件。</p>
<p>在网上找了相关解决方案，说在SpringBoot项目中，为了获取相对路径并且保证程序在打包为JAR后仍然能够读取到对应的文件，要用<code>ClassPathResource</code>类进行读取<br>但是我用了之后仍然不行。</p>
<p>控制台错误打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;message&quot;: &quot;class path resource [static/satellite.txt] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/D:/satellite/satellite/target/satellite-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/static/satellite.txt&quot;,</span><br></pre></td></tr></table></figure>

<p>后来找到原因，在代码中使用File对象创建和读取文件，导致无法获取到对应的文件对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;static/satellite.txt&quot;</span>);</span><br><span class="line">File file = classPathResource.getFile();</span><br></pre></td></tr></table></figure>

<p>猜想原因可能是在打包为JAR后，JAR是一个压缩包，不能直接获取文件对象，要改为用流进行读取和创建，除非真的需要创建文件对象，否则即使获取到文件对象，可能后面也要转为用流进行下一步操作，所以不妨直接用<code>ClassPathResource</code>对象的<code>getInputStream()</code>方法，一步到位获取到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;static/satellite.txt&quot;</span>);</span><br><span class="line"><span class="comment">//打包成jar无法读取文件,要用流读取</span></span><br><span class="line"><span class="comment">//File file = classPathResource.getFile();</span></span><br><span class="line">InputStream inputStream = classPathResource.getInputStream();</span><br></pre></td></tr></table></figure>
<p>修改后可以正常运行了。</p>
]]></content>
      <tags>
        <tag>系统开发记录</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC+Mybatis整合</title>
    <url>/2018/12/01/SpringMVC-Mybatis%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>控制层采用springmvc、持久层使用mybatis实现。<br>首先参考<a href="https://homxuwang.github.io/2018/11/29/Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/">Spring与Mybatis整合</a></p>
<h1 id="所需依赖包"><a href="#所需依赖包" class="headerlink" title="所需依赖包"></a>所需依赖包</h1><p><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/2.png" alt="所需依赖包"><br><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/3.png" alt="所需依赖包"></p>
<h2 id="配置数据库和逆向工程"><a href="#配置数据库和逆向工程" class="headerlink" title="配置数据库和逆向工程"></a>配置数据库和逆向工程</h2><p>数据库表:<br><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/5.png" alt="items表"><br><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/6.png" alt="user表"><br>使用逆向工程生成pojo和dao:<br><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/4.png" alt="pojo和dao"><br>这里可能和上一篇文章中<code>User</code>类和<code>Items</code>类的代码不同，需要进行修改</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><code>applicationContext.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置数据库连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置mybatis核心配置文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:sqlmapConfig.xml&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- Mapper动态代理开发 扫描包 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置基本包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;my.study.springmvc.mapper&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>db.properties</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/springmvc</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=12345</span><br></pre></td></tr></table></figure>

<p><code>log4j.properties</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>
<p><code>sqlmapConfit.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置别名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定扫描包，会把保内所有的类都设置别名，</span></span><br><span class="line"><span class="comment">		别名的名就是类名，大小写不敏感 </span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;my.study.springmvc.mapper&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>web.xml</code>中配置监听器，去读取配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- Spring监听器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/1.png" alt="ContextLoaderListener的位置"><br>配置至此，如果开启tomcat,那么就可以连接数据库了</p>
<h2 id="配置事务"><a href="#配置事务" class="headerlink" title="配置事务"></a>配置事务</h2><p><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/7.png" alt="配置注解事务"><br>在<code>applicationContext.xml</code>中配置注解事务,并开启注解:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启注解 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="从mysql中读取信息并显示"><a href="#从mysql中读取信息并显示" class="headerlink" title="从mysql中读取信息并显示"></a>从mysql中读取信息并显示</h1><p>书写service层代码:<br><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/8.png" alt="service层"><br><code>ItemService.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.Items;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Items&gt; <span class="title">selectItemsList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ItemServiceImpl.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.dao.ItemsMapper;</span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.Items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询商品信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> homxu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemServiceImpl</span> <span class="keyword">implements</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ItemsMapper itemsmapper;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Items&gt; <span class="title">selectItemsList</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> itemsmapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将service代码注入到controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.Items;</span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.service.ItemService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ItemService itemservice;</span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/item/itemlist.action&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemList</span><span class="params">()</span></span>&#123;		</span><br><span class="line">		<span class="comment">//从mysql中查询</span></span><br><span class="line">		List&lt;Items&gt; items = itemservice.selectItemsList();</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.addObject(<span class="string">&quot;itemList&quot;</span>,items);</span><br><span class="line">		mav.setViewName(<span class="string">&quot;itemList&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="SpringMVC-Mybatis%E6%95%B4%E5%90%88/9.png" alt="测试结果"><br>其中@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。关于此注释：<a href="https://www.cnblogs.com/caoyc/p/5626365.html">https://www.cnblogs.com/caoyc/p/5626365.html</a></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Navicat MySQL Data Transfer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Source Server         : localhost_3306</span></span><br><span class="line"><span class="comment">Source Server Version : 50611</span></span><br><span class="line"><span class="comment">Source Host           : localhost:3306</span></span><br><span class="line"><span class="comment">Source Database       : springmvc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Target Server Type    : MYSQL</span></span><br><span class="line"><span class="comment">Target Server Version : 50611</span></span><br><span class="line"><span class="comment">File Encoding         : 65001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date: 2016-05-09 19:45:13</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for items</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `items`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `items` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">  `price` <span class="type">float</span>(<span class="number">10</span>,<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品定价&#x27;</span>,</span><br><span class="line">  `detail` text COMMENT <span class="string">&#x27;商品描述&#x27;</span>,</span><br><span class="line">  `pic` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品图片&#x27;</span>,</span><br><span class="line">  `createtime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生产日期&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of items</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `items` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;台式机&#x27;</span>, <span class="string">&#x27;13000.0&#x27;</span>, <span class="string">&#x27;该电脑质量非常好！！！！&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2016-02-03 13:22:53&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `items` <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;笔记本&#x27;</span>, <span class="string">&#x27;16000.0&#x27;</span>, <span class="string">&#x27;笔记本性能好，质量好！！！！！&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-02-09 13:22:57&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `items` <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;背包&#x27;</span>, <span class="string">&#x27;200.0&#x27;</span>, <span class="string">&#x27;名牌背包，容量大质量好！！！！&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2015-02-06 13:23:02&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">  `birthday` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;2&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;2014-07-10&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;北京市&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;张小明&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;陈小明&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;陈小明&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;河南郑州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;26&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h2><p>逆向工程生成的dao：<br><code>ItemsMapper.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.Items;</span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.ItemsExample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemsMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countByExample</span><span class="params">(ItemsExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByExample</span><span class="params">(ItemsExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Items record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(Items record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Items&gt; <span class="title">selectByExampleWithBLOBs</span><span class="params">(ItemsExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Items&gt; <span class="title">selectByExample</span><span class="params">(ItemsExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Items <span class="title">selectByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleSelective</span><span class="params">(<span class="meta">@Param(&quot;record&quot;)</span> Items record, <span class="meta">@Param(&quot;example&quot;)</span> ItemsExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleWithBLOBs</span><span class="params">(<span class="meta">@Param(&quot;record&quot;)</span> Items record, <span class="meta">@Param(&quot;example&quot;)</span> ItemsExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExample</span><span class="params">(<span class="meta">@Param(&quot;record&quot;)</span> Items record, <span class="meta">@Param(&quot;example&quot;)</span> ItemsExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(Items record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeyWithBLOBs</span><span class="params">(Items record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(Items record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UserMapper.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.User;</span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.UserExample;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countByExample</span><span class="params">(UserExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByExample</span><span class="params">(UserExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(User record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">selectByExample</span><span class="params">(UserExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">selectByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExampleSelective</span><span class="params">(<span class="meta">@Param(&quot;record&quot;)</span> User record, <span class="meta">@Param(&quot;example&quot;)</span> UserExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByExample</span><span class="params">(<span class="meta">@Param(&quot;record&quot;)</span> User record, <span class="meta">@Param(&quot;example&quot;)</span> UserExample example)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(User record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(User record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ItemsMapper.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;my.study.springmvc.dao.ItemsMapper&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;my.study.springmvc.pojo.Items&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;REAL&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;createtime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createtime&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;TIMESTAMP&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ResultMapWithBLOBs&quot;</span> <span class="attr">type</span>=<span class="string">&quot;my.study.springmvc.pojo.Items&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;detail&quot;</span> <span class="attr">property</span>=<span class="string">&quot;detail&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;LONGVARCHAR&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;oredCriteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criteria&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;criteria.valid&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criteria.criteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criterion&quot;</span> &gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">choose</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.noValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.singleValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.betweenValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.listValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criterion.value&quot;</span> <span class="attr">item</span>=<span class="string">&quot;listItem&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">                    #&#123;listItem&#125;</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Update_By_Example_Where_Clause&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;example.oredCriteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criteria&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;criteria.valid&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criteria.criteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criterion&quot;</span> &gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">choose</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.noValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.singleValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.betweenValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.listValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criterion.value&quot;</span> <span class="attr">item</span>=<span class="string">&quot;listItem&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">                    #&#123;listItem&#125;</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span> &gt;</span></span><br><span class="line">    id, name, price, pic, createtime</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Blob_Column_List&quot;</span> &gt;</span></span><br><span class="line">    detail</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByExampleWithBLOBs&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ResultMapWithBLOBs&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.ItemsExample&quot;</span> &gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;distinct&quot;</span> &gt;</span></span><br><span class="line">      distinct</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    ,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Blob_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from items</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;orderByClause != null&quot;</span> &gt;</span></span><br><span class="line">      order by $&#123;orderByClause&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByExample&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.ItemsExample&quot;</span> &gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;distinct&quot;</span> &gt;</span></span><br><span class="line">      distinct</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from items</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;orderByClause != null&quot;</span> &gt;</span></span><br><span class="line">      order by $&#123;orderByClause&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ResultMapWithBLOBs&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> &gt;</span></span><br><span class="line">    select </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    ,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Blob_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from items</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> &gt;</span></span><br><span class="line">    delete from items</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByExample&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.ItemsExample&quot;</span> &gt;</span></span><br><span class="line">    delete from items</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.Items&quot;</span> &gt;</span></span><br><span class="line">    insert into items (id, name, price, </span><br><span class="line">      pic, createtime, detail</span><br><span class="line">      )</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;price,jdbcType=REAL&#125;, </span><br><span class="line">      #&#123;pic,jdbcType=VARCHAR&#125;, #&#123;createtime,jdbcType=TIMESTAMP&#125;, #&#123;detail,jdbcType=LONGVARCHAR&#125;</span><br><span class="line">      )</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertSelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.Items&quot;</span> &gt;</span></span><br><span class="line">    insert into items</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span> &gt;</span></span><br><span class="line">        id,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span> &gt;</span></span><br><span class="line">        name,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price != null&quot;</span> &gt;</span></span><br><span class="line">        price,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;pic != null&quot;</span> &gt;</span></span><br><span class="line">        pic,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createtime != null&quot;</span> &gt;</span></span><br><span class="line">        createtime,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;detail != null&quot;</span> &gt;</span></span><br><span class="line">        detail,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;price,jdbcType=REAL&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;pic != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;pic,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createtime != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;createtime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;detail != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;detail,jdbcType=LONGVARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countByExample&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.ItemsExample&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> &gt;</span></span><br><span class="line">    select count(*) from items</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByExampleSelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> &gt;</span></span><br><span class="line">    update items</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.id != null&quot;</span> &gt;</span></span><br><span class="line">        id = #&#123;record.id,jdbcType=INTEGER&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.name != null&quot;</span> &gt;</span></span><br><span class="line">        name = #&#123;record.name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.price != null&quot;</span> &gt;</span></span><br><span class="line">        price = #&#123;record.price,jdbcType=REAL&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.pic != null&quot;</span> &gt;</span></span><br><span class="line">        pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.createtime != null&quot;</span> &gt;</span></span><br><span class="line">        createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.detail != null&quot;</span> &gt;</span></span><br><span class="line">        detail = #&#123;record.detail,jdbcType=LONGVARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Update_By_Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByExampleWithBLOBs&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> &gt;</span></span><br><span class="line">    update items</span><br><span class="line">    set id = #&#123;record.id,jdbcType=INTEGER&#125;,</span><br><span class="line">      name = #&#123;record.name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      price = #&#123;record.price,jdbcType=REAL&#125;,</span><br><span class="line">      pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,</span><br><span class="line">      createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      detail = #&#123;record.detail,jdbcType=LONGVARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Update_By_Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByExample&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> &gt;</span></span><br><span class="line">    update items</span><br><span class="line">    set id = #&#123;record.id,jdbcType=INTEGER&#125;,</span><br><span class="line">      name = #&#123;record.name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      price = #&#123;record.price,jdbcType=REAL&#125;,</span><br><span class="line">      pic = #&#123;record.pic,jdbcType=VARCHAR&#125;,</span><br><span class="line">      createtime = #&#123;record.createtime,jdbcType=TIMESTAMP&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Update_By_Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKeySelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.Items&quot;</span> &gt;</span></span><br><span class="line">    update items</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span> &gt;</span></span><br><span class="line">        name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price != null&quot;</span> &gt;</span></span><br><span class="line">        price = #&#123;price,jdbcType=REAL&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;pic != null&quot;</span> &gt;</span></span><br><span class="line">        pic = #&#123;pic,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createtime != null&quot;</span> &gt;</span></span><br><span class="line">        createtime = #&#123;createtime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;detail != null&quot;</span> &gt;</span></span><br><span class="line">        detail = #&#123;detail,jdbcType=LONGVARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKeyWithBLOBs&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.Items&quot;</span> &gt;</span></span><br><span class="line">    update items</span><br><span class="line">    set name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      price = #&#123;price,jdbcType=REAL&#125;,</span><br><span class="line">      pic = #&#123;pic,jdbcType=VARCHAR&#125;,</span><br><span class="line">      createtime = #&#123;createtime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      detail = #&#123;detail,jdbcType=LONGVARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.Items&quot;</span> &gt;</span></span><br><span class="line">    update items</span><br><span class="line">    set name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      price = #&#123;price,jdbcType=REAL&#125;,</span><br><span class="line">      pic = #&#123;pic,jdbcType=VARCHAR&#125;,</span><br><span class="line">      createtime = #&#123;createtime,jdbcType=TIMESTAMP&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>UserMapper.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;my.study.springmvc.dao.UserMapper&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;my.study.springmvc.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DATE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;CHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;oredCriteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criteria&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;criteria.valid&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criteria.criteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criterion&quot;</span> &gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">choose</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.noValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.singleValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.betweenValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.listValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criterion.value&quot;</span> <span class="attr">item</span>=<span class="string">&quot;listItem&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">                    #&#123;listItem&#125;</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Update_By_Example_Where_Clause&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;example.oredCriteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criteria&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;criteria.valid&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criteria.criteria&quot;</span> <span class="attr">item</span>=<span class="string">&quot;criterion&quot;</span> &gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">choose</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.noValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.singleValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.betweenValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125; #&#123;criterion.value&#125; and #&#123;criterion.secondValue&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;criterion.listValue&quot;</span> &gt;</span></span><br><span class="line">                  and $&#123;criterion.condition&#125;</span><br><span class="line">                  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;criterion.value&quot;</span> <span class="attr">item</span>=<span class="string">&quot;listItem&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">                    #&#123;listItem&#125;</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span> &gt;</span></span><br><span class="line">    id, username, birthday, sex, address</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByExample&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.UserExample&quot;</span> &gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;distinct&quot;</span> &gt;</span></span><br><span class="line">      distinct</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;orderByClause != null&quot;</span> &gt;</span></span><br><span class="line">      order by $&#123;orderByClause&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> &gt;</span></span><br><span class="line">    select </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> &gt;</span></span><br><span class="line">    delete from user</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByExample&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.UserExample&quot;</span> &gt;</span></span><br><span class="line">    delete from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    insert into user (id, username, birthday, </span><br><span class="line">      sex, address)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;birthday,jdbcType=DATE&#125;, </span><br><span class="line">      #&#123;sex,jdbcType=CHAR&#125;, #&#123;address,jdbcType=VARCHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertSelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    insert into user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;(&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span> &gt;</span></span><br><span class="line">        id,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span> &gt;</span></span><br><span class="line">        username,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null&quot;</span> &gt;</span></span><br><span class="line">        birthday,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span> &gt;</span></span><br><span class="line">        sex,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span> &gt;</span></span><br><span class="line">        address,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;values (&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;)&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;id,jdbcType=INTEGER&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;sex,jdbcType=CHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span> &gt;</span></span><br><span class="line">        #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countByExample&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.UserExample&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> &gt;</span></span><br><span class="line">    select count(*) from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByExampleSelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> &gt;</span></span><br><span class="line">    update user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.id != null&quot;</span> &gt;</span></span><br><span class="line">        id = #&#123;record.id,jdbcType=INTEGER&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.username != null&quot;</span> &gt;</span></span><br><span class="line">        username = #&#123;record.username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.birthday != null&quot;</span> &gt;</span></span><br><span class="line">        birthday = #&#123;record.birthday,jdbcType=DATE&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.sex != null&quot;</span> &gt;</span></span><br><span class="line">        sex = #&#123;record.sex,jdbcType=CHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;record.address != null&quot;</span> &gt;</span></span><br><span class="line">        address = #&#123;record.address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Update_By_Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByExample&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> &gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set id = #&#123;record.id,jdbcType=INTEGER&#125;,</span><br><span class="line">      username = #&#123;record.username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birthday = #&#123;record.birthday,jdbcType=DATE&#125;,</span><br><span class="line">      sex = #&#123;record.sex,jdbcType=CHAR&#125;,</span><br><span class="line">      address = #&#123;record.address,jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Update_By_Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKeySelective&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    update user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span> &gt;</span></span><br><span class="line">        username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null&quot;</span> &gt;</span></span><br><span class="line">        birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span> &gt;</span></span><br><span class="line">        sex = #&#123;sex,jdbcType=CHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span> &gt;</span></span><br><span class="line">        address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;my.study.springmvc.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set username = #&#123;username,jdbcType=VARCHAR&#125;,</span><br><span class="line">      birthday = #&#123;birthday,jdbcType=DATE&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=CHAR&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC学习笔记-一</title>
    <url>/2018/11/30/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,我们可以从Spring的整体结构中看得出来,如下图：<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/1.png" alt="Spring结构"></p>
<p>SpringMVC简单的处理流程图:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/2.png" alt="SpringMVC处理流程"><br>前端控制器可以说是SpringMVC的心脏，是核心部分。</p>
<h1 id="创建入门程序"><a href="#创建入门程序" class="headerlink" title="创建入门程序"></a>创建入门程序</h1><p>创建动态Web工程，导入相关jar包:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/3.png" alt="工程目录"></p>
<h2 id="配置前端控制器"><a href="#配置前端控制器" class="headerlink" title="配置前端控制器"></a>配置前端控制器</h2><p>在<code>web.xml</code>中配置前端控制器:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 默认找 /WEB-INF/[servlet的名称]-servlet.xml --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，在<code>&lt;url-pattern&gt;</code>配置时：<br><code>/*</code>拦截所有，包括jsp和各种静态资源<br><code>*.action</code>或者<code>*.do</code>只拦截以action和do结尾的请求<br><code>/</code>拦截所有，但是不包括jsp</p>
<h2 id="创建springmvc-xml配置文件"><a href="#创建springmvc-xml配置文件" class="headerlink" title="创建springmvc.xml配置文件"></a>创建springmvc.xml配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 扫描包下有@Controller @Service 注解的代码 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;my.study.springmvc.controller&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建Controller，书写入门程序"><a href="#创建Controller，书写入门程序" class="headerlink" title="创建Controller，书写入门程序"></a>创建Controller，书写入门程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.springmvc.pojo.Items;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;	</span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/item/itemlist.action&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemList</span><span class="params">()</span></span>&#123;		</span><br><span class="line">		List&lt;Items&gt; list = <span class="keyword">new</span> ArrayList&lt;Items&gt;();</span><br><span class="line">		list.add(<span class="keyword">new</span> my.study.springmvc.pojo.Items(<span class="number">1</span>, <span class="string">&quot;1&quot;</span>, <span class="number">2399f</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;a&quot;</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Items(<span class="number">2</span>, <span class="string">&quot;28&quot;</span>, <span class="number">2399f</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;d&quot;</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Items(<span class="number">3</span>, <span class="string">&quot;38&quot;</span>, <span class="number">2399f</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;s&quot;</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Items(<span class="number">4</span>, <span class="string">&quot;48&quot;</span>, <span class="number">2399f</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;f&quot;</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Items(<span class="number">5</span>, <span class="string">&quot;58&quot;</span>, <span class="number">2399f</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;x&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.addObject(<span class="string">&quot;itemList&quot;</span>, list);</span><br><span class="line">		mav.setViewName(<span class="string">&quot;/WEB-INF/jsp/itemList.jsp&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类上添加<code>@Controller</code>注解，把Controller交由Spring管理<br><code>@RequestMapping(value = &quot;请求地址&quot;)</code>该方法请求的地址,其中<code>.action</code>可以加也可以不加。<br><code>ModelAndView</code>从字面意思就可以理解，是数据和视图</p>
<p>在<code>/WEB-INF/jsp/</code>路径下创建jsp，用于显示:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>查询商品列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/item/queryitem.action&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">查询条件：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;查询&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">商品列表：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品价格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>生产日期<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品描述<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$&#123;itemList &#125;&quot;</span> <span class="attr">var</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;item.name &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;item.price &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">fmt:formatDate</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;item.createtime&#125;&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;item.detail &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建pojo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Items</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Items</span><span class="params">(Integer id, String name, Float price, Date createtime, String detail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">		<span class="keyword">this</span>.createtime = createtime;</span><br><span class="line">		<span class="keyword">this</span>.detail = detail;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//get/set...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务器访问:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/4.png" alt="工程目录"></p>
<h1 id="SpringMVC架构"><a href="#SpringMVC架构" class="headerlink" title="SpringMVC架构"></a>SpringMVC架构</h1><p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/5.png" alt="SpringMVC架构"><br>架构流程：<br>1、    用户发送请求至前端控制器DispatcherServlet<br>2、    DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>3、    处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。返回的是<code>包名+类名+方法名</code><br>4、    DispatcherServlet通过HandlerAdapter处理器适配器调用处理器<br>5、    执行处理器(Controller，也叫后端控制器)。<br>6、    Controller执行完成返回ModelAndView<br>7、    HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet<br>8、    DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>9、    ViewReslover解析后返回具体View<br>10、    DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。<br>11、    DispatcherServlet响应用户</p>
<p>组件说明:<br>以下组件通常使用框架提供实现：</p>
<ul>
<li><p>   DispatcherServlet：前端控制器<br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
</li>
<li><p>   HandlerMapping：处理器映射器<br>HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
</li>
<li><p>   Handler：处理器<br>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p>
</li>
<li><p>   HandlAdapter：处理器适配器<br>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
</li>
<li><p>ViewResolver：视图解析器<br>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 </p>
</li>
<li><p>   View：视图<br>springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>
</li>
</ul>
<p>在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。<br>需要用户开发的组件有handler、view</p>
<h2 id="默认加载的组件"><a href="#默认加载的组件" class="headerlink" title="默认加载的组件"></a>默认加载的组件</h2><p>我们没有做任何配置，就可以使用这些组件<br>因为框架已经默认加载这些组件了，配置文件位置如下图：</p>
<p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/6.png" alt="默认加载的组件"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Default implementation classes for DispatcherServlet&#x27;s strategy interfaces.</span><br><span class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span><br><span class="line"># Not meant to be customized by application developers.</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></table></figure>

<h2 id="组件扫描器"><a href="#组件扫描器" class="headerlink" title="组件扫描器"></a>组件扫描器</h2><p>使用组件扫描器省去在spring容器配置每个Controller类的繁琐。<br>使用<code>&lt;context:component-scan&gt;</code>自动扫描标记@Controller的控制器类，<br>在springmvc.xml配置文件中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置controller扫描包，多个包之间用,分隔</span></span><br><span class="line"><span class="comment">	扫描包下有@Controller @Service 注解的代码</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;my.study.springmvc&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注解映射器和适配器"><a href="#注解映射器和适配器" class="headerlink" title="注解映射器和适配器"></a>注解映射器和适配器</h2><h3 id="配置处理器映射器"><a href="#配置处理器映射器" class="headerlink" title="配置处理器映射器"></a>配置处理器映射器</h3><p>注解式处理器映射器，对类中标记了@ResquestMapping的方法进行映射。根据@ResquestMapping定义的url匹配@ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器。<br>HandlerMethod对象中封装url对应的方法Method。 </p>
<p>从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。</p>
<p>在springmvc.xml配置文件中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解描述：<br><code>@RequestMapping</code>：定义请求url到处理器功能方法的映射</p>
<h3 id="配置处理器适配器"><a href="#配置处理器适配器" class="headerlink" title="配置处理器适配器"></a>配置处理器适配器</h3><p>注解式处理器适配器，对标记@ResquestMapping的方法进行适配。</p>
<p>从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。</p>
<p>在springmvc.xml配置文件中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置处理器适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">	<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>直接配置处理器映射器和处理器适配器比较麻烦，可以使用注解驱动来加载。<br>SpringMVC使用<code>&lt;mvc:annotation-driven&gt;</code>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter<br>可以在springmvc.xml配置文件中使用<code>&lt;mvc:annotation-driven&gt;</code>替代注解处理器和适配器的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p>视图解析器使用SpringMVC框架默认的InternalResourceViewResolver，这个视图解析器支持JSP视图解析<br>在springmvc.xml配置文件中配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; </span></span><br><span class="line"><span class="comment">		&quot;/WEB-INF/jsp/test.jsp&quot; --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置逻辑视图的前缀 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置逻辑视图的后缀 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为itemList，则最终返回的jsp视图地址:<br>“WEB-INF/jsp/itemList.jsp”</p>
<p>最终jsp物理地址：前缀+逻辑视图名+后缀</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC学习笔记-三</title>
    <url>/2018/12/05/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<p>在<a href="https://homxuwang.github.io/2018/12/02/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/">SpringMVC学习笔记-二</a>的基础上继续进行开发</p>
<h1 id="高级参数绑定"><a href="#高级参数绑定" class="headerlink" title="高级参数绑定"></a>高级参数绑定</h1><h2 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h2><p>需求:在商品列表页面选中多个商品，然后删除。功能要求商品列表页面中的每个商品前有一个checkbok，选中多个商品后点击删除按钮把商品id传递给Controller，根据商品id删除商品信息。<br>前端页面代码进行修改，修改后的页面见附录。<br>Controller代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除多个商品</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/item/deleteItems.action&quot; )</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">deleteItems</span><span class="params">(Integer[] ids)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>调试查看接收到值：<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/1.png" alt="调试结果"></p>
<p>如果将数组作为pojo的内部属性名，则直接在POJO中添加该成员变量，名字与前台的<code>name</code>继续保持一致即可.<br>在<code>QueryVo</code>中添加私有成员变量:<img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/2.png" alt="QueryVo"></p>
<p>修改Controller:<img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/3.png" alt="修改Congtoller"></p>
<p>测试结果:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/4.png" alt="测试结果"></p>
<h2 id="将表单的数据绑定到List"><a href="#将表单的数据绑定到List" class="headerlink" title="将表单的数据绑定到List"></a>将表单的数据绑定到List</h2><p>需求：实现商品数据的批量修改：</p>
<ul>
<li><ol>
<li>在商品列表页面中可以对商品信息进行修改。</li>
</ol>
</li>
<li><ol start="2">
<li>可以批量提交修改后的商品数据。</li>
</ol>
</li>
</ul>
<p>修改<code>QueryVo.java</code>,添加Items的List属性:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> Items items;</span><br><span class="line"><span class="keyword">private</span> Integer[] ids;</span><br><span class="line"><span class="keyword">private</span> List&lt;Items&gt; itemLists;</span><br><span class="line"><span class="comment">//gets/sets...</span></span><br></pre></td></tr></table></figure>
<p>在Controller中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改多个商品</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/item/updatesItems.action&quot; )</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">updatesItems</span><span class="params">(QueryVo vo)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>修改jsp页面,name属性必须是list属性名+下标+元素属性。:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/5.png" alt="修改页面"><br>${current}    当前这次迭代的（集合中的）项<br>${status.first}    判断当前项是否为集合中的第一项，返回值为true或false<br>${status.last}    判断当前项是否为集合中的最<br>varStatus属性常用参数总结下：<br>${status.index}    输出行号，从0开始。<br>${status.count}    输出行号，从1开始。<br>${status.后一项，返回值为true或false<br>begin、end、step分别表示：起始序号，结束序号，跳跃步伐。</p>
<p>测试:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/6.png" alt="前端页面"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/7.png" alt="后台接收值"></p>
<p><code>注意</code>:接收List时，只能放在包装类的属性中，不能直接接收List</p>
<h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h1><p>通过@RequestMapping注解可以定义不同的处理器映射规则。</p>
<h2 id="URL路径映射"><a href="#URL路径映射" class="headerlink" title="URL路径映射"></a>URL路径映射</h2><p>@RequestMapping(value=”item”)或@RequestMapping(“/item”）<br>value的值是数组，可以将多个url映射到同一个方法<br>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &#123; &quot;itemList&quot;, &quot;itemListAll&quot; &#125;)</span></span><br></pre></td></tr></table></figure>
<h2 id="添加在类上面"><a href="#添加在类上面" class="headerlink" title="添加在类上面"></a>添加在类上面</h2><p>在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头</p>
<h2 id="请求方法限定"><a href="#请求方法限定" class="headerlink" title="请求方法限定"></a>请求方法限定</h2><p>除了可以对url进行设置，还可以限定请求进来的方法</p>
<ul>
<li><p>限定GET方法<br>@RequestMapping(method = RequestMethod.GET)</p>
</li>
<li><p>如果通过POST访问则报错：<br>HTTP Status 405 - Request method ‘POST’ not supported</p>
</li>
</ul>
<p>例如：<br>@RequestMapping(value = “itemList”,method = RequestMethod.POST)</p>
<ul>
<li>限定POST方法<br>@RequestMapping(method = RequestMethod.POST)</li>
</ul>
<p>如果通过GET访问则报错：<br>HTTP Status 405 - Request method ‘GET’ not supported</p>
<ul>
<li>GET和POST都可以<br>@RequestMapping(method = {RequestMethod.GET,RequestMethod.POST})</li>
</ul>
<h1 id="Controller方法返回值"><a href="#Controller方法返回值" class="headerlink" title="Controller方法返回值"></a>Controller方法返回值</h1><h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。<br>参考前面的代码</p>
<h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>在Controller方法形参上可以定义request和response，使用request或response指定响应结果：</p>
<ul>
<li><p>1、使用request转发页面，如下：<br>request.getRequestDispatcher(“页面路径”).forward(request, response);<br>request.getRequestDispatcher(“/WEB-INF/jsp/success.jsp”).forward(request, response);</p>
</li>
<li><p>2、可以通过response页面重定向：<br>response.sendRedirect(“url”)<br>response.sendRedirect(“/springmvc-web2/itemEdit.action”);</p>
</li>
<li><p>3、可以通过response指定响应结果，例如响应json数据如下：<br>response.getWriter().print(“{&quot;abc&quot;:123}”);</p>
</li>
</ul>
<p>异步请求使用void比较合适</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回void测试</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;queryItem&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryItem</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 1 使用request进行转发</span></span><br><span class="line">	<span class="comment">// request.getRequestDispatcher(&quot;/WEB-INF/jsp/success.jsp&quot;).forward(request,</span></span><br><span class="line">	<span class="comment">// response);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2 使用response进行重定向到编辑页面</span></span><br><span class="line">	<span class="comment">// response.sendRedirect(&quot;/springmvc-web2/itemEdit.action&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3 使用response直接显示</span></span><br><span class="line">	response.getWriter().print(<span class="string">&quot;&#123;\&quot;abc\&quot;:123&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><h3 id="逻辑视图名"><a href="#逻辑视图名" class="headerlink" title="逻辑视图名"></a>逻辑视图名</h3><p>controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/itemList.jsp</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;itemList&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向"></a>Redirect重定向</h3><p>Contrller方法返回字符串可以重定向到一个url地址<br>如下商品修改提交后重定向到商品编辑页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新商品</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;updateItem&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateItemById</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 更新商品</span></span><br><span class="line">	<span class="keyword">this</span>.itemService.updateItemById(item);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改商品成功后，重定向到商品编辑页面</span></span><br><span class="line">	<span class="comment">// 重定向后浏览器地址栏变更为重定向的地址，</span></span><br><span class="line">	<span class="comment">// 重定向相当于执行了新的request和response，所以之前的请求参数都会丢失</span></span><br><span class="line">	<span class="comment">// 如果要指定请求参数，需要在重定向的url后面添加 ?itemId=1 这样的请求参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;redirect:/itemEdit.action?itemId=&quot;</span> + item.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forward转发"><a href="#forward转发" class="headerlink" title="forward转发"></a>forward转发</h3><p>Controller方法执行后继续执行另一个Controller方法<br>如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新商品</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;updateItem&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateItemById</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 更新商品</span></span><br><span class="line">	<span class="keyword">this</span>.itemService.updateItemById(item);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改商品成功后，重定向到商品编辑页面</span></span><br><span class="line">	<span class="comment">// 重定向后浏览器地址栏变更为重定向的地址，</span></span><br><span class="line">	<span class="comment">// 重定向相当于执行了新的request和response，所以之前的请求参数都会丢失</span></span><br><span class="line">	<span class="comment">// 如果要指定请求参数，需要在重定向的url后面添加 ?itemId=1 这样的请求参数</span></span><br><span class="line">	<span class="comment">// return &quot;redirect:/itemEdit.action?itemId=&quot; + item.getId();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改商品成功后，继续执行另一个方法</span></span><br><span class="line">	<span class="comment">// 使用转发的方式实现。转发后浏览器地址栏还是原来的请求地址，</span></span><br><span class="line">	<span class="comment">// 转发并没有执行新的request和response，所以之前的请求参数都存在</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;forward:/itemEdit.action&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果转发到editItem.action，request可以带过去</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward: /itemEdit.action&quot;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><p>springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。</p>
<h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。<br>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图:</p>
<p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/8.png" alt="异常处理架构"></p>
<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>为了区别不同的异常,通常根据异常类型进行区分，这里我们创建一个自定义系统异常。<br>如果controller、service、dao抛出此类异常说明是系统预期处理的异常信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 异常信息</span></span><br><span class="line">	<span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">			HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">			Object obj,</span></span></span><br><span class="line"><span class="params"><span class="function">			Exception e)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义异常信息</span></span><br><span class="line">				String msg;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 判断异常类型</span></span><br><span class="line">				<span class="keyword">if</span> (e <span class="keyword">instanceof</span> MyException) &#123;</span><br><span class="line">					<span class="comment">// 如果是自定义异常，读取异常信息</span></span><br><span class="line">					msg = e.getMessage();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 如果是运行时异常，则取错误堆栈，从堆栈中获取异常信息</span></span><br><span class="line">					Writer out = <span class="keyword">new</span> StringWriter();</span><br><span class="line">					PrintWriter s = <span class="keyword">new</span> PrintWriter(out);</span><br><span class="line">					e.printStackTrace(s);</span><br><span class="line">					msg = out.toString();</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 把错误信息发给相关人员,邮件,短信等方式</span></span><br><span class="line">				<span class="comment">// TODO</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 返回错误页面，给用户友好页面显示错误信息</span></span><br><span class="line">				ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">				modelAndView.addObject(<span class="string">&quot;msg&quot;</span>, msg);</span><br><span class="line">				modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理器配置"><a href="#异常处理器配置" class="headerlink" title="异常处理器配置"></a>异常处理器配置</h2><p>在<code>springmvc.xml</code>中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringMVC异常处理器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;my.study.springmvc.exception.CustomExceptionResolver&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><p><code>error.jsp</code>:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=ISO-8859-1&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;ISO-8859-1&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=ISO-8859-1&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;error &#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/9.png" alt="异常测试"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/10.png" alt="测试结果"></p>
<h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h2><p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/11.png" alt="在eclipse配置"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/12.png" alt="在eclipse配置"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/13.png" alt="在eclipse配置"></p>
<h2 id="加入jar包"><a href="#加入jar包" class="headerlink" title="加入jar包"></a>加入jar包</h2><p>实现图片上传需要加入的jar包，把两个jar包放到工程的lib文件夹中，如下图：<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/14.png" alt="加入jar包"></p>
<h2 id="jsp页面修改"><a href="#jsp页面修改" class="headerlink" title="jsp页面修改"></a>jsp页面修改</h2><p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/15.png" alt="图片上传"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/16.png" alt="图片上传"></p>
<h2 id="配置上传解析器"><a href="#配置上传解析器" class="headerlink" title="配置上传解析器"></a>配置上传解析器</h2><p>在springmvc.xml中配置文件上传解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传,id必须设置为multipartResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 设置文件上传大小 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5000000&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>更改代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用包装的pojo</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/updateitemQueryVo.action&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">itemEdit</span><span class="params">(QueryVo vo,MultipartFile pictureFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//图片上传</span></span><br><span class="line">		<span class="comment">//设置图片名称，不能重复，可以使用uuid</span></span><br><span class="line">		String picName = UUID.randomUUID().toString();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取文件名</span></span><br><span class="line">		String oriName = pictureFile.getOriginalFilename();</span><br><span class="line">		<span class="comment">//获取图片后缀名</span></span><br><span class="line">		String extName = oriName.substring(oriName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">		<span class="comment">//开始上传</span></span><br><span class="line">		pictureFile.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\homxu\\Desktop\\测试\\&quot;</span>+picName+extName));</span><br><span class="line">		vo.getItems().setPic(picName+extName);</span><br><span class="line">		<span class="comment">//更新信息</span></span><br><span class="line">		itemservice.updateItemsByPojo(vo.getItems());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;forward:/itemEdit.action?id=&quot;</span>+vo.getItems().getId() ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>测试可能报错，是因为之前用的日期格式测试不对，在相应代码处改过来即可<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/17.png" alt="上传结果"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/18.png" alt="上传结果"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/19.png" alt="上传结果"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="itemList-jsp"><a href="#itemList-jsp" class="headerlink" title="itemList.jsp"></a>itemList.jsp</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/fmt&quot;</span>  prefix=<span class="string">&quot;fmt&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;查询商品列表&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/item/queryitem.action&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">查询条件：</span><br><span class="line">&lt;table width=<span class="string">&quot;100%&quot;</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;查询&quot;</span>/&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">商品列表：</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/item/deleteItems.action&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">&lt;table width=<span class="string">&quot;100%&quot;</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;选择&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;生产日期&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品描述&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;操作&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;itemList &#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;ids&quot;</span> value=<span class="string">&quot;$&#123;item.id&#125;&quot;</span>/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.name &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;&lt;fmt:formatDate value=<span class="string">&quot;$&#123;item.createtime&#125;&quot;</span> pattern=<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;td&gt;&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;&quot;</span>&gt;修改&lt;/a&gt;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;删除&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC学习笔记-四</title>
    <url>/2018/12/11/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="json数据交互"><a href="#json数据交互" class="headerlink" title="json数据交互"></a>json数据交互</h1><p>导入处理json的依赖包：<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/1.png" alt="处理json依赖包"></p>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：<br>@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容（json数据）转换为java对象并绑定到Controller方法的参数上。<br>@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象进行绑定</p>
<h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>作用：<br>@ResponseBody注解用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端</p>
<p>本例子应用：<br>@ResponseBody注解实现将Controller方法返回java对象转换为json响应给客户端。</p>
<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>前端代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/js/jquery-3.2.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> &gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> jsonString = <span class="string">&#x27;&#123;&quot;id&quot;: 1,&quot;name&quot;: &quot;测试商品&quot;,&quot;price&quot;: 99.9,&quot;detail&quot;: &quot;测试商品描述&quot;,&quot;pic&quot;: &quot;123456.jpg&quot;&#125;&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	$.ajax(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">url</span> : <span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/json.action&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">data</span> : jsonString,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">contentType</span> : <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">type</span> : <span class="string">&#x27;post&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">dataType</span> : <span class="string">&#x27;json&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">success</span> : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			alert(data.name + <span class="string">&quot; &quot;</span> + data.price);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>后台Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//json</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/json.action&quot; )</span></span><br><span class="line">	<span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Items <span class="title">jsonAction</span><span class="params">(<span class="meta">@RequestBody</span> Items items)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> items;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/2.png" alt="后台接收到数据"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/3.png" alt="前台打印数据"></p>
<h2 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h2><p>如果不使用注解驱动<code>&lt;mvc:annotation-driven /&gt;</code>，就需要给处理器适配器配置json转换器，参考之前学习的自定义参数绑定。</p>
<p>在springmvc.xml配置文件中，给处理器适配器加入json转换器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理器适配器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Spring Web MVC 的处理器拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。<br>实现HandlerInterceptor接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// controller执行后且视图返回后调用此方法</span></span><br><span class="line">	<span class="comment">// 这里可得到执行controller时的异常信息</span></span><br><span class="line">	<span class="comment">// 这里可记录操作日志</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HandlerInterceptor1....afterCompletion&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// controller执行后但未返回视图前调用此方法</span></span><br><span class="line">	<span class="comment">// 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HandlerInterceptor1....postHandle&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Controller执行前调用此方法</span></span><br><span class="line">	<span class="comment">// 返回true表示继续执行，返回false中止执行</span></span><br><span class="line">	<span class="comment">// 这里可以加入登录校验、权限拦截等</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;HandlerInterceptor1....preHandle&quot;</span>);</span><br><span class="line">		<span class="comment">// 设置为true，测试使用</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的拦截器再复制一份HandlerInterceptor2，注意新的拦截器修改代码：<br>System.out.println(“HandlerInterceptor2….preHandle”);</p>
<h2 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h2><p>在<code>springmvc.xml</code>中配置拦截器；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 所有的请求都进入拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置具体的拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;my.study.springmvc.Interceptor.HandlerInterceptor1&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 所有的请求都进入拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置具体的拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;my.study.springmvc.Interceptor.HandlerInterceptor2&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="正常运行流程"><a href="#正常运行流程" class="headerlink" title="正常运行流程"></a>正常运行流程</h3><p>控制台打印：<br>HandlerInterceptor1….preHandle<br>HandlerInterceptor2….preHandle<br>HandlerInterceptor2….postCompletion<br>HandlerInterceptor1….postCompletion<br>HandlerInterceptor2….afterCompletion<br>HandlerInterceptor1….afterCompletion</p>
<h3 id="中断流程测试"><a href="#中断流程测试" class="headerlink" title="中断流程测试"></a>中断流程测试</h3><p>HandlerInterceptor1的preHandler方法返回false，HandlerInterceptor2返回true，运行流程如下：</p>
<p>HandlerInterceptor1..preHandle..</p>
<p>从日志看出第一个拦截器的preHandler方法返回false后第一个拦截器只执行了preHandler方法，其它两个方法没有执行，第二个拦截器的所有方法不执行，且Controller也不执行了。</p>
<p>HandlerInterceptor1的preHandler方法返回true，HandlerInterceptor2返回false，运行流程如下：</p>
<p>HandlerInterceptor1..preHandle..<br>HandlerInterceptor2..preHandle..<br>HandlerInterceptor1..afterCompletion..</p>
<p>从日志看出第二个拦截器的preHandler方法返回false后第一个拦截器的postHandler没有执行，第二个拦截器的postHandler和afterCompletion没有执行，且controller也不执行了。</p>
<p>总结：<br>preHandle按拦截器定义顺序调用<br>postHandler按拦截器定义逆序调用<br>afterCompletion按拦截器定义逆序调用</p>
<p>postHandler在拦截器链内所有拦截器返成功调用<br>afterCompletion只有preHandle返回true才调用</p>
<h2 id="拦截器应用"><a href="#拦截器应用" class="headerlink" title="拦截器应用"></a>拦截器应用</h2><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>1、有一个登录页面，需要写一个Controller访问登录页面<br>2、登录页面有一提交表单的动作。需要在Controller中处理。<br>    a)判断用户名密码是否正确（在控制台打印）<br>    b)如果正确,向session中写入用户信息（写入用户名username）<br>    c)跳转到商品列表<br>3、拦截器。<br>    a)拦截用户请求，判断用户是否登录（登录请求不能拦截）<br>    b)如果用户已经登录。放行<br>    c)如果用户未登录，跳转到登录页面。</p>
<h3 id="编写jsp"><a href="#编写jsp" class="headerlink" title="编写jsp"></a>编写jsp</h3><p>见附录</p>
<h3 id="用户登陆Controller"><a href="#用户登陆Controller" class="headerlink" title="用户登陆Controller"></a>用户登陆Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 跳转到登录页面</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;toLogin&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用户登录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;login&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpSession session)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 校验用户登录</span></span><br><span class="line">		System.out.println(username);</span><br><span class="line">		System.out.println(password);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 把用户名放到session中</span></span><br><span class="line">		session.setAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;redirect:/item/itemList.action&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写拦截器"><a href="#编写拦截器" class="headerlink" title="编写拦截器"></a>编写拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...省略部分代码</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object arg2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 从request中获取session</span></span><br><span class="line">		HttpSession session = request.getSession();</span><br><span class="line">		<span class="comment">// 从session中获取username</span></span><br><span class="line">		Object username = session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">		<span class="comment">// 判断username是否为null</span></span><br><span class="line">		<span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果不为空则放行</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果为空则跳转到登录页面</span></span><br><span class="line">			response.sendRedirect(request.getContextPath() + <span class="string">&quot;/user/toLogin.action&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用户登录配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/item/**&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置具体的拦截器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;my.study.springmvc.Interceptor.LoginHandlerInterceptor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>未登录状态下访问<code>/item/**</code>下的请求都会跳转到登录页面<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/4.png" alt="跳转页面"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="longin-jsp"><a href="#longin-jsp" class="headerlink" title="longin.jsp"></a>longin.jsp</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">	pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/user/login.action&quot;</span>&gt;</span><br><span class="line">&lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;label&gt;密码：&lt;/label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring与Mybatis整合</title>
    <url>/2018/11/29/Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>在不使用Spring的情况下，创建sqlSessionFactory需要两步:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.加载核心配置文件</span></span><br><span class="line">String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;</span><br><span class="line">InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="comment">//2.创建SqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br></pre></td></tr></table></figure>

<p>原始Dao开发时，每一个实现类都要注入一个工厂，然后工厂调用<code>openSession()</code>方法创建SqlSession对象，然后sqlSession再执行sql语句，这一系列存在大量重复代码。</p>
<h1 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h1><p>1、SqlSessionFactory对象应该放到spring容器中作为单例存在。<br>2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。<br>3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。<br>4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。</p>
<h1 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h1><p><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/1.png" alt="依赖包"><br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/2.png" alt="依赖包"></p>
<h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><p><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/4.png" alt="依赖包"><br><code>applicationContext.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- dbcp数据源(配置数据库连接池) --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置mybatis核心配置文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:sqlmapConfig.xml&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>maxActive</code>表示连接池最大连接数，<code>maxIdle</code>表示最大空闲</p>
<p><code>db.properties</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=12345</span><br></pre></td></tr></table></figure>
<p><code>log4j.properties</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>sqlmapConfig.xml</code></p>
<p><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/3.png" alt="依赖包"></p>
<h1 id="Mapper代理形式开发dao"><a href="#Mapper代理形式开发dao" class="headerlink" title="Mapper代理形式开发dao"></a>Mapper代理形式开发dao</h1><h2 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h2><p>程序结构:<br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/4.png" alt="依赖包"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.mybatis.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>applicationContext.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mpper动态代理开发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;my.study.mybatis.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>sqlmapConfig.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;my.study.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 根据用户id查询 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;my.study.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		select * from user where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mybatis.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String sex;</span><br><span class="line">	<span class="keyword">private</span> Date birthday;</span><br><span class="line">	<span class="keyword">private</span> String address;</span><br><span class="line">	<span class="comment">//get/set...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mybatis.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.mybatis.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> my.study.mybatis.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		UserMapper mapper = (UserMapper) <span class="keyword">this</span>.context.getBean(<span class="string">&quot;userMapper&quot;</span>);</span><br><span class="line">		User user = mapper.selectUserById(<span class="number">1</span>);</span><br><span class="line">		System.out.println(user);			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/5.png" alt="测试结果"></p>
<p><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/8.png" alt="关系图"></p>
<h2 id="扫描包形式配置mapper"><a href="#扫描包形式配置mapper" class="headerlink" title="扫描包形式配置mapper"></a>扫描包形式配置mapper</h2><p>使用扫描方式不需要手动再注入工厂，它会扫描spring中配置的工厂,只需制定基本包就可以</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mapper动态代理开发 扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置基本包 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;my.study.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用这种方式，每个mapper代理对象的id就是类名，首字母小写</p>
<p>注解掉之前配置的Mpper动态代理开发:<br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/10.png" alt="配置"></p>
<p>使用扫描方式进行注入，不需要指定id,没有id的情况下，无法指定id，则需要指定实现类:<br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/9.png" alt="修改代码"><br>然后进行测试:<br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/11.png" alt="修改代码"></p>
<h1 id="传统dao的开发方式"><a href="#传统dao的开发方式" class="headerlink" title="传统dao的开发方式"></a>传统dao的开发方式</h1><p><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/6.png" alt="添加的类和接口"></p>
<p><code>UserDao</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.mybatis.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	<span class="function">User <span class="title">selectUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserDaoImpl</code>类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.support.SqlSessionDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.mybatis.pojo.User;</span><br><span class="line"><span class="comment">//继承SqlSessionDaoSupport可以不用再在此类声明工厂，而是交给父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取SqlSession</span></span><br><span class="line">		SqlSession sqlSession = <span class="keyword">super</span>.getSqlSession();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用SqlSession执行操作</span></span><br><span class="line">		User user = sqlSession.selectOne(<span class="string">&quot;selectUserById&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不要关闭sqlSession</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserDaoImpl</code>继承<code>SqlSessionDaoSupport</code>可以使Spring在父类创建工厂</p>
<p><code>sqlmapConfig.xml</code>配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;my.study.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>applicationContext.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dao --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.mybatis.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入工厂 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>书写测试类<code>UserDaoTest.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.mybatis.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.mybatis.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> my.study.mybatis.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取userDao</span></span><br><span class="line">		UserDao userDao = <span class="keyword">this</span>.context.getBean(UserDao.class);</span><br><span class="line"></span><br><span class="line">		User user = userDao.selectUserById(<span class="number">1</span>);</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/7.png" alt="测试结果"></p>
<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><p>使用官方网站的Mapper自动生成工具mybatis-generator-core-1.3.2来生成po类和Mapper映射文件<br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/12.png" alt="程序目录"></p>
<p>运行时，主程序会读取配置文件，进行生成</p>
<p>配置文件<code>generatorConfig.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- id随便取 targetRuntime是MyBatis3版本--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;testTables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">password</span>=<span class="string">&quot;12345&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;</span></span><br><span class="line"><span class="comment">			connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; </span></span><br><span class="line"><span class="comment">			userId=&quot;yycg&quot;</span></span><br><span class="line"><span class="comment">			password=&quot;yycg&quot;&gt;</span></span><br><span class="line"><span class="comment">		&lt;/jdbcConnection&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 </span></span><br><span class="line"><span class="comment">			NUMERIC 类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- targetProject:生成PO类的位置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;my.study.mybatis.pojo&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;my.study.mybatis.mapper&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">targetPackage</span>=<span class="string">&quot;my.study.mybatis.mapper&quot;</span> </span></span><br><span class="line"><span class="tag">			<span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定数据库表 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">schema</span>=<span class="string">&quot;&quot;</span> <span class="attr">tableName</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">schema</span>=<span class="string">&quot;&quot;</span> <span class="attr">tableName</span>=<span class="string">&quot;orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 有些表的字段需要指定java类型</span></span><br><span class="line"><span class="comment">		 &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="comment">			&lt;columnOverride column=&quot;id&quot; javaType=&quot;Long&quot; /&gt;</span></span><br><span class="line"><span class="comment">		&lt;/table&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.XMLParserException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorSqlmap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//指定逆向工程配置文件</span></span><br><span class="line">		File configFile = <span class="keyword">new</span> File(<span class="string">&quot;generatorConfig.xml&quot;</span>); </span><br><span class="line">		ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">		Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">		DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">		MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config,</span><br><span class="line">				callback, warnings);</span><br><span class="line">		myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			GeneratorSqlmap generatorSqlmap = <span class="keyword">new</span> GeneratorSqlmap();</span><br><span class="line">			generatorSqlmap.generator();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主程序运行,查看日志:<br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/13.png" alt="程序目录"><br>刷新后，可以看到已经生成了对应的文件:<br><img src="Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/14.png" alt="刷新目录"></p>
<p>1.逆向工程生成的代码只能做单表查询<br>2.不能在生成的代码上进行扩展，因为如果数据库变更，需要重新使用逆向工程生成代码，原来编写的代码就被覆盖了。<br>3.一张表会生成4个文件<br>4.<code>*Example.java</code>文件中封装了很多方便的方法可以用来调用</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC学习笔记-二</title>
    <url>/2018/12/02/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h2><p>需求：打开商品编辑页面，展示商品信息</p>
<p>在<a href="https://homxuwang.github.io/2018/12/01/SpringMVC-Mybatis%E6%95%B4%E5%90%88/">SpringMVC+Mybatis整合</a><br>的基础上，进行商品编辑的功能开发。</p>
<p>需求分析:编辑商品信息，首先要显示商品详情<br>需要根据商品id查询商品信息，然后展示到页面。<br>请求的url：/itemEdit.action<br>参数：id（商品id）<br>响应结果：商品编辑页面，展示商品详细信息。</p>
<p>在<code>ItemService.java</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过id查询某个商品</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Items <span class="title">selectItemsById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<code>ItemServiceImpl.java</code>类中实现方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询某个商品</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Items <span class="title">selectItemsById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> itemsmapper.selectByPrimaryKey(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Controller中书写方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过id查询某个商品</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/itemEdit.action&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemEdit</span><span class="params">(HttpServletRequest request,HttpServletResponse response</span></span></span><br><span class="line"><span class="params"><span class="function">    ,HttpSession session,Model model)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取id</span></span><br><span class="line">  String id = request.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//查询商品</span></span><br><span class="line">  Items item = itemservice.selectItemsById(Integer.parseInt(id));</span><br><span class="line">  </span><br><span class="line">  ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">  mav.addObject(<span class="string">&quot;item&quot;</span>, item);</span><br><span class="line">  mav.setViewName(<span class="string">&quot;editItem&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/1.png"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/2.png"><br>测试结果:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/3.png"></p>
<h2 id="绑定简单类型"><a href="#绑定简单类型" class="headerlink" title="绑定简单类型"></a>绑定简单类型</h2><p>当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。<br>这样，从Request取参数的方法就可以进一步简化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过id查询某个商品</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/itemEdit.action&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemEdit</span><span class="params">(Integer id,HttpServletRequest request,HttpServletResponse response</span></span></span><br><span class="line"><span class="params"><span class="function">			,HttpSession session,Model model)</span> </span>&#123;		</span><br><span class="line">		<span class="comment">//查询商品</span></span><br><span class="line">		Items item = itemservice.selectItemsById(id);</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.addObject(<span class="string">&quot;item&quot;</span>, item);</span><br><span class="line">		mav.setViewName(<span class="string">&quot;editItem&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>当请求的参数名称和处理器形参名称不一致时，使用@RequestParam常用于处理简单类型的绑定。</p>
<p>value：参数名字，即入参的请求参数名字，如value=“itemId”表示请求的参数区中的名字为itemId的参数的值将传入</p>
<p>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报错<br>TTP Status 400 - Required Integer parameter ‘XXXX’ is not present<br>如果想设置为可以为空，则将requied设置为false</p>
<p>defaultValue：默认值，表示如果请求中没有同名参数时的默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过id查询某个商品</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/itemEdit.action&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemEdit</span><span class="params">(<span class="meta">@RequestParam(value=&quot;id&quot;,required=false,defaultValue=&quot;1&quot;)</span> Integer value,HttpServletRequest request,HttpServletResponse response</span></span></span><br><span class="line"><span class="params"><span class="function">			,HttpSession session,Model model)</span> </span>&#123;		</span><br><span class="line">		<span class="comment">//查询商品</span></span><br><span class="line">		Items item = itemservice.selectItemsById(value);</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.addObject(<span class="string">&quot;item&quot;</span>, item);</span><br><span class="line">		mav.setViewName(<span class="string">&quot;editItem&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数绑定之POJO"><a href="#参数绑定之POJO" class="headerlink" title="参数绑定之POJO"></a>参数绑定之POJO</h2><p>如果提交的参数很多，或者提交的表单中的内容很多的时候,可以使用简单类型接受数据,也可以使用pojo接收数据。<br>要求：pojo对象中的属性名和表单中input的name属性一致。</p>
<p>ItemService里编写接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过pojo更新商品信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateItemsByPojo</span><span class="params">(Items item)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ItemServiceImpl.java编写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过pojo更新商品信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateItemsByPojo</span><span class="params">(Items items)</span> </span>&#123;</span><br><span class="line">		items.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">		itemsmapper.updateByPrimaryKeyWithBLOBs(items);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在Controller中书写代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/updateitem.action&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemEdit</span><span class="params">(Items items)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//更新信息</span></span><br><span class="line">		itemservice.updateItemsByPojo(items);</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.addObject(<span class="string">&quot;item&quot;</span>, items);</span><br><span class="line">		mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/4.png" alt="测试结果"><br>但是提交的内容会有乱码<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/6.png" alt="乱码"></p>
<h2 id="解决提交内容乱码问题"><a href="#解决提交内容乱码问题" class="headerlink" title="解决提交内容乱码问题"></a>解决提交内容乱码问题</h2><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p>在web.xml中加入过滤器，解决post提交乱码问题：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决post乱码问题 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 设置编码参是UTF8 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/5.png" alt="web.xml配置"><br>再次修改测试：<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/7.png" alt="测试结果"></p>
<h2 id="参数绑定之包装的POJO"><a href="#参数绑定之包装的POJO" class="headerlink" title="参数绑定之包装的POJO"></a>参数绑定之包装的POJO</h2><p>使用包装的pojo接收商品信息的查询条件。<br>创建包装对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.springmvc.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Items items;</span><br><span class="line">  <span class="comment">//get/set...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller中的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用包装的pojo</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/updateitemQueryVo.action&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">itemEdit</span><span class="params">(QueryVo vo)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//更新信息</span></span><br><span class="line">		itemservice.updateItemsByPojo(vo.getItems());</span><br><span class="line">		</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这时候前端页面要修改为其<code>成员变量.属性名</code>的格式:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/8.png" alt="修改前端页面"><br>修改form的提交地址后测试，可以看到后台正确接收到值，并且修改成功<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/9.png" alt="后台接受正确"><br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/10.png" alt="修改成功"></p>
<h2 id="自定义参数绑定"><a href="#自定义参数绑定" class="headerlink" title="自定义参数绑定"></a>自定义参数绑定</h2><p>需求：在商品修改页面可以修改商品的生产日期，并且根据业务需求自定义日期格式。</p>
<p>由于日期数据有很多种格式，springmvc没办法把字符串转换成日期类型。所以需要自定义参数绑定。<br>负责处理这部分的是springMVC的适配器<br>在jsp页面添加显示和修改日期的部分:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;商品生产日期&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;items.createtime&quot;</span></span><br><span class="line">    value=<span class="string">&quot;&lt;fmt:formatDate value=&quot;</span>$&#123;item.createtime&#125;<span class="string">&quot; pattern=&quot;</span>yyyy-MM-dd HH:mm:ss<span class="string">&quot;/&gt;&quot;</span> /&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>
<p>吧<code>ItemServiceImpl.java</code>中写入时间的代码删除:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过pojo更新商品信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateItemsByPojo</span><span class="params">(Items items)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		items.setCreatetime(new Date());</span></span><br><span class="line">		itemsmapper.updateByPrimaryKeyWithBLOBs(items);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>自定义Converter,假如传入的日期为<code>2018:12-04 16_:_34-26</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Converter&lt;S, T&gt;</span></span><br><span class="line"><span class="comment">//S:source,需要转换的源的类型</span></span><br><span class="line"><span class="comment">//T:target,需要转换的目标类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 把字符串转换为日期类型</span></span><br><span class="line">			SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy:MM-dd HH_mm-ss&quot;</span>);</span><br><span class="line">			Date date = simpleDateFormat.parse(source);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> date;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果转换异常则返回空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>springmvc.xml</code>中配置Converter:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;ConversionServiceFactory&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 转换器配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ConversionServiceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;my.study.springmvc.conversion.DateConverter&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在修改日期处填写日期<code>2016:12-04 16_43-52</code>进行测试:<br><img src="SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/11.png" alt="修改成功"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="editItem-jsp"><a href="#editItem-jsp" class="headerlink" title="editItem.jsp"></a>editItem.jsp</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/fmt&quot;</span>  prefix=<span class="string">&quot;fmt&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;修改商品信息&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt; </span><br><span class="line">	&lt;!-- 上传图片是需要指定属性 enctype=<span class="string">&quot;multipart/form-data&quot;</span> --&gt;</span><br><span class="line">	&lt;!-- &lt;form id=<span class="string">&quot;itemForm&quot;</span> action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt; --&gt;</span><br><span class="line">	&lt;form id=<span class="string">&quot;itemForm&quot;</span>	action=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/updateitem.action&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">		&lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;$&#123;item.id &#125;&quot;</span> /&gt; 修改商品信息：</span><br><span class="line">		&lt;table width=<span class="string">&quot;100%&quot;</span> border=<span class="number">1</span>&gt;</span><br><span class="line">			&lt;tr&gt;</span><br><span class="line">				&lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">				&lt;td&gt;&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;$&#123;item.name &#125;&quot;</span> /&gt;&lt;/td&gt;</span><br><span class="line">			&lt;/tr&gt;</span><br><span class="line">			&lt;tr&gt;</span><br><span class="line">				&lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">				&lt;td&gt;&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;price&quot;</span> value=<span class="string">&quot;$&#123;item.price &#125;&quot;</span> /&gt;&lt;/td&gt;</span><br><span class="line">			&lt;/tr&gt;</span><br><span class="line">			&lt;tr&gt;</span><br><span class="line">				&lt;td&gt;商品简介&lt;/td&gt;</span><br><span class="line">				&lt;td&gt;&lt;textarea rows=<span class="string">&quot;3&quot;</span> cols=<span class="string">&quot;30&quot;</span> name=<span class="string">&quot;detail&quot;</span>&gt;$&#123;item.detail &#125;&lt;/textarea&gt;</span><br><span class="line">				&lt;/td&gt;</span><br><span class="line">			&lt;/tr&gt;</span><br><span class="line">			&lt;tr&gt;</span><br><span class="line">				&lt;td colspan=<span class="string">&quot;2&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">				&lt;/td&gt;</span><br><span class="line">			&lt;/tr&gt;</span><br><span class="line">		&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记-一</title>
    <url>/2018/11/09/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<p> Spring是一个一站式框架。Spring可以看做是一个容器，所有对象都可以在其中进行管理<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/Spring1.png"></p>
<h1 id="Spring-搭建基本环境"><a href="#Spring-搭建基本环境" class="headerlink" title="Spring 搭建基本环境"></a>Spring 搭建基本环境</h1><p>首先导入Spring所需依赖包：<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/1.png" alt="导入依赖包"></p>
<p>创建一个对象用于测试：</p>
<p><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/2.png" alt="创建对象"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;User 的空参构造方法被调用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要书写配置文件，并将创建好的对象注册到Spring容器中。<br>建议将配置文件放到源码文件夹根目录(/src)下，文件名可以任意取。</p>
<p>导入配置文件的约束：Preference中搜索<code>XML Catlog</code>，打开后点击<code>Add</code>-&gt;<code>FileSystem...</code><br>选择Spring解压目录下的<code>schema</code>-&gt;<code>beans</code>-&gt;<code>spring-beans-4.2.xsd</code>(选择最新版本(我的是4.2)即可)</p>
<p>继续选择<code>Kye Type</code>-&gt;<code>Scheme location</code>：<br>把<code>Location</code>中<code>spring-beans-4.2.xsd</code>文件名复制，追加到<code>Key</code>中(注意补一个<code>/</code>).<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/3.png" alt="导入约束"></p>
<p>然后在配置文件中，输入<code>&lt;beans&gt;&lt;/beans&gt;</code>后，在Eclipse下切换到设计视图，选中<code>beans</code>-&gt;右键选中<code>Edit Namespaces</code>-&gt;点击<code>Add</code>-&gt;勾选<code>xsi</code>-&gt;点击ok-&gt;继续点击<code>Add</code>-&gt;选择<code>Specify New Namespace</code>-&gt;选择<code>Browse</code>-&gt;选择<code>Select XML Catalog entry</code>-&gt;找到刚才上图的Key-&gt;<code>Namespace Name</code>填写Key中<code>http://www.spri.....beans</code>的内容，<code>Prefix</code>不用写</p>
<p><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/4.png" alt="导入约束"></p>
<p>导入成功</p>
<p>最后将对象注册到容器进行测试：<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/5.png" alt="注册对象"></p>
<p><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/6.png" alt="注册对象"></p>
<h1 id="ApplicationContext-amp-BeanFactory"><a href="#ApplicationContext-amp-BeanFactory" class="headerlink" title="ApplicationContext&amp;BeanFactory"></a>ApplicationContext&amp;BeanFactory</h1><p><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/7.png" alt="注册对象"></p>
<p><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/8.png" alt="注册对象"></p>
<p>简单介绍：<br>其中BeanFactory作为最顶层的接口，功能较为单一。BeanFactory接口实现类的容器，特点是每次获得对象时才会创建对象。</p>
<p>ApplicationContext在每次容器启动时，就会创建容器中的所有对象</p>
<h1 id="Spring的配置"><a href="#Spring的配置" class="headerlink" title="Spring的配置"></a>Spring的配置</h1><h2 id="bean-元素"><a href="#bean-元素" class="headerlink" title="bean 元素"></a>bean 元素</h2><p>以前面配置User对象为例。</p>
<blockquote>
<p><code>bean</code>标签：<br>使用该元素描述需要spring容器管理的对象<br>class属性:被管理对象的完整类名.<br>name属性:给被管理的对象起个名字.获得对象时根据该名称获得对象. 特点:可以重复.可以使用特殊字符.<br>id属性: 与name属性一样.特点:名称不可重复.不能使用特殊字符.</p>
</blockquote>
<h3 id="Scope属性"><a href="#Scope属性" class="headerlink" title="Scope属性"></a>Scope属性</h3><h4 id="singleton-默认值"><a href="#singleton-默认值" class="headerlink" title="singleton(默认值)"></a>singleton(默认值)</h4><p>单例对象.被标识为单例的对象在spring容器中只会存在一个实例，即默认为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User&quot; class=&quot;my.study.bean.User&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1.创建容器对象</span></span><br><span class="line">  ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;my/study/b_create/applicationContext.xml&quot;</span>);</span><br><span class="line">  <span class="comment">//2.在容器中寻找&quot;User&quot;对象</span></span><br><span class="line">  User u = (User) ac.getBean(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">  User u1 = (User) ac.getBean(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">  <span class="comment">//3打印user对象</span></span><br><span class="line">  System.out.println(u == u1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>多例原型.被标识为多例的对象,每次再获得才会创建.每次创建都是新的对象.<br>注意，当整合struts2时,ActionBean必须配置为多例的。因为Action对象是由Spring容器管理的，struts2每次请求都会创建一个Action<br>将配置文件改为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User&quot; class=&quot;my.study.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>继续用test1()测试，打印结果为<code>false</code></p>
<h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><p>在web环境下.对象与request生命周期一致.即每当请求完成，对象就会在Spring中移除</p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>在web环境下,对象与session生命周期一致.即在一次会话中，会话完成后,对象就会在Spring中被移除</p>
<h3 id="生命周期属性"><a href="#生命周期属性" class="headerlink" title="生命周期属性"></a>生命周期属性</h3><p>如果希望Bean在创建时有初始化方法，可以指定Bean中的一个方法为其初始化方法，Spring会在对象创建完成后调用。即<code>init-method</code><br>同样可以配置一个销毁方法，Spring容器在关闭前调用此方法。<code>destory-method</code><br>注意<code>scope=&quot;prototype&quot;</code>不能和<code>destory-method</code>标签一起使用</p>
<h2 id="Spring的分模块配置"><a href="#Spring的分模块配置" class="headerlink" title="Spring的分模块配置"></a>Spring的分模块配置</h2><p>在主配置文件中引入其他配置文件，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>目录写在src目录下的全包名和配置文件名</p>
<h2 id="Spring创建对象的方式"><a href="#Spring创建对象的方式" class="headerlink" title="Spring创建对象的方式"></a>Spring创建对象的方式</h2><p>创建新的配置文件和类进行测试</p>
<p><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/9.png" alt="创建对象的方式"><br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/10.png" alt="创建对象的方式"></p>
<p><code>UserFactory</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;静态工厂方式创建User&quot;</span>);		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">createUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;实例工厂方式创建User&quot;</span>);		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>applicationContext.xml</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 方式1：空参构造创建 --&gt;</span><br><span class="line">	&lt;bean name=&quot;User&quot; class=&quot;my.study.bean.User&quot;&gt;&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 方式2：静态工厂创建</span><br><span class="line">		调用UserFactory的createUser方法创建名为user2的对象，放入容器</span><br><span class="line">	 --&gt;</span><br><span class="line">	&lt;bean name=&quot;User2&quot; class=&quot;my.study.bean.UserFactory&quot; factory-method=&quot;createUser&quot;&gt;&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 方式3：实例工厂创建</span><br><span class="line">		调用UserFactory的createUser方法创建名为user3的对象，放入容器</span><br><span class="line">	 --&gt;</span><br><span class="line">	&lt;bean name=&quot;User3&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;createUser2&quot;&gt;&lt;/bean&gt;</span><br><span class="line">	&lt;bean name=&quot;userFactory&quot; class=&quot;my.study.bean.UserFactory&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="空参构造方式"><a href="#空参构造方式" class="headerlink" title="空参构造方式"></a>空参构造方式</h3><p>空参构造方式就是最开始配置bean时的构造方式，前面已经有结果。当然这里要注意，创建容器对象时，传参时要传入的配置文件需要加上包名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;my/study/b_create/applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a>静态工厂方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//静态工厂方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1.创建容器对象</span></span><br><span class="line">  ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;my/study/b_create/applicationContext.xml&quot;</span>);</span><br><span class="line">  <span class="comment">//2.向容器请求&quot;user&quot;对象</span></span><br><span class="line">  User u = (User) ac.getBean(<span class="string">&quot;User2&quot;</span>);</span><br><span class="line">  <span class="comment">//3打印user对象</span></span><br><span class="line">  System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例工厂方式"><a href="#实例工厂方式" class="headerlink" title="实例工厂方式"></a>实例工厂方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//动态工厂方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1.创建容器对象</span></span><br><span class="line">  ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;my/study/b_create/applicationContext.xml&quot;</span>);</span><br><span class="line">  <span class="comment">//2.向容器请求&quot;user&quot;对象</span></span><br><span class="line">  User u = (User) ac.getBean(<span class="string">&quot;User3&quot;</span>);</span><br><span class="line">  <span class="comment">//3打印user对象</span></span><br><span class="line">  System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring属性注入"><a href="#Spring属性注入" class="headerlink" title="Spring属性注入"></a>Spring属性注入</h1><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><h3 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h3><p>新建一个包，在配置文件<code>&lt;bean&gt;&lt;/bean&gt;</code>中添加<code>property</code>标签，其中<code>name</code>表示要注入的属性名,<code>value</code>表示要注入的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- set方式注入： --&gt;</span><br><span class="line">&lt;bean name=&quot;User&quot; class=&quot;my.study.bean.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;jay&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;age&quot; value=&quot;17&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>书写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.c_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.bean.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1.创建容器对象</span></span><br><span class="line">		ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;my/study/c_injection/applicationContext.xml&quot;</span>);</span><br><span class="line">		User u = (User) ac.getBean(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">		System.out.println(u.getName() + <span class="string">&quot; , &quot;</span> +u.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [name=jay, age=<span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>这是值类型注入。</p>
<p>下面是引用类型注入。<br>然后新建一个<code>Car</code>类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Car [name=&quot;</span> + name + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在User中添加<code>car</code>属性，并添加<code>get</code>和<code>set</code>方法<br>如果要注入<code>Car</code>类型，需要先把<code>Car</code>配置到容器中。<br>在配置文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;Car&quot; class=&quot;my.study.bean.Car&quot;&gt;  </span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;Q5&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;color&quot; value=&quot;black&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>然后为<code>User</code>的<code>car</code>属性注入刚才配置的<code>Car</code>对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User&quot; class=&quot;my.study.bean.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;jay&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;age&quot; value=&quot;17&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;car&quot; ref=&quot;Car&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>重新书写<code>User</code>的<code>toString()</code>方法，重新运行<code>test()</code>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [name=jay, age=<span class="number">17</span>, car=Car [name=Q5, color=black]]</span><br></pre></td></tr></table></figure>
<h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><p>在<code>User</code>类中添加有参构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Car car)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是<code>bean</code>的配置，添加如下配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User2&quot; class=&quot;my.study.bean.User&quot;&gt; </span><br><span class="line">	&lt;constructor-arg name=&quot;name&quot; value=&quot;chou&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;car&quot; ref=&quot;Car&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>ref依然传入上面定义的<code>Car</code>.然后书写代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;my/study/c_injection/applicationContext.xml&quot;</span>);</span><br><span class="line">	User u = (User) ac.getBean(<span class="string">&quot;User2&quot;</span>);</span><br><span class="line">	System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [name=chou, age=<span class="keyword">null</span>, car=Car [name=Q5, color=black]]</span><br></pre></td></tr></table></figure>

<p>如果定义一个重载构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Car car,String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想让Spring在使用构造函数注入时，使用<code>User(String name, Car car)</code>来创建对象，可以在<code>&lt;contructor-arg&gt;&lt;/contructor-arg&gt;</code>中使用<code>index</code>.使用<code>index</code>来表示构造函数的参数索引,<code>index</code>越小表示越靠前的位置.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User2&quot; class=&quot;my.study.bean.User&quot;&gt; </span><br><span class="line">	&lt;constructor-arg name=&quot;name&quot; value=&quot;chou&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;car&quot; ref=&quot;Car&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>如果是构造函数是同样的注入顺序，但是是不同的类型，在<code>index</code>后面继续追加一个<code>type</code>，表示构造函数的参数类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer name, Car car)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name+<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意<code>value</code>中的传参要和<code>type</code>对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User2&quot; class=&quot;my.study.bean.User&quot;&gt; </span><br><span class="line">	&lt;constructor-arg name=&quot;name&quot; value=&quot;123&quot; index=&quot;0&quot; type=&quot;java.lang.Integer&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;car&quot; ref=&quot;Car&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [name=<span class="number">123</span>, age=<span class="keyword">null</span>, car=Car [name=Q5, color=black]]</span><br></pre></td></tr></table></figure>

<h3 id="p名称空间注入"><a href="#p名称空间注入" class="headerlink" title="p名称空间注入"></a>p名称空间注入</h3><p>首先在<code>&lt;beans&gt;&lt;/beans&gt;</code>中导入名称空间,添加<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot; </code><br>即添加后的<code>beans</code>名称空间为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">		xmlns:p=&quot;http://www.springframework.org/schema/p&quot; </span><br><span class="line">		xmlns=&quot;http://www.springframework.org/schema/beans&quot; </span><br><span class="line">		xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &quot;&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>注入方法，使用<code>p:</code>属性完成注入，如果是值类型，则用<code>p:属性名=&quot;值&quot;</code>，如果是引用类型，则用<code>p:属性名-ref=&quot;bean名称&quot;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User3&quot; class=&quot;my.study.bean.User&quot; p:name=&quot;hey&quot; p:age=&quot;22&quot; p:car-ref=&quot;Car&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>书写代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;my/study/c_injection/applicationContext.xml&quot;</span>);</span><br><span class="line">	User u = (User) ac.getBean(<span class="string">&quot;User3&quot;</span>);</span><br><span class="line">	System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User [name=hey, age=22, car=Car [name=Q5, color=black]]</span><br></pre></td></tr></table></figure>
<h3 id="spel注入"><a href="#spel注入" class="headerlink" title="spel注入"></a>spel注入</h3><p>即Spring Expression Language.有点类似于el和ognl的写法.</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User4&quot; class=&quot;my.study.bean.User&quot;&gt;</span><br><span class="line">	&lt;!-- 使用User的name属性值作为value的值 --&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;#&#123;User.name&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 使用User3的value属性值作为value的值 --&gt;</span><br><span class="line">	&lt;property name=&quot;age&quot; value=&quot;#&#123;User3.age&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 引用类型不支持spel表达式 --&gt;</span><br><span class="line">	&lt;property name=&quot;car&quot; ref=&quot;Car&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [name=jay, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]</span><br></pre></td></tr></table></figure>

<h2 id="复杂类型注入"><a href="#复杂类型注入" class="headerlink" title="复杂类型注入"></a>复杂类型注入</h2><p>新建<code>CollectionBean</code>类进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.c_injection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] arr;</span><br><span class="line">	<span class="keyword">private</span> List list;</span><br><span class="line">	<span class="keyword">private</span> Map map;</span><br><span class="line">	<span class="keyword">private</span> Properties prop;</span><br><span class="line">	<span class="keyword">public</span> Object[] getArr() &#123;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArr</span><span class="params">(Object[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.arr = arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.list = list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map map)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.map = map;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Properties <span class="title">getProp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> prop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProp</span><span class="params">(Properties prop)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.prop = prop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;CollectionBean [arr=&quot;</span> + Arrays.toString(arr) + <span class="string">&quot;, list=&quot;</span> + list + <span class="string">&quot;, map=&quot;</span> + map + <span class="string">&quot;, prop=&quot;</span> + prop</span><br><span class="line">				+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在配置文件中书写配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;CollectionBean_arr&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.c_injection.CollectionBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 如果数组中只准备注入一个元素，直接使用value|ref --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">		&lt;property name=&quot;arr&quot; value=&quot;11&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 多元素注入 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arr&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;User4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试并打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionBean [arr=[<span class="number">1</span>, <span class="number">2</span>, User [name=jay, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]], list=<span class="keyword">null</span>, map=<span class="keyword">null</span>, prop=<span class="keyword">null</span>]</span><br></pre></td></tr></table></figure>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>在配置文件中添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;CollectionBean_arr&quot; class=&quot;my.study.c_injection.CollectionBean&quot;&gt;</span><br><span class="line">&lt;!-- arr注入 --&gt;</span><br><span class="line">	&lt;!-- 如果数组中只准备注入一个元素，直接使用value|ref --&gt;</span><br><span class="line">	&lt;!--  </span><br><span class="line">		&lt;property name=&quot;arr&quot; value=&quot;11&quot;&gt;&lt;/property&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;!-- 多元素注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;arr&quot;&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;User4&quot;&gt;&lt;/ref&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- list注入 --&gt;</span><br><span class="line">	&lt;!-- 如果List中只准备注入一个元素，直接使用value|ref --&gt;</span><br><span class="line">	&lt;!-- 多元素注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;list&quot;&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;value&gt;list1&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;list2&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;User3&quot;&gt;&lt;/ref&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionBean [arr=[<span class="number">1</span>, <span class="number">2</span>, User [name=jay, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]], list=[list1, list2, User [name=hey, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]], map=<span class="keyword">null</span>, prop=<span class="keyword">null</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>在配置文件中添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;CollectionBean_arr&quot; class=&quot;my.study.c_injection.CollectionBean&quot;&gt;</span><br><span class="line">&lt;!-- arr注入 --&gt;</span><br><span class="line">	&lt;!-- 如果数组中只准备注入一个元素，直接使用value|ref --&gt;</span><br><span class="line">	&lt;!--  </span><br><span class="line">		&lt;property name=&quot;arr&quot; value=&quot;11&quot;&gt;&lt;/property&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;!-- 多元素注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;arr&quot;&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;User4&quot;&gt;&lt;/ref&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- list注入 --&gt;</span><br><span class="line">	&lt;!-- 如果List中只准备注入一个元素，直接使用value|ref --&gt;</span><br><span class="line">	&lt;!-- 多元素注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;list&quot;&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;value&gt;list1&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;list2&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;User3&quot;&gt;&lt;/ref&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- map注入 --&gt;		</span><br><span class="line">	&lt;property name=&quot;map&quot;&gt;</span><br><span class="line">		&lt;map&gt;</span><br><span class="line">			&lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">			&lt;entry key=&quot;user&quot; value-ref=&quot;User4&quot;&gt;&lt;/entry&gt;</span><br><span class="line">			&lt;entry key-ref=&quot;User3&quot; value-ref=&quot;User2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">		&lt;/map&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>测试并打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionBean [arr=[<span class="number">1</span>, <span class="number">2</span>, User [name=jay, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]], list=[list1, list2, User [name=hey, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]], map=&#123;key1=value1, user=User [name=jay, age=<span class="number">22</span>, car=Car [name=Q5, color=black]], User [name=hey, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]=User [name=<span class="number">123</span>, age=<span class="keyword">null</span>, car=Car [name=Q5, color=black]]&#125;, prop=<span class="keyword">null</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>配置文件中的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;CollectionBean_arr&quot; class=&quot;my.study.c_injection.CollectionBean&quot;&gt;</span><br><span class="line">&lt;!-- arr注入 --&gt;</span><br><span class="line">	&lt;!-- 如果数组中只准备注入一个元素，直接使用value|ref --&gt;</span><br><span class="line">	&lt;!--  </span><br><span class="line">		&lt;property name=&quot;arr&quot; value=&quot;11&quot;&gt;&lt;/property&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;!-- 多元素注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;arr&quot;&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;value&gt;1&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;User4&quot;&gt;&lt;/ref&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- list注入 --&gt;</span><br><span class="line">	&lt;!-- 如果List中只准备注入一个元素，直接使用value|ref --&gt;</span><br><span class="line">	&lt;!-- 多元素注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;list&quot;&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;value&gt;list1&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;list2&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;User3&quot;&gt;&lt;/ref&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- map注入 --&gt;		</span><br><span class="line">	&lt;property name=&quot;map&quot;&gt;</span><br><span class="line">		&lt;map&gt;</span><br><span class="line">			&lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">			&lt;entry key=&quot;user&quot; value-ref=&quot;User4&quot;&gt;&lt;/entry&gt;</span><br><span class="line">			&lt;entry key-ref=&quot;User3&quot; value-ref=&quot;User2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">		&lt;/map&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- Properties注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;prop&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;propkey1&quot;&gt; propvalue1&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;propkey2&quot;&gt; propvalue2&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionBean [arr=[<span class="number">1</span>, <span class="number">2</span>, User [name=jay, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]], list=[list1, list2, User [name=hey, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]], map=&#123;key1=value1, user=User [name=jay, age=<span class="number">22</span>, car=Car [name=Q5, color=black]], User [name=hey, age=<span class="number">22</span>, car=Car [name=Q5, color=black]]=User [name=<span class="number">123</span>, age=<span class="keyword">null</span>, car=Car [name=Q5, color=black]]&#125;, prop=&#123;propkey2=propvalue2, propkey1=propvalue1&#125;]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>学习笔记</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记-三</title>
    <url>/2018/11/13/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="Spring结合JDBC"><a href="#Spring结合JDBC" class="headerlink" title="Spring结合JDBC"></a>Spring结合JDBC</h1><p>其实，Spring中提供了一个可以操作数据库的对象，这个对象封装了各种JDBC技术，可以用它来操作数据库.——<code>JDBCtemplate</code><br>需要的依赖包：<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/1.png" alt="依赖包"></p>
<h2 id="不使用Spring操作数据库"><a href="#不使用Spring操作数据库" class="headerlink" title="不使用Spring操作数据库"></a>不使用Spring操作数据库</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.g_jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyVetoException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1. 准备连接池</span></span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		</span><br><span class="line">		dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql:///你的数据库名&quot;</span>);</span><br><span class="line">		dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">		<span class="comment">//2. 创建JDBC模板对象</span></span><br><span class="line">		JdbcTemplate jt = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">		jt.setDataSource(dataSource);</span><br><span class="line">		<span class="comment">//3. 书写SQL语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into t_user values(null,&#x27;hey&#x27;)&quot;</span>;</span><br><span class="line">		jt.update(sql);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以去数据库中自己查看是否添加成功</p>
<h2 id="使用Spring操作数据库"><a href="#使用Spring操作数据库" class="headerlink" title="使用Spring操作数据库"></a>使用Spring操作数据库</h2><p>1.使用JDBC模板完成增删改查<br>定义<code>UserDao</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.g_jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User u)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User u)</span></span>;</span><br><span class="line">	<span class="function">User <span class="title">getById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义<code>User</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.g_jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<code>UserDaoImpl</code>类，书写方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.g_jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个JdbcTemplate用来对SQL语句进行操作</span></span><br><span class="line">	<span class="keyword">private</span> JdbcTemplate jt;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;insert into t_user values(null,?)&quot;</span>;</span><br><span class="line">		jt.update(sql, u.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;delete from t_user where id = ?&quot;</span>;</span><br><span class="line">		jt.update(sql, id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;update t_user set name = ? where id = ?&quot;</span>;</span><br><span class="line">		jt.update(sql, u.getName(),u.getId()); </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from t_user where id = ?&quot;</span>;</span><br><span class="line">		User u = jt.queryForObject(sql, <span class="keyword">new</span> RowMapper&lt;User&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> arg1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">				User u = <span class="keyword">new</span> User();</span><br><span class="line">				u.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">				u.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">				<span class="keyword">return</span> u;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;, id);</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from t_user&quot;</span>;</span><br><span class="line">		Integer count = jt.queryForObject(sql,Integer.class);</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from t_user&quot;</span>;</span><br><span class="line">		List&lt;User&gt; list = jt.query(sql, <span class="keyword">new</span> RowMapper&lt;User&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> arg1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">				User u = <span class="keyword">new</span> User();</span><br><span class="line">				u.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">				u.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">				<span class="keyword">return</span> u;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJt</span><span class="params">(JdbcTemplate jt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jt = jt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要配置到Spring中，让Spring管理：<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/2.png" alt="配置关系"><br>在配置文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;</span><br><span class="line">	&lt;!-- 1.将DataSource连接池放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;JdbcUrl&quot; value=&quot;jdbc:mysql:///hibernate_32&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;DriverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;User&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;Password&quot; value=&quot;12345&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 2.将JDBCTemplate放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;JdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 3.将UserDao放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;userDao&quot; class=&quot;my.study.g_jdbcTemplate.UserDaoImpl&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;jt&quot; ref=&quot;JdbcTemplate&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.g_jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyVetoException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:my/study/g_jdbcTemplate/applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> UserDao ud;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//1. 准备连接池</span></span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		</span><br><span class="line">		dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql:///hibernate_32&quot;</span>);</span><br><span class="line">		dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">		<span class="comment">//2. 创建JDBC模板对象</span></span><br><span class="line">		JdbcTemplate jt = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">		jt.setDataSource(dataSource);</span><br><span class="line">		<span class="comment">//3. 书写SQL语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into t_user values(null,&#x27;hey&#x27;)&quot;</span>;</span><br><span class="line">		jt.update(sql);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		u.setName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		ud.save(u);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		u.setId(<span class="number">2</span>);</span><br><span class="line">		u.setName(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">		ud.update(u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ud.delete(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> totalCount = ud.getTotalCount();</span><br><span class="line">		System.out.println(totalCount);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(ud.getById(<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(ud.getAll());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，可以让<code>UserDaoImpl</code>继承<code>JDBCDaoSupport</code>，父类可以根据连接池自己创建JDBC模板.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.g_jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;insert into t_user values(null,?) &quot;</span>;</span><br><span class="line">		<span class="keyword">super</span>.getJdbcTemplate().update(sql, u.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;delete from t_user where id = ? &quot;</span>;</span><br><span class="line">		<span class="keyword">super</span>.getJdbcTemplate().update(sql,id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;update  t_user set name = ? where id=? &quot;</span>;</span><br><span class="line">		<span class="keyword">super</span>.getJdbcTemplate().update(sql, u.getName(),u.getId());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from t_user where id = ? &quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getJdbcTemplate().queryForObject(sql,<span class="keyword">new</span> RowMapper&lt;User&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> arg1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">				User u = <span class="keyword">new</span> User();</span><br><span class="line">				u.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">				u.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">				<span class="keyword">return</span> u;</span><br><span class="line">			&#125;&#125;, id);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from t_user  &quot;</span>;</span><br><span class="line">		Integer count = <span class="keyword">super</span>.getJdbcTemplate().queryForObject(sql, Integer.class);</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from t_user  &quot;</span>;</span><br><span class="line">		List&lt;User&gt; list = <span class="keyword">super</span>.getJdbcTemplate().query(sql, <span class="keyword">new</span> RowMapper&lt;User&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> arg1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">				User u = <span class="keyword">new</span> User();</span><br><span class="line">				u.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">				u.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">				<span class="keyword">return</span> u;</span><br><span class="line">			&#125;&#125;);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在配置文件中可以简化配置，不需要配置<code>JDBCTemplate</code>。<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/3.png" alt="配置关系2"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;JdbcUrl&quot; value=&quot;jdbc:mysql:///hibernate_32&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;DriverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;User&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;Password&quot; value=&quot;12345&quot;&gt;&lt;/property&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean name=&quot;userDao&quot; class=&quot;my.study.g_jdbcTemplate.UserDaoImpl&quot; &gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; &gt;&lt;/property&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>Spring中整合properties配置:<br>新建<code>db.properties</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JdbcUrl=jdbc:mysql:///hibernate_32</span><br><span class="line">DriverClass=com.mysql.jdbc.Driver</span><br><span class="line">User=root</span><br><span class="line">Password=12345</span><br></pre></td></tr></table></figure>

<p>更改配置文件中的配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	&lt;!-- 指定Properties的位置 --&gt;</span><br><span class="line">	&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">	&lt;!-- 1.将DataSource连接池放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;JdbcUrl&quot; value=&quot;$&#123;jdbc.JdbcUrl&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;DriverClass&quot; value=&quot;$&#123;jdbc.DriverClass&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;User&quot; value=&quot;$&#123;jdbc.User&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;Password&quot; value=&quot;$&#123;jdbc.Password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="Spring中的aop事务"><a href="#Spring中的aop事务" class="headerlink" title="Spring中的aop事务"></a>Spring中的aop事务</h1><h2 id="事务相关概念"><a href="#事务相关概念" class="headerlink" title="事务相关概念"></a>事务相关概念</h2><p>事务的特性：ACID</p>
<blockquote>
<p>⑴ 原子性（Atomicity）<br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>⑵ 一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>⑶ 隔离性（Isolation）<br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>　　关于事务的隔离性数据库提供了多种隔离级别。</p>
<p>⑷ 持久性（Durability）<br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
</blockquote>
<p>事务并发问题：</p>
<blockquote>
<p>1.脏读<br>　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。<br>2.不可重复读<br>　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。<br>3.虚读(幻读)<br>　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
</blockquote>
<blockquote>
<p>　　现在来看看MySQL数据库为我们提供的四种隔离级别：</p>
<p>　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p>
<p>　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p>
<p>　　③ Read committed (读已提交)：可避免脏读的发生。</p>
<p>　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
</blockquote>
<blockquote>
<p>　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
</blockquote>
<p>Spring提供了<code>PlatformTransactionManager</code>接口，封装了事务操作对象的方法.对不同的平台，有不同的实现类.如:<code>JDBC</code>平台–<code>DataSourceTransactionManager</code>;<code>Hibernate</code>平台—<code>TransactionManager</code>..等.在Spring中使用事务管理，最核心的就是使用<code>PlatformTransactionManager</code>对象。</p>
<p>Spring事务管理可以管理事务的隔离级别、是否只读、事务的传播行为(比如在一个service方法中调用另一个service方法)、</p>
<p>事务的传播行为包括：</p>
<ul>
<li>保证同一个事务中</li>
</ul>
<p>PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个(默认)</p>
<p>PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务</p>
<p>PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常</p>
<ul>
<li>保证没有在同一个事务中</li>
</ul>
<p>PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务</p>
<p>PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务</p>
<p>PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常</p>
<p>PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</p>
<h2 id="定义场景并书写代码"><a href="#定义场景并书写代码" class="headerlink" title="定义场景并书写代码"></a>定义场景并书写代码</h2><h3 id="不添加事务部分"><a href="#不添加事务部分" class="headerlink" title="不添加事务部分"></a>不添加事务部分</h3><p>定义一个转钱的场景，自行建一个表，包含id,姓名和钱数。<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/4.png" alt="表"><br>定义接口,包含加钱和减钱两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseMoney</span><span class="params">(Integer id,Double money)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseMoney</span><span class="params">(Integer id,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseMoney</span><span class="params">(Integer id, Double money)</span> </span>&#123;</span><br><span class="line">		getJdbcTemplate().update(<span class="string">&quot;update t_account set money = money + ? where id = ?&quot;</span>, money,id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseMoney</span><span class="params">(Integer id, Double money)</span> </span>&#123;</span><br><span class="line">		getJdbcTemplate().update(<span class="string">&quot;update t_account set money = money-? where id = ? &quot;</span>, money,id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义service方法,包含转账方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Integer from,Integer to,Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义service方法实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.dao.AccountDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AccountDao ad ;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">final</span> Integer from,<span class="keyword">final</span> Integer to,<span class="keyword">final</span> Double money)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//减钱</span></span><br><span class="line">		ad.decreaseMoney(from, money);</span><br><span class="line">		<span class="comment">//加钱</span></span><br><span class="line">		ad.increaseMoney(to, money);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAd</span><span class="params">(AccountDao ad)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ad = ad;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/5.png" alt="Spring中配置依赖关系"><br>书写配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;</span><br><span class="line">	&lt;!-- 指定Properties的位置 --&gt;</span><br><span class="line">	&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">	&lt;!-- 1.将DataSource连接池放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;JdbcUrl&quot; value=&quot;$&#123;jdbc.JdbcUrl&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;DriverClass&quot; value=&quot;$&#123;jdbc.DriverClass&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;User&quot; value=&quot;$&#123;jdbc.User&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;Password&quot; value=&quot;$&#123;jdbc.Password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 2.AccountDao --&gt;</span><br><span class="line">	&lt;bean name=&quot;accountDao&quot; class=&quot;my.study.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 3.将AccountService放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;accountService&quot; class=&quot;my.study.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;ad&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>书写代码测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.service.AccountService;</span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:my/study/dao/applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Resource(name=&quot;accountService&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> AccountService as;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		as.transfer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">100d</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新查看数据库结果:<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/6.png" alt="结果"></p>
<p>这是没有添加事务的程序.没有添加事务，就容易发生各种问题(前面提到的事务的问题)。</p>
<h3 id="添加事务"><a href="#添加事务" class="headerlink" title="添加事务"></a>添加事务</h3><p>首先需要配置核心事务管理器,它依赖于连接池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	&lt;!-- 事务核心管理器,封装了所有事务操作. 依赖于连接池 --&gt;</span><br><span class="line">	&lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; &gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="编码式"><a href="#编码式" class="headerlink" title="编码式"></a>编码式</h4><p>需要在代码中进行事务管理，需要书写重复代码。并不推荐.<br>编码式需要事务模板对象，在xml中配置,要配置tt属性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;!-- 事务模板对象 --&gt;</span><br><span class="line">	&lt;bean name=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot; &gt;</span><br><span class="line">		&lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; &gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">...</span><br><span class="line">	&lt;bean name=&quot;accountService&quot; class=&quot;my.study.service.AccountServiceImpl&quot; &gt;</span><br><span class="line">	&lt;property name=&quot;ad&quot; ref=&quot;accountDao&quot; &gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;tt&quot; ref=&quot;transactionTemplate&quot; &gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;  </span><br></pre></td></tr></table></figure>

<p>使用编码式，需要在service中声明一个<code>TransactionTemplate</code>,并生成set方法,然后定义<code>execute()</code>方法，实现接口，在<code>doInTransactionWithoutResult</code>方法中书写事务操作的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionCallbackWithoutResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.dao.AccountDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AccountDao ad ;</span><br><span class="line">	<span class="keyword">private</span> TransactionTemplate tt;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">final</span> Integer from,<span class="keyword">final</span> Integer to,<span class="keyword">final</span> Double money)</span> </span>&#123;</span><br><span class="line">		tt.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus arg0)</span> </span>&#123;</span><br><span class="line">				<span class="comment">//减钱</span></span><br><span class="line">				ad.decreaseMoney(from, money);</span><br><span class="line">				<span class="comment">//加钱</span></span><br><span class="line">				ad.increaseMoney(to, money);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAd</span><span class="params">(AccountDao ad)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ad = ad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTt</span><span class="params">(TransactionTemplate tt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tt = tt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>execute</code>方法的执行步骤：<code>打开事务</code>-&gt;执行<code>doInTransactionWithoutResult</code>方法-&gt;<code>提交事务</code>.在<code>doInTransactionWithoutResult</code>方法中提供了try catch语句，如果发生错误则进行回滚操作。</p>
<h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><p>配置AOP事务，AOP事务的配置和效果如图：<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/7.png" alt="AOP配置关系"><br>进行xml配置之前，还需要导入新的命名空间约束，<code>tx</code>约束,并在<code>XMLEditor</code>下添加这个约束和<code>aop</code>约束:<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/8.png" alt="导入命名空间依赖"><br>导入方法见<code>Spring学习笔记-一</code>和<code>Spring学习笔记-二</code>中相关部分。<br>最终需要的配置如下：<br><img src="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/9.png" alt="结果"></p>
<p>xml中的各个配置：<br><code>beans</code>:最基本的根元素<br><code>context</code>:读取properties配置文件<br><code>aop</code>:配置AOP，将通知织入目标对象<br><code>tx</code>:配置事务通知</p>
<h5 id="配置事务通知"><a href="#配置事务通知" class="headerlink" title="配置事务通知"></a>配置事务通知</h5><p>接下来配置事务通知，是以方法为单位进行配置的，在配置文件中新增配置事务的部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务通知 --&gt;</span><br><span class="line">	&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">		&lt;tx:attributes&gt;		</span><br><span class="line">			&lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;&gt;&lt;/tx:method&gt;</span><br><span class="line">		&lt;/tx:attributes&gt;</span><br><span class="line">	&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>
<p>name为事务的方法名<br>isolation:隔离级别:<br>        - DEFAULT<br>        - READ_UNCOMMITTED<br>        - READ_COMMITTED<br>        - REPEATABLE_READ<br>        - SERIALIZABLE<br>propagation:传播行为：<br>        - REQUIRED<br>        - SUPPORTS<br>        - MANDATORY<br>        - REQUIRES_NEW<br>        - NOT_SUPPORTED<br>        - NEVER<br>        - NESTED<br>read-only:”false”,这个就不多解释了吧</p>
<p>当然，配置的<code>name</code>方法名可以用<code>*</code>通配符来进行匹配相似的方法名，可以使用的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">		&lt;tx:attributes&gt;		</span><br><span class="line">		&lt;tx:method name=&quot;save*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;persist*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;update*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;modify*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;delete*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;remove*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;get*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;find*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;&gt;&lt;/tx:method&gt;</span><br><span class="line">	&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>
<p>注意其中<code>get</code>和<code>find</code>的只读为<code>true</code></p>
<h5 id="配置将事务织入目标对象"><a href="#配置将事务织入目标对象" class="headerlink" title="配置将事务织入目标对象"></a>配置将事务织入目标对象</h5><p>配置完事务通知要进行配置织入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置织入 --&gt;</span><br><span class="line">	&lt;aop:config &gt;</span><br><span class="line">		&lt;!-- 配置切点表达式 --&gt;</span><br><span class="line">		&lt;aop:pointcut expression=&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot; id=&quot;txPc&quot;/&gt;</span><br><span class="line">		&lt;!-- 配置切面 --&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPc&quot;/&gt;</span><br><span class="line">	&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<p>其中切面的构成是通知加切点,advice-ref：通知的名称;pointcut-ref：切点的名称.<br>完整的xml配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;&gt;</span><br><span class="line">	&lt;!-- 指定Properties的位置 --&gt;</span><br><span class="line">	&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 事务核心管理器,封装了所有事务操作. 依赖于连接池 --&gt;</span><br><span class="line">	&lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; &gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 事务模板对象 --&gt;</span><br><span class="line">	&lt;bean name=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot; &gt;</span><br><span class="line">		&lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; &gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置事务通知 --&gt;</span><br><span class="line">	&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">		&lt;tx:attributes&gt;</span><br><span class="line">			&lt;!-- name为方法名</span><br><span class="line">				isolation:隔离级别:</span><br><span class="line">					- DEFAULT</span><br><span class="line">					- READ_UNCOMMITTED</span><br><span class="line">					- READ_COMMITTED</span><br><span class="line">					- REPEATABLE_READ</span><br><span class="line">					- SERIALIZABLE</span><br><span class="line">				propagation:传播行为：</span><br><span class="line">					- REQUIRED</span><br><span class="line">					- SUPPORTS</span><br><span class="line">					- MANDATORY</span><br><span class="line">					- REQUIRES_NEW</span><br><span class="line">					- NOT_SUPPORTED</span><br><span class="line">					- NEVER</span><br><span class="line">					- NESTED</span><br><span class="line">			 --&gt;</span><br><span class="line">			&lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; &gt;&lt;/tx:method&gt;</span><br><span class="line">		&lt;/tx:attributes&gt;</span><br><span class="line">	&lt;/tx:advice&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置织入 --&gt;</span><br><span class="line">	&lt;aop:config &gt;</span><br><span class="line">		&lt;!-- 配置切点表达式 --&gt;</span><br><span class="line">		&lt;aop:pointcut expression=&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot; id=&quot;txPc&quot;/&gt;</span><br><span class="line">		&lt;!-- 配置切面 </span><br><span class="line">			advice-ref：通知的名称</span><br><span class="line">			pointcut-ref：切点的名称</span><br><span class="line">		--&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPc&quot;/&gt;</span><br><span class="line">	&lt;/aop:config&gt;</span><br><span class="line">	&lt;!-- 1.将DataSource连接池放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;JdbcUrl&quot; value=&quot;$&#123;jdbc.JdbcUrl&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;DriverClass&quot; value=&quot;$&#123;jdbc.DriverClass&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;User&quot; value=&quot;$&#123;jdbc.User&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;Password&quot; value=&quot;$&#123;jdbc.Password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 2.AccountDao --&gt;</span><br><span class="line">	&lt;bean name=&quot;accountDao&quot; class=&quot;my.study.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 3.将AccountService放入Spring容器 --&gt;</span><br><span class="line">	&lt;bean name=&quot;accountService&quot; class=&quot;my.study.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;ad&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;tt&quot; ref=&quot;transactionTemplate&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>注解配置只需将上面的编制织入和配置事务通知替换为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启注解管理AOP事务 --&gt;</span><br><span class="line">	&lt;tx:annotation-driven/&gt;</span><br></pre></td></tr></table></figure>

<p>配置完成后可以使用注解配置事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Isolation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionCallbackWithoutResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.dao.AccountDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AccountDao ad ;</span><br><span class="line">	<span class="keyword">private</span> TransactionTemplate tt;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">final</span> Integer from,<span class="keyword">final</span> Integer to,<span class="keyword">final</span> Double money)</span> </span>&#123;</span><br><span class="line">				<span class="comment">//减钱</span></span><br><span class="line">				ad.decreaseMoney(from, money);</span><br><span class="line">			<span class="comment">//	int i = 1/0;</span></span><br><span class="line">				<span class="comment">//加钱</span></span><br><span class="line">				ad.increaseMoney(to, money);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAd</span><span class="params">(AccountDao ad)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ad = ad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTt</span><span class="params">(TransactionTemplate tt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tt = tt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在类之前加上注解配置，那么这个类的所有方法都遵循这个配置。如果有某个方法和类声明的注解配置不一样，则再这个方法前面声明一下注解配置即可。</p>
<p>可以再书写一个测试类进行测试，注意要读取正确的配置文件（即开启了注解配置的文件）</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>cesium加载大数据量geojson优化&amp;踩坑记</title>
    <url>/2021/03/01/cesium%E5%8A%A0%E8%BD%BD%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8Fgeojson%E4%BC%98%E5%8C%96-%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在做一个新的Cesium项目时，要在Cesium中添加多个矢量图层（包括点、面），并要对矢量数据进行编辑（包括属性编辑和图形编辑）。点图层数据数据量较小，而其中一个面数据较大，大概有15000个feature，在正式上线时，面数据大概有测试数据的3-4倍，因此要找到一个高效率加载大量矢量数据的方案。</p>
<h1 id="将feature加载形式从entity改为primitive"><a href="#将feature加载形式从entity改为primitive" class="headerlink" title="将feature加载形式从entity改为primitive"></a>将feature加载形式从entity改为primitive</h1><h2 id="primitive简介"><a href="#primitive简介" class="headerlink" title="primitive简介"></a>primitive简介</h2><p>primitive更接近cesium渲染引擎的底层。</p>
<blockquote>
<p>使用Geometry和Appearance 具有以下优势：<br>（1）性能：绘制大量Primitive时，可以将其合并为单个Geometry以减轻CPU负担、更好的使用GPU。合并Primitive由web worker线程执行，UI保持响应性<br>（2）灵活性：Geometry与Appearance解耦，两者可以分别进行修改<br>（3）低级别访问：易于编写GLSL顶点、片段着色器、使用自定义的渲染状态</p>
</blockquote>
<blockquote>
<p>同时，具有以下劣势：<br>（1）需要编写更多地代码<br>（2）需要对图形编程有更多的理解，特别是OpenGL的知识</p>
</blockquote>
<p>下面代码是entity与primitive方式对比：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//entity方式</span></span><br><span class="line">viewer.entities.add(&#123;</span><br><span class="line">    <span class="attr">rectangle</span>: &#123;</span><br><span class="line">        <span class="attr">coordinates</span>: Cesium.Rectangle.fromDegrees(<span class="number">110.20</span>, <span class="number">34.55</span>, <span class="number">111.20</span>, <span class="number">35.55</span>),</span><br><span class="line">        <span class="attr">material</span>: <span class="keyword">new</span> Cesium.StripeMaterialProperty(&#123;</span><br><span class="line">            <span class="attr">evenColor</span>: Cesium.Color.WHITE,</span><br><span class="line">            <span class="attr">oddColor</span>: Cesium.Color.BLUE,</span><br><span class="line">            <span class="attr">repeat</span>:<span class="number">5</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//primitive方式</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Cesium.GeometryInstance(&#123;</span><br><span class="line">    <span class="attr">geometry</span>: <span class="keyword">new</span> Cesium.RectangleGeometry(&#123;</span><br><span class="line">        <span class="attr">rectangle</span>: Cesium.Rectangle.fromDegrees(<span class="number">105.20</span>, <span class="number">30.55</span>, <span class="number">106.20</span>, <span class="number">31.55</span>),</span><br><span class="line">        <span class="attr">vertexFormat</span>:Cesium.EllipsoidSurfaceAppearance.VERTEXT_FORMAT</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">viewer.scene.primitives.add(<span class="keyword">new</span> Cesium.Primitive(&#123;</span><br><span class="line">    <span class="attr">geometryInstances</span>: instance,</span><br><span class="line">    <span class="attr">appearance</span>: <span class="keyword">new</span> Cesium.EllipsoidSurfaceAppearance(&#123;</span><br><span class="line">        <span class="attr">material</span>:Cesium.Material.fromType(<span class="string">&#x27;Stripe&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>改用primitive渲染feature后，仍然在数据加载阶段会有卡顿，因此猜测显示和加载feature事件过长的瓶颈不在于渲染方式上，而在于异步从服务器获取json数据方面。<br>因此考虑将数据切片，然后加载切片WMTS服务，缩短每次HTTP请求时的数据量，进而加快请求速度。</p>
<h1 id="将shp数据存入PostgreSQL，通过GeoServer发布为WFS服务"><a href="#将shp数据存入PostgreSQL，通过GeoServer发布为WFS服务" class="headerlink" title="将shp数据存入PostgreSQL，通过GeoServer发布为WFS服务"></a>将shp数据存入PostgreSQL，通过GeoServer发布为WFS服务</h1><p>该方式虽然将shp数据入库，但是通过GeoServer发布，数据依然在加载阶段有卡顿。因为数据虽然入库，但是在请求数据时，并没有对数据进行筛选，而仍请求全部的数据，这与直接加载json文本文件没什么区别。</p>
<h1 id="将图层使用GeoServer发布为WMTS服务"><a href="#将图层使用GeoServer发布为WMTS服务" class="headerlink" title="将图层使用GeoServer发布为WMTS服务"></a>将图层使用GeoServer发布为WMTS服务</h1><p>经过上述尝试，发现必须对数据进行分片加载，减小加载数据时的压力，切片是一个很好的方式。</p>
<h2 id="在GeoServer对数据进行切片"><a href="#在GeoServer对数据进行切片" class="headerlink" title="在GeoServer对数据进行切片"></a>在GeoServer对数据进行切片</h2><p>使用GeoServer+Vector-tile-plugin插件生成WMTS切片。Cesium调用WMTS服务时，数据以分片方式加载，加载速度很快。<br>但该方式也有缺点：</p>
<ol>
<li>发布的数据风格统一，且需要在发布前定义好；</li>
<li>数据为图片形式，无法在z轴方向拉伸；</li>
</ol>
<h1 id="使用mvt矢量切片"><a href="#使用mvt矢量切片" class="headerlink" title="使用mvt矢量切片"></a>使用mvt矢量切片</h1><h2 id="切片制作与发布"><a href="#切片制作与发布" class="headerlink" title="切片制作与发布"></a>切片制作与发布</h2><p>首先使用idesktop对数据源进行矢量切片（如果需要制作专题图，建议先在idesktop中制作好，然后对该数据进行切片）<br>在单任务生成底图瓦片界面中，勾选所需切片的比例尺级别，输出设置中，存储类型选原始。其他保持不变。</p>
<p><strong>注意</strong><br>在idesktop制作mvt切片时，浏览工作空间时，注意要将工作区的<em>整幅地图</em>放在工作窗口内，否则在切片后数据会存在不能显示和浏览的问题。（这是超图需要改进的一个地方，而且这个问题官方也没提醒需要注意，只能踩坑才能发现）</p>
<p>使用iserver发布制作好的矢量切片，步骤：</p>
<ol>
<li>在iserver中选择发布服务，在弹出对话框数据中选择<code>UGCV5(MVT)切片</code></li>
<li>选择瓦片配置文件。选择制作好的矢量切片文件夹，找到后缀为<code>.sci</code>的配置文件并选择。</li>
<li>选择发布的服务类型。选择<code>REST-矢量瓦片服务</code>。点击下一步，并点击完成。</li>
</ol>
<p>服务发布后，可以在iserver中浏览数据。</p>
<h2 id="加载和显示切片"><a href="#加载和显示切片" class="headerlink" title="加载和显示切片"></a>加载和显示切片</h2><p>在SuperMap的WebGL应用中，调用和添加切片数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scene.addVectorTilesMap(&#123;  <span class="comment">//scene是Cesium.viewer.scene</span></span><br><span class="line">    <span class="attr">url</span>: url, <span class="comment">//服务地址</span></span><br><span class="line">    <span class="attr">canvasWidth</span>: <span class="number">512</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;testMVT&#x27;</span>,</span><br><span class="line">    <span class="attr">viewer</span>: viewer <span class="comment">//Cesium.viewer</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="缺点及改进方案"><a href="#缺点及改进方案" class="headerlink" title="缺点及改进方案"></a>缺点及改进方案</h2><p>– 2021.3.8更新 –</p>
<p>矢量切片有两个很明显的缺点：</p>
<ol>
<li>不能以entity或primitive形式加载feature，因此不能对每个要素进行单独的渲染，只能以2d形式平铺在平面。</li>
<li>虽然能够读取属性信息，但是无法对属性信息进行修改。</li>
</ol>
<p>针对第一种缺点的解决方案，可以在idesktop中先将要素进行拉伸，渲染，然后发布为<code>.s3m</code>的切片；针对第二个问题的解决方案，我采用的方法是，单独写一个后台服务，用来修改和读取要素的属性信息，即在数据库中针对要素的属性单独挂接一张表，读取和修改时通过后台服务进行操作。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.jianshu.com/p/5a74c607a591">https://www.jianshu.com/p/5a74c607a591</a></li>
<li><a href="http://support.supermap.com.cn:8090/webgl/web/apis/3dwebgl.html">http://support.supermap.com.cn:8090/webgl/web/apis/3dwebgl.html</a></li>
<li>官方加载MVT的示例 <a href="http://support.supermap.com.cn:8090/webgl/examples/webgl/editor.html#MVT">http://support.supermap.com.cn:8090/webgl/examples/webgl/editor.html#MVT</a></li>
</ol>
]]></content>
      <tags>
        <tag>cesium</tag>
        <tag>gis</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 目录结构笔记 及 一个简单电商项目的网页架构思路</title>
    <url>/2018/06/05/Vue-cli-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%8F%8A-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>学习了vue有一小段时间，期间中断去学习了java并且补了一下数据结构的基础，有点断层。跟着视频用vue2.0做了一个电商的小项目。思路稍微清晰了一些，但是因为中途转学其他的缘故，有一些东西还是忘掉了，这里总结一下使用vue-cli搭建项目的一些经验和教训。</p>
<p>首先是vue-cli的目录结构，这个是基于webpack的脚手架目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- build                            // 项目构建(webpack)相关代码</span><br><span class="line">|   |-- build.js                     // 生产环境构建代码</span><br><span class="line">|   |-- check-version.js             // 检查node、npm等版本</span><br><span class="line">|   |-- utils.js                     // 构建工具相关</span><br><span class="line">|   |-- vue-loader.conf.js           // css加载器配置</span><br><span class="line">|   |-- webpack.base.conf.js         // webpack基础配置</span><br><span class="line">|   |-- webpack.dev.conf.js          // webpack开发环境配置</span><br><span class="line">|   |-- webpack.prod.conf.js         // webpack生产环境配置</span><br><span class="line">|-- config                           // 项目开发环境配置</span><br><span class="line">|   |-- dev.env.js                   // 开发环境变量</span><br><span class="line">|   |-- index.js                     // 项目一些配置变量(包括监听变量，打包路径等)</span><br><span class="line">|   |-- prod.env.js                  // 生产环境变量</span><br><span class="line">|   |-- test.env.js                  // 测试环境变量</span><br><span class="line">|-- node_modules                     //存放依赖的目录</span><br><span class="line">|-- src                              // 源码目录</span><br><span class="line">|   |-- assets                         // 静态资源（css文件，外部js文件）</span><br><span class="line">|   |-- components                     // vue公共组件</span><br><span class="line">|   |-- router                         // 路由配置</span><br><span class="line">|   |-- App.vue                        // 根组件</span><br><span class="line">|   |-- main.js                        // 入口文件，加载各种公共组件</span><br><span class="line">|-- static                           // 静态文件，比如一些图片，json数据等</span><br><span class="line">|-- test                             // 测试文件目录</span><br><span class="line">|-- .babelrc                         // ES6语法编译配置</span><br><span class="line">|-- .editorconfig                    // 定义代码格式</span><br><span class="line">|-- .gitignore                       // git上传需要忽略的文件格式</span><br><span class="line">|-- .postcssrc.js</span><br><span class="line">|-- README.md                        // 项目说明</span><br><span class="line">|-- index.html                       // 入口页面</span><br><span class="line">|-- package.json                     // 项目基本信息</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>当然不同版本的项目目录或者文件大同小异，基本都包括在上面了。</p>
<p>接下来讲一个平时用的比较多的网页排版及vue的大体配置。在此之前先介绍几个文件：</p>
<ol>
<li>index.html<br>一般只定义一个空的根节点，在main.js里面定义的实例将挂载在根节点下，内容都通过vue组件来填充。</li>
</ol>
<p><img src="Vue-cli-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%8F%8A-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF/1.png"></p>
<ol start="2">
<li><p>App.vue<br>App.vue 是个根组件。一个vue文件包括template,script,style三部分。<br>vue通常用es6来写，用export default导出。<br><code>&lt;style&gt;&lt;/style&gt;</code>默认是影响全局的，如需定义作用域只在该组件下起作用，需在标签上加scoped。<br>如要引入外部css文件，首先需给项目安装css-loader依赖包。使用import引入，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">  import &#x27;./assets/css/bootstrap.css&#x27;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>main.js<br>main.js是个入口文件。<br>这里:<code>template: &#39;&lt;App/&gt;&#39; </code>表示用<code>&lt;app&gt;&lt;/app&gt;</code>替换index.html里面的<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>。<br>这么做的目的很简单，<code>&lt;App /&gt;</code>他就是<code>App.vue</code>，template就是选择vue实例要加载哪个模板。最新的vue-cli脚手架模板现在是这个形式。App.vue是主程序，其他所有的.vue都是放在App.vue中，所以只需要加载App.vue就完全可以把其他的东西加载出来。<br><img src="Vue-cli-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%8F%8A-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF/2.png"></p>
</li>
<li><p>router<br>router目录下的index.js即是路由配置文件</p>
</li>
</ol>
<p>  <img src="Vue-cli-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%8F%8A-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF/3.png"></p>
<p>  router中可以设置多个路由，但是这里要先引入相应的组件，在进行设置：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入Vue框架</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">//引入路由依赖</span><br><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">//引入各个页面组件</span><br><span class="line">import IndexPage from &#x27;./components/index&#x27;</span><br><span class="line">import DetailPage from &#x27;./components/detail.vue&#x27;</span><br><span class="line">import DetailAnaPage from &#x27;./components/detail/analysis&#x27;</span><br><span class="line">import DetailPubPage from &#x27;./components/detail/publish&#x27;</span><br><span class="line">import DetailCouPage from &#x27;./components/detail/count&#x27;</span><br><span class="line">import DetailForPage from &#x27;./components/detail/forecast&#x27;</span><br><span class="line">import OrderListPage from &#x27;./components/orderList&#x27;</span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      component: IndexPage</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/orderList&#x27;,</span><br><span class="line">      component: OrderListPage</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/detail&#x27;,</span><br><span class="line">      component: DetailPage,</span><br><span class="line">      redirect: &#x27;detail/analysis&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;forecast&#x27;,</span><br><span class="line">          component: DetailForPage</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;analysis&#x27;,</span><br><span class="line">          component: DetailAnaPage</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;publish&#x27;,</span><br><span class="line">          component: DetailPubPage</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;count&#x27;,</span><br><span class="line">          component: DetailCouPage</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>  这里介绍一个基础的vue模板构建思路：<br>   <img src="Vue-cli-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%8F%8A-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF/5.png"></p>
<p>  <code>App.vue</code>如下，其中的router的配置可以参见上面的代码</p>
<p>  <img src="Vue-cli-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%8F%8A-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF/4.png" alt="App.vue"><br>  当然这里只设置了简单的内容，具体的方法和数据及样式根据不同的需求进行补充即可。</p>
<p>  当然这只是一种简单的设计思路，做项目时可以用这个做为参考，但是不要被限制。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记-二</title>
    <url>/2018/11/10/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="使用注解配置Spring"><a href="#使用注解配置Spring" class="headerlink" title="使用注解配置Spring"></a>使用注解配置Spring</h1><h2 id="导入新的命名空间和依赖包"><a href="#导入新的命名空间和依赖包" class="headerlink" title="导入新的命名空间和依赖包"></a>导入新的命名空间和依赖包</h2><p>导入方法参见<code>Spring学习笔记-一</code>，与导入<code>beans</code>命名空间类似。先导入<code>spring-context-4.2.xsd</code>，然后进行配置,还要在<code>xml</code>的<code>Dsign</code>视图下进行配置，在<code>Prefix</code>中填写<code>context</code>.<br>同时需要导入依赖包<code>spring-aop-4.2.4.RELEASE.jar</code>.</p>
<h2 id="使用注解代理配置文件"><a href="#使用注解代理配置文件" class="headerlink" title="使用注解代理配置文件"></a>使用注解代理配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 扫描指定包名及其子包下的所有注解 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;my.study.bean2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="在类中使用注解进行配置"><a href="#在类中使用注解进行配置" class="headerlink" title="在类中使用注解进行配置"></a>在类中使用注解进行配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.bean2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="keyword">private</span> Car car;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;User 的空参构造方法被调用&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;User [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, car=&quot;</span> + car + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解<code>@Component(&quot;user&quot;)</code>相当于在配置文件中添加了<code>&lt;bean name=&quot;user&quot; class=&quot;my.study.bean2.User&quot;&gt;&lt;/bean&gt;</code><br>书写测试类，可以打印出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User 的空参构造方法被调用</span><br></pre></td></tr></table></figure>

<p>除了<code>@Component</code>注解，还有<code>@Serviece</code>,<code>@Controller</code>,<code>@Repository</code>注解，它们和<code>@Component</code>没有什么区别，只是为了区分注解的对象是在哪一层，便于解读。<br><code>@Serviece</code>—Service层<br><code>@Controller</code>—Web层<br><code>@Repository</code>—DAO层</p>
<h2 id="其他注解关键字"><a href="#其他注解关键字" class="headerlink" title="其他注解关键字"></a>其他注解关键字</h2><p><code>@Scope(scopeName=&quot;singleton|prototype&quot;)</code>—与<code>&lt;bean&gt;</code>中的<code>scope</code>关键字一样，默认为<code>singleton</code>.</p>
<p><code>@Value()</code>—值类型注入<br> 1.—放在属性前面，里面填写要注入的值，表示要注入的属性的值<br>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Scope(scopeName=&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;	</span><br><span class="line">	<span class="meta">@Value(&quot;test1&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="meta">@Value(&quot;11&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="keyword">private</span> Car car;	</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就等于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;User&quot; class=&quot;my.study.bean2.User&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot; value=&quot;test1&quot;&gt;&lt;/property&gt;</span><br><span class="line">  &lt;property name=&quot;age&quot; value=&quot;11&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>可以看打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User 的空参构造方法被调用</span><br><span class="line">User [name=test1, age=<span class="number">11</span>, car=<span class="keyword">null</span>]</span><br></pre></td></tr></table></figure>
<p>这种方式是通过反射的Field对属性赋值,破坏了封装性</p>
<p> 2.—放在<code>set</code>方法前面，里面填写要注入的值，表示要注入的属性的值<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Scope(scopeName=&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;	</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Value(&quot;test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Value(value=&quot;11&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式通过set方法赋值,没有破坏封装性.</p>
<p><code>@Autowired</code>—自动装配引用类型注入</p>
<p>先将要注入的对象注册到容器中，可以在这个对象中先注入各种类型，然后使用<code>@Autowired</code>注入到当前类。<br>缺点：如果是匹配到多个类型一致的对象，无法选择注入哪一个</p>
<p><code>@Qualifier()</code>—指定要注入的对象的名称(即<code>name=&quot;&quot;</code>)</p>
<p><code>@Resource(name=&quot;&quot;)</code>—手动注入，指定注入哪个名称的对象</p>
<p><code>@PostContruct</code>—在初始化方法前添加此注解,对象被创建后调用,类似于<code>init-method</code></p>
<p><code>@PreDestory</code>—在销毁前调用,相当于<code>destory-method</code></p>
<h1 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a>Spring中的AOP</h1><h2 id="手动实现AOP"><a href="#手动实现AOP" class="headerlink" title="手动实现AOP"></a>手动实现AOP</h2><p>简要概括AOP思想就是<code>面向切面编程,横向重复,纵向抽取</code>.</p>
<p>首先Spring能够为容器中管理的对象生成动态代理对象。以前要使用<code>Proxy.newProxyInstance(xx,xx,xx)</code>生成代理对象.而现在Spring只需通过配置就可以生成代理对象。通过这个功能，就可以使用AOP思想进行开发。</p>
<p>Srping实现AOP的原理：<br>1.<code>动态代理</code>—但是，被代理对象必须要实现接口，才能产生代理对象.没有接口不能实现动态代理.如果有接口，优先使用动态代理</p>
<p>2.<code>cglib代理</code>—cglib代理属于第三方代理技术.可以对任何类生成代理.代理的原理是对目标对象进行继承代理. 如果目标对象被final修饰.那么该类无法被cglib代理.如果没有接口，实现此代理</p>
<p>手动实现AOP:<br>1.创建一个<code>UserService</code>接口，定义<code>UserServiceImpl</code>类要实现这个接口的方法.创建UserService代理工厂<code>UserServiceProxyFactory</code>,提供一个工厂方法，返回<code>UserService</code>对象.在方法中生成代理并返回UserService对象.</p>
<p>现在需要在调用<code>UserServiceImpl</code>的每一个方法(<code>save</code>,<code>delete</code>,<code>update</code>,<code>find</code>)之前都进行一个操作(比如打开事务),之后都进行另一个操作(比如提交事务).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;保存用户!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;删除用户!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;更新用户!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;查找用户!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.UserService;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.UserServiceImpl;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxyFactory</span>  <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义构造方法，必须传入当前代理对象的实例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxyFactory</span><span class="params">(UserService us)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.us = us;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义传入当前代理对象的实例</span></span><br><span class="line">	<span class="keyword">private</span> UserService us;</span><br><span class="line">  <span class="comment">//返回代理对象</span></span><br><span class="line">  <span class="comment">// 编写工具方法：生成动态代理</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserService <span class="title">getUserServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//第一个参数传入类加载器,第二个参数传入被代理对象所实现的接口,第三个参数要说明这次代理要怎么增强，即增强的内容，要传入一个InvocationHandler</span></span><br><span class="line">  UserService usProxy = (UserService) Proxy.newProxyInstance(UserServiceProxyFactory.class.getClassLoader(),</span><br><span class="line">                UserServiceImpl.class.getInterfaces(), </span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//返回</span></span><br><span class="line">  <span class="keyword">return</span> usProxy;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//实现接口</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">//第一个参数是当前代理对象的实例,第二个参数是当前调用的方法,第三个参数是当前方法执行时的参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0, Method method, Object[] arg2)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//业务方法执行前需要进行的操作，这里是打开事务</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打开事务!&quot;</span>);</span><br><span class="line">    <span class="comment">//传入当前代理对象的实例us作为运行所在类</span></span><br><span class="line">    <span class="comment">//业务方法的执行</span></span><br><span class="line">		Object invoke = method.invoke(us, arg2);</span><br><span class="line">    <span class="comment">//业务方法执行后要执行的操作，这里是提交事务</span></span><br><span class="line">		System.out.println(<span class="string">&quot;提交事务!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> invoke;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书写测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="comment">//动态代理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建被代理对象</span></span><br><span class="line">		UserService us = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">		<span class="comment">//创建Factory,传入被代理对象</span></span><br><span class="line">		UserServiceProxyFactory factory = <span class="keyword">new</span> UserServiceProxyFactory(us);</span><br><span class="line">		<span class="comment">//调用getUserServiceProxy()方法，返回代理对象</span></span><br><span class="line">		UserService usProxy = factory.getUserServiceProxy();</span><br><span class="line">		<span class="comment">//调用代理对象的增加方法</span></span><br><span class="line">		usProxy.save();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//代理对象与被代理对象实现了相同的接口</span></span><br><span class="line">		<span class="comment">//代理对象 与 被代理对象没有继承关系</span></span><br><span class="line">		System.out.println(usProxy <span class="keyword">instanceof</span> UserServiceImpl );<span class="comment">//false</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开事务！</span><br><span class="line">保存用户！</span><br><span class="line">提交事务！</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>2.使用cglib方式实现AOP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.UserService;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cglib代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxyFactory2</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserService <span class="title">getUserServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 创建 Cglib 的核心类:</span></span><br><span class="line">		Enhancer en = <span class="keyword">new</span> Enhancer();<span class="comment">//帮我们生成代理对象</span></span><br><span class="line">		<span class="comment">// 设置父类:</span></span><br><span class="line">		en.setSuperclass(UserServiceImpl.class);<span class="comment">//设置对谁进行代理</span></span><br><span class="line">		<span class="comment">// 设置父类:</span></span><br><span class="line">		en.setCallback(<span class="keyword">this</span>);<span class="comment">//代理要做什么</span></span><br><span class="line">		<span class="comment">// 生成代理：</span></span><br><span class="line">		UserService us = (UserService) en.create();<span class="comment">//创建代理对象</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> us;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object prxoyobj, Method method, Object[] arg, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//打开事务</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打开事务!&quot;</span>);</span><br><span class="line">		<span class="comment">//调用原有方法</span></span><br><span class="line">		Object returnValue = methodProxy.invokeSuper(prxoyobj, arg);</span><br><span class="line">		<span class="comment">//提交事务</span></span><br><span class="line">		System.out.println(<span class="string">&quot;提交事务!&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> returnValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>书写测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  UserServiceProxyFactory2 factory = <span class="keyword">new</span> UserServiceProxyFactory2();</span><br><span class="line">  </span><br><span class="line">  UserService usProxy = factory.getUserServiceProxy();</span><br><span class="line">  </span><br><span class="line">  usProxy.save();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断代理对象是否属于被代理对象类型</span></span><br><span class="line">  <span class="comment">//代理对象继承了被代理对象=&gt;true</span></span><br><span class="line">  System.out.println(usProxy <span class="keyword">instanceof</span> UserServiceImpl );<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">打开事务！</span><br><span class="line">保存用户！</span><br><span class="line">提交事务！</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h2><p><code>Joinpoint</code>(连接点):所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点.即目标对象中，所有可以增强的方法。</p>
<p><code>Pointcut</code>(切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义.即目标对象，已经增强的方法(已经增强了的连接点)。</p>
<p><code>Advice</code>(通知/增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)。即增强的代码,也就是上面的例子中的<code>System.out.println(&quot;打开事务!&quot;);</code>和<code>System.out.println(&quot;提交事务!&quot;);</code></p>
<p><code>Introduction</code>(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field.</p>
<p><code>Target</code>(目标对象):代理的目标对象.即被代理对象</p>
<p><code>Weaving</code>(织入):是指把增强应用到目标对象来创建新的代理对象的过程.spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装在期织入.指的是将通知应用到连接点，形成切入点的过程(成形代理过程).</p>
<p><code>Proxy</code>（代理）:一个类被 AOP 织入增强后，就产生一个结果代理类.(将通知织入到目标对象后，形成代理对象)</p>
<p><code>Aspect</code>(切面): 是切入点和通知（引介）的结合,即切入点+通知</p>
<h2 id="Spring中AOP的使用-xml配置"><a href="#Spring中AOP的使用-xml配置" class="headerlink" title="Spring中AOP的使用(xml配置)"></a>Spring中AOP的使用(xml配置)</h2><p>Spring中封装了动态代理的代码，所以不需要自己手写动态代理代码来实现AOP了。</p>
<p>需要第三方依赖包<code>com.springsource.org.aopalliance-1.0.0.jar</code>、<code>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</code>(具体版本可自己选择其他的)</p>
<h3 id="准备目标对象"><a href="#准备目标对象" class="headerlink" title="准备目标对象"></a>准备目标对象</h3><p>使用上一节中的<code>UserServiceImpl</code>类.</p>
<h3 id="准备通知"><a href="#准备通知" class="headerlink" title="准备通知"></a>准备通知</h3><p>通知类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.e_springaop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;	</span><br><span class="line">	<span class="comment">//前置通知  目标方法运行之前调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置通知(如果出现异常不调用) 目标方法运行之后调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterNoExc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;后置通知(如果出现异常不调用)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//环绕通知 目标方法之前和之后都调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;环绕通知,前置部分&quot;</span>);</span><br><span class="line">		Object proceed = pjp.proceed();</span><br><span class="line">		System.out.println(<span class="string">&quot;环绕通知,后置部分&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> proceed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//异常拦截通知  如果出现异常则调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;异常拦截通知&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置通知(无论是否出现异常都会调用)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterWithExc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;后置通知(无论是否出现异常都会调用)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置进行织入-将通知织入目标对象中"><a href="#配置进行织入-将通知织入目标对象中" class="headerlink" title="配置进行织入,将通知织入目标对象中"></a>配置进行织入,将通知织入目标对象中</h3><p>首先导入aop的xml约束（命名空间），方法和之前的类似。</p>
<p>在<code>my.study.e_springaop</code>包内书写配置文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置目标对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userServiceTarget&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.service.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置通知对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.e_springaop.MyAdvice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置将通知织入目标对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- id可以自定义</span></span><br><span class="line"><span class="comment">			 expression=&quot;execute()&quot;为固定格式，传参为：</span></span><br><span class="line"><span class="comment">			 	public void my.study.service.UserServiceImpl.save()</span></span><br><span class="line"><span class="comment">			 	默认为public:</span></span><br><span class="line"><span class="comment">			 	void my.study.service.UserServiceImpl.save()</span></span><br><span class="line"><span class="comment">			 	返回值为任意的函数:</span></span><br><span class="line"><span class="comment">			 	* my.study.service.UserServiceImpl.save()</span></span><br><span class="line"><span class="comment">			 	UserServiceImpl类下的所有方法:</span></span><br><span class="line"><span class="comment">			 	* my.study.service.UserServiceImpl.*()</span></span><br><span class="line"><span class="comment">			 	</span></span><br><span class="line"><span class="comment">			 	参数为任意:</span></span><br><span class="line"><span class="comment">			 	* my.study.service.*ServiceImpl.*(..)</span></span><br><span class="line"><span class="comment">			 	my.study.service包下及其子包下的所有以ServiceImpl为结尾的类的所有方法:</span></span><br><span class="line"><span class="comment">			 	* my.study.service..*ServiceImpl.*()</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 指定myAdvice中的before方法切入到demo这个切入点中 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 其他几个类似 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterNoexc&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;exc&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;afterWithExc&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;demo&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>书写测试类:<br>使用了spring与junit整合测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.e_springaop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.service.UserService;</span><br><span class="line"><span class="comment">//创建容器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:my/study/e_springaop/applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Resource(name=&quot;userServiceTarget&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> UserService us;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		us.save();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前置通知</span><br><span class="line">环绕通知,前置部分</span><br><span class="line">保存用户!</span><br><span class="line">后置通知(无论是否出现异常都会调用)</span><br><span class="line">环绕通知,后置部分</span><br><span class="line">后置通知(如果出现异常不调用)</span><br></pre></td></tr></table></figure>

<h2 id="Spring中AOP的使用-注解配置"><a href="#Spring中AOP的使用-注解配置" class="headerlink" title="Spring中AOP的使用(注解配置)"></a>Spring中AOP的使用(注解配置)</h2><p>注解配置的步骤和使用xml配置的步骤类似，只是在配置文件中不需要使用<code>&lt;aop:config /&gt;</code>标签进行配置，而是在配置文件中开启注解，继续接下来的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置目标对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userServiceTarget&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.service.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置通知对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.f_springannotionaop.MyAdvice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启使用注解完成织入 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>my.study.f_springannotionaop</code>包下的<code>MyAdvice</code>类中，添加注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.f_springannotionaop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Pointcut(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前置通知  目标方法运行之前调用</span></span><br><span class="line">	<span class="meta">@Before(&quot;MyAdvice.cut()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置通知(如果出现异常不调用) 目标方法运行之后调用</span></span><br><span class="line">	<span class="meta">@AfterReturning(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterNoExc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;后置通知(如果出现异常不调用)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//环绕通知 目标方法之前和之后都调用</span></span><br><span class="line">	<span class="meta">@Around(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;环绕通知,前置部分&quot;</span>);</span><br><span class="line">		Object proceed = pjp.proceed();</span><br><span class="line">		System.out.println(<span class="string">&quot;环绕通知,后置部分&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> proceed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//异常拦截通知  如果出现异常则调用</span></span><br><span class="line">	<span class="meta">@AfterThrowing(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;异常拦截通知&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置通知(无论是否出现异常都会调用)</span></span><br><span class="line">	<span class="meta">@After(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterWithExc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;后置通知(无论是否出现异常都会调用)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Aspect</code>表示该类是一个通知类<br><code>@Before(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</code>表示该通知是一个前置通知，参数为<code>execution(* my.study.service.*ServiceImpl.*(..))&quot;)</code>进行指定切入点.<br><code>@AfterReturning(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</code>表示该通知是一个后置通知.<br><code>@Around(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</code>表示该通知是一个环绕通知<br><code>@AfterThrowing(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</code>表示该通知是一个异常拦截通知<br><code>@After(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</code>表示该通知是一个后置通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before(&quot;MyAdvice.cut()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中    <code>@Before(&quot;MyAdvice.cut()&quot;)</code>就等于<code>@Before(&quot;execution(* my.study.service.*ServiceImpl.*(..))&quot;)</code>，这样方便管理切入点</p>
<p>书写测试类，并打印结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环绕通知,前置部分</span><br><span class="line">前置通知</span><br><span class="line">保存用户!</span><br><span class="line">环绕通知,后置部分</span><br><span class="line">后置通知(无论是否出现异常都会调用)</span><br><span class="line">后置通知(如果出现异常不调用)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>学习笔记</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>[总结]What is deadlock?How to troubleshoot deadlocks?</title>
    <url>/2019/06/12/What-is-deadlock-How-to-troubleshoot-deadlocks/</url>
    <content><![CDATA[<h1 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h1><p>当两个(或多个)任务正在等待必须由另一线程释放的某个共享资源，而线程该线程又正在等待必须由前述任务之一释放的另一共享资源时，并发应用程序就出现了<strong>死锁</strong>。</p>
<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile modified=\&quot;2019-06-13T07:32:26.952Z\&quot; host=\&quot;www.draw.io\&quot; agent=\&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36\&quot; etag=\&quot;N6TJ4Wx920oDQg6_8sun\&quot; version=\&quot;10.7.7\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;_GEg1l8nubf1ai1I0eZx\&quot; name=\&quot;第 1 页\&quot;&gt;zVffk5owEP5rfGwHEhR9rD96nU5vxtGH3j1mYA/SBsLEoNC/vkGCIaKed6eeL072y27I7n4fKz08SYoHQbL4kYfAesgJix6e9hAaeo76rYCyBrwBqoFI0LCGXAMs6T/QoI6LchrCynKUnDNJMxsMeJpCIC2MCME3ttsLZ/ZTMxJBB1gGhHXR3zSUsU4L+Qb/ATSKmye7g1G9k5DGWWeyiknINy0Iz3p4IjiX9SopJsCq2jV1qeO+H9ndXUxAKs8JYEMf/gazxfjnFM0elw+LPMq+DPTdZNkkDKHKX5tcyJhHPCVsZtCx4HkaQnWqoyzj84vzTIGuAv+AlKVuJsklV1AsE6Z31YVF+aTjt8ZzZXztN+a0aG9OS20FuVhvn7s9pKDyyYQp67kJUmtzQmU0B9TJVhkeraGGVjwXAZwoXMNFIiKQJ/zQrtNKIcATUAmpOAGMSLq270E0V6Odnw79JgQpWw4Zp6lctU6eV4By0Kob9esDteZQ32KGWtQHNlbrZgbasucNTNI5rAnLdVZzt0OuTUwlLDOyLe1GvTBsYpBVVmv4hRZVo3XD1iAkFKdb1i2xDvAdqxbY0fbGqFmXx4lbQm6wQz1pFfLtdfLfoTiL+BeUn1HcTjsn5HdB9aAz1YM/qJ4PdQp1GL3oMlq91bNqqapAGAPGI0ESVawMBFXXALG/Nzcb41fkcAH2I8emv+J/h/7+Afp716L/8H7o79rTx39t/ByeOO6tJg4+UzPeZ0wc3LdHjuf41x85uDty0D2MHIz3RDf65Jkzuh/R7c0c93YzxztTP0d6e5uZ43VnTpfSdz5z3NHeX67h1WaOMs0HVP1aMV+hePYf&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>

<p>当系统中同时出现如下四种条件时，就会导致这种情形。我们称其为<strong>Coffman条件</strong>(产生死锁的4个必要条件)</p>
<p>如果一个系统中如下4种情形同时存在，则产生死锁情形的机会就会上升</p>
<ul>
<li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用(死锁中涉及的资源必须是不可共享的。一次只有一个任务可以使用该资源)</li>
<li><strong>占有并等待条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放(一个任务在占有某一互斥的资源时又请求另一互斥的资源。当它在等待时，不会释放任何资源)</li>
<li><strong>不可剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放(资源只能被那些持有它们的任务释放)</li>
<li><strong>循环等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。例如存在进程集合{P1,P2,P3….Pn}，P1 申请P2获取的资源，P2申请P3资源….而Pn申请P1获取的资源，这样形成了一个闭环，即循环等待。</li>
</ul>
<p>这4个条件即Coffman条件，由Edward G.Coffman, Jr先生于1971年首次提出。</p>
<h1 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h1><p>有一些机制可以用来避免死锁：</p>
<ul>
<li><strong>忽略它们</strong>：这是最常用的机制。你可以假设自己的系统绝对不会出现死锁，而如果发生死锁，结果就是你可以停止应用程序并且重新执行它。</li>
<li><strong>检测与修复</strong>：系统中有一项专门分析系统状态的任务，可以检测是否发生了死锁。如果它检测到了死锁，可以采取一些措施来修复该问题，例如，结束某个任务或者强制释放某一资源。</li>
<li><strong>预防</strong>：如果你想防止系统出现死锁，就必须预防Coffman条件中的一条或者多条出现。</li>
<li><strong>规避</strong>：如果你可以在某一任务执行之前得到该任务所使用资源的相关信息，那么死锁是可以规避的。当一个任务要开始执行时，你可以对系统中空闲的资源和任务所需的资源进行分析，这样就可以判断任务是否能够开始执行。</li>
</ul>
<h2 id="忽略它们"><a href="#忽略它们" class="headerlink" title="忽略它们"></a>忽略它们</h2><p>有时候也称为鸵鸟策略：<br>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="死锁检测与修复"><a href="#死锁检测与修复" class="headerlink" title="死锁检测与修复"></a>死锁检测与修复</h2><ul>
<li>每种类型一个资源的死锁检测<br>  <img src="What-is-deadlock-How-to-troubleshoot-deadlocks/1.png"><br>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。<br>图a可以抽取出环，如图b，它满足了环路等待条件，因此会发生死锁。</li>
<li>*每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现**，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li>
<li>每种类型多个资源的死锁检测<br><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/2.png"><br>上图中，有三个进程四个资源，每个数据代表的含义如下：<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量<br>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。<br>算法总结如下：<br>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</li>
</ul>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
</li>
<li>死锁恢复<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
</li>
</ul>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><ul>
<li>破坏互斥条件<br>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</li>
<li>破坏占有并等待条件<br>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</li>
<li>破坏不可抢占条件</li>
<li>破坏环路等待<br>给资源统一编号，进程只能按编号顺序来请求资源。</li>
</ul>
<p>比如:</p>
<ul>
<li>超时放弃<br>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。</li>
</ul>
<h2 id="死锁规避-避免"><a href="#死锁规避-避免" class="headerlink" title="死锁规避(避免)"></a>死锁规避(避免)</h2><p>在程序运行时避免发生死锁。</p>
<ul>
<li><p>安全状态<br><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/3.png"><br>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
</li>
<li><p>单个资源的银行家算法<br>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。<br><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/4.png"><br>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
</li>
<li><p>多个资源的银行家算法<br><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/5.png"><br>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。<br>如果一个状态不是安全的，需要拒绝进入这个状态。</li>
</ul>
</li>
</ul>
<h1 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h1><p><a href="http://tpcg.io/EW1UmT">http://tpcg.io/EW1UmT</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object a = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">final</span> Object b = <span class="keyword">new</span> Object();</span><br><span class="line">    Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;now i in threadA-locka&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;now i in threadA-lockb&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;now i in threadB-lockb&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;now i in threadB-locka&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadA.start();</span><br><span class="line">    threadB.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">now i in threadA-locka</span><br><span class="line">now i in threadB-lockb</span><br></pre></td></tr></table></figure>

<h1 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h1><h2 id="Jstack命令"><a href="#Jstack命令" class="headerlink" title="Jstack命令"></a>Jstack命令</h2><p>jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。<br>Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。<br>首先，我们通过jps确定当前执行任务的进程号:</p>
<p>首先，我们通过jps确定当前执行任务的进程号:<br><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/6.png"></p>
<p>可以确定任务进程号是51028，然后执行jstack命令查看当前进程堆栈信息(在eclipse中运行后可能会有jstack无法连接报错的信息，所以我换成了IDEA来执行 ORZ)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\homxu&gt;jps</span><br><span class="line">10896</span><br><span class="line">47284 Jps</span><br><span class="line">52168 DeadLock</span><br><span class="line"></span><br><span class="line">C:\Users\homxu&gt;jstack -F 52168</span><br><span class="line">Attaching to process ID 52168, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.144-b01</span><br><span class="line">Deadlock Detection:</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000569a3968 (Object@0x00000000e071b2f8, a java/lang/Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock Monitor@0x00000000569a1188 (Object@0x00000000e071b2e8, a java/lang/Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line"></span><br><span class="line">Found a total of 1 deadlock.</span><br><span class="line"></span><br><span class="line">Thread 1: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 23: (state = BLOCKED)</span><br><span class="line"> - com.study.DeadLock$2.run() @bci=28, line=30 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 22: (state = BLOCKED)</span><br><span class="line"> - com.study.DeadLock$1.run() @bci=28, line=14 (Interpreted frame)</span><br><span class="line"> - java.lang.Thread.run() @bci=11, line=748 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 15: (state = IN_NATIVE)</span><br><span class="line"> - java.net.SocketInputStream.socketRead0(java.io.FileDescriptor, byte[], int, int, int) @bci=0 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"> - java.net.SocketInputStream.socketRead(java.io.FileDescriptor, byte[], int, int, int) @bci=8, line=116 (Interpret</span><br><span class="line">ed frame)</span><br><span class="line"> - java.net.SocketInputStream.read(byte[], int, int, int) @bci=117, line=171 (Interpreted frame)</span><br><span class="line"> - java.net.SocketInputStream.read(byte[], int, int) @bci=11, line=141 (Interpreted frame)</span><br><span class="line"> - sun.nio.cs.StreamDecoder.readBytes() @bci=135, line=284 (Interpreted frame)</span><br><span class="line"> - sun.nio.cs.StreamDecoder.implRead(char[], int, int) @bci=112, line=326 (Interpreted frame)</span><br><span class="line"> - sun.nio.cs.StreamDecoder.read(char[], int, int) @bci=180, line=178 (Interpreted frame)</span><br><span class="line"> - java.io.InputStreamReader.read(char[], int, int) @bci=7, line=184 (Interpreted frame)</span><br><span class="line"> - java.io.BufferedReader.fill() @bci=145, line=161 (Interpreted frame)</span><br><span class="line"> - java.io.BufferedReader.readLine(boolean) @bci=44, line=324 (Interpreted frame)</span><br><span class="line"> - java.io.BufferedReader.readLine() @bci=2, line=389 (Interpreted frame)</span><br><span class="line"> - com.intellij.rt.execution.application.AppMainV2$1.run() @bci=36, line=64 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 14: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 13: (state = BLOCKED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 12: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 11: (state = BLOCKED)</span><br><span class="line"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</span><br><span class="line"> - java.lang.Object.wait() @bci=2, line=502 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference.tryHandlePending(boolean) @bci=54, line=191 (Interpreted frame)</span><br><span class="line"> - java.lang.ref.Reference$ReferenceHandler.run() @bci=1, line=153 (Interpreted frame)</span><br></pre></td></tr></table></figure>

<p>可以看到，进程的确存在死锁，两个线程分别在等待对方持有的Object对象</p>
<h2 id="JConsole工具"><a href="#JConsole工具" class="headerlink" title="JConsole工具"></a>JConsole工具</h2><p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。<br>我们在命令行中敲入jconsole命令，会自动弹出以下对话框，选择进程52168，并点击“链接”<br><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/7.png"></p>
<p><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/8.png"></p>
<p><img src="What-is-deadlock-How-to-troubleshoot-deadlocks/9.png"></p>
<p>可以看到进程中存在死锁。<br>以上例子我都是用synchronized关键词实现的死锁，如果读者用ReentrantLock制造一次死锁，再次使用死锁检测工具，也同样能检测到死锁，不过显示的信息将会更加丰富，有兴趣的读者可以自己尝试一下。</p>
<blockquote>
<p>在我的理解当中，死锁就是“两个任务以不合理的顺序互相争夺资源”造成，因此为了规避死锁，应用程序需要妥善处理资源获取的顺序。<br>另外有些时候，死锁并不会马上在应用程序中体现出来，在通常情况下，都是应用在生产环境运行了一段时间后，才开始慢慢显现出来，在实际测试过程中，由于死锁的隐蔽性，很难在测试过程中及时发现死锁的存在，而且在生产环境中，应用出现了死锁，往往都是在应用状况最糟糕的时候——在高负载情况下。因此，开发者在开发过程中要谨慎分析每个系统资源的使用情况，合理规避死锁，另外一旦出现了死锁，也可以尝试使用本文中提到的一些工具，仔细分析，总是能找到问题所在的。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《精通JAVA并发编程(第二版)》</li>
<li><a href="https://www.cnblogs.com/thomaschen750215/p/4109646.html">https://www.cnblogs.com/thomaschen750215/p/4109646.html</a></li>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81?id=%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D">https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81?id=%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D</a></li>
<li><a href="https://juejin.im/post/5aaf6ee76fb9a028d3753534#heading-1">https://juejin.im/post/5aaf6ee76fb9a028d3753534#heading-1</a></li>
</ul>
<script type="text/javascript" src="https://www.draw.io/js/viewer.min.js"></script>]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2018/07/18/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>因为hexo博客之前出过一些问题，导致之前做的git笔记被覆盖掉丢失了。所以这次再一次整理一下git的一些常用操作并记录下来。</p>
<h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>进入到要创建仓库的文件夹,输入命令</p>
<ul>
<li><code>git init</code><br>这时候会有提示 <img src="git%E7%AC%94%E8%AE%B0/1.png" alt="创建仓库"><br>然后目录下会多一个<code>.git</code>的隐藏文件夹。</li>
</ul>
<p>另外一种方式</p>
<ul>
<li><code>git init demo</code> 初始化到一个叫demo的自定义文件夹</li>
</ul>
<p>另外可以从远程仓库初始化</p>
<ul>
<li><p><code>git clone https://github.com/xxxxxxxxx.git</code> 克隆项目</p>
</li>
<li><p><code>git clone https://github.com/xxxxxxxxx.git demo</code> 克隆项目到一个叫demo的自定义文件夹</p>
</li>
</ul>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><ul>
<li><code>git status</code> 查看仓库状态<br><img src="git%E7%AC%94%E8%AE%B0/2.png" alt="创建仓库"></li>
</ul>
<p>No commits yet 是指没有提交记录<br>Untracked files 是指未跟踪到的文件，指有文件更改了但是没有commit</p>
<ul>
<li><p><code>git add .</code> 将所有修改添加至暂存区</p>
</li>
<li><p><code>git commit -m &quot;描述&quot;</code>  提交版本(即在这个历史节点下修改和做了什么)</p>
</li>
<li><p><code>git add . &amp;&amp; git commit -m &quot;描述&quot;</code> 同时执行两次操作<br>这时候再查看仓库状态，可以看到nothing to commit</p>
</li>
</ul>
<p><img src="git%E7%AC%94%E8%AE%B0/3.png" alt="提交至缓存区并提交版本"></p>
<ul>
<li><code>git log</code> 查看版本记录<br>黄色的一串字母数字组合表示唯一标识</li>
</ul>
<p>下面则是描述说明的内容</p>
<p><img src="git%E7%AC%94%E8%AE%B0/4.png" alt="查看版本记录"></p>
<ul>
<li><p><code>git log -p</code>可以看到修改的具体信息</p>
</li>
<li><p><code>git log --oneline</code> 一行显示</p>
</li>
<li><p><code>git checkout xxx</code> 穿越到指定的历史节点,xxx表示上面的唯一标识,可以不用输入全部()</p>
</li>
<li><p><code>git checkout -</code> 回到原来的节点</p>
</li>
</ul>
<h1 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h1><ul>
<li><code>modefied</code> 已修改</li>
<li><code>staged</code> 已暂存(缓冲阶段)</li>
<li><code>commited</code> 已提交</li>
<li><code>git diff</code> 比对当前内容和暂存区内容。</li>
<li><code>git diff HEAD</code> 比对当前内容和最近一次提交。</li>
<li><code>git diff HEAD^</code> 比对当前内容和倒数第二次提交。</li>
<li><code>git diff HEAD^ HEAD</code> 比对最近两次提交。<h1 id="标签tag"><a href="#标签tag" class="headerlink" title="标签tag"></a>标签tag</h1></li>
</ul>
<p>项目开发中，在版本提交时会有很多小版本，但是其中有一些节点很重要，比如完成某些重要的功能，可以在这个重要的节点使用标签做标记。</p>
<ul>
<li><p><code>git tag -a 标签名 -m &quot;备注&quot;</code> 添加tag (a=annotated有注释的) 默认加在最近的节点上面</p>
</li>
<li><p><code>git tag -a 标签名 -m &quot;备注&quot; 版本号</code> 在历史节点添加标签，最后加上历史版本号</p>
</li>
<li><p><code>git tag</code>  罗列所有tag</p>
</li>
</ul>
<p><img src="git%E7%AC%94%E8%AE%B0/5.png" alt="tag"></p>
<ul>
<li>command1 &amp;&amp; command2 ：组合命令</li>
<li>添加 -a 属性，才可以后接-m属性</li>
<li><code>git show 标签名</code> 显示tag信息</li>
<li><code>git checkout 标签名</code> 回到tag所在的提交</li>
</ul>
<h1 id="分支branch"><a href="#分支branch" class="headerlink" title="分支branch"></a>分支branch</h1><ul>
<li><code>git branch $branchName</code>  在当前节点创建分支</li>
<li><code>git checkout $branchName</code> 切换到分支(可以跳转到不同分支)</li>
<li><code>git log --all --graph</code> 图形化显示</li>
</ul>
<p>分支的作用主要是利用分支进行当前问题的处理（比如在某个版本分支出来进行调试bug，但是在master继续版本的推进，在bug修复后合并分支，这样bug得到了解决版本也进行了推进）。</p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><ul>
<li><code>git checkout -b $branchName</code> 创建并切换至分支</li>
<li><code>git merge $branchName</code> 合并分支</li>
</ul>
<p>合并一个文件要用人工进行处理orz</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul>
<li><code>git remote add $remoteName $giturl</code>添加远程仓库</li>
<li><code>git push -u $remoteName $branchName</code>push到远程分支<br><img src="git%E7%AC%94%E8%AE%B0/7.png" alt="push"><br>输入github的用户名密码就自动开始push了</li>
<li><code>git remote -v</code> 打印远程仓库信息</li>
</ul>
<p><img src="git%E7%AC%94%E8%AE%B0/6.png" alt="remote"><br>fetch是下载地址，push是上传地址</p>
<ul>
<li><p><code>git clone $giturl</code> 克隆</p>
</li>
<li><p><code>git pull</code> = <code>git fetch &amp;&amp; git merge</code></p>
</li>
</ul>
<p><img src="git%E7%AC%94%E8%AE%B0/8.png" alt="总结"></p>
<p>根据<code>表严肃</code>老师的视频进行整理 <a href="http://biaoyansu.com/i/6593023230131">http://biaoyansu.com/i/6593023230131</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop遇到的一些坑</title>
    <url>/2018/07/24/hadoop%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    <content><![CDATA[<p>最近开始了大数据的基础学习，刚开始就踩了一些坑。在这里做一下简要记录。</p>
<h1 id="WARN-util-NativeCodeLoader-Unable-to-load-native-hadoop-library-for-your-platform…"><a href="#WARN-util-NativeCodeLoader-Unable-to-load-native-hadoop-library-for-your-platform…" class="headerlink" title="WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform…"></a>WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform…</h1><p>由于好久没有打开ubuntu系统使用hadoop，不知道是什么原因，今天运行hadoop的一些命令的时候有警告： <code>WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</code><br>百思不得其解，在开始安装好hadoop的时候是没有任何问题的，之后也没有动过。<br>搜索了一圈问题后，都说是电脑上的本地库和hadoop的需求不一致，但是我改了一圈也还是没有解决问题。后在这里找到方法并且尝试后解决了。<a href="https://blog.csdn.net/znb769525443/article/details/51507283">https://blog.csdn.net/znb769525443/article/details/51507283</a></p>
<p>这里根据上面博客的内容简要摘录：</p>
<blockquote>
<p>增加调试信息，执行命令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_ROOT_LOGGER=DEBUG,console</span><br><span class="line">hadoop fs -text est/data/origz/access.log.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样就能够看到报错的信息<br>解决方法：<br>修改<code>/HADOOP_HOME/etc/hadoop/中的hadoop_env.sh</code>在头部添加</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=&quot;/usr/local/hadoop/lib/native/&quot;</span><br><span class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.library.path=/usr/local/hadoop/lib/native/&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次执行./start-dfs.sh </p>
</blockquote>
<p>问题解决。</p>
<p>当然每个人的错误虽然相似，但是错误原因可能不同，这里学会了一招看报错的log信息<br>hadoop开启关闭调试信息：</p>
<p>开启：<code>export HADOOP_ROOT_LOGGER=DEBUG,console</code> </p>
<p>关闭：<code>export HADOOP_ROOT_LOGGER=INFO,console</code></p>
<h1 id="hadoop集群启动之后dataNode节点没有启动"><a href="#hadoop集群启动之后dataNode节点没有启动" class="headerlink" title="hadoop集群启动之后dataNode节点没有启动"></a>hadoop集群启动之后dataNode节点没有启动</h1><p>今天遇到的另一个问题是，在hadoop操作的时候，向某个文件夹复制文件的时候报错：<code>ARN hdfs.DataStreamer: DataStreamer Exception org.apache.hadoop.ipc.RemoteException</code><br>然后锁定问题是dataNode节点没有启动，使用了命令<code>stop-all.sh start-all.sh</code>重启后仍然没有用。</p>
<p>使用了<a href="https://blog.csdn.net/qq_20124743/article/details/78668130">https://blog.csdn.net/qq_20124743/article/details/78668130</a> 的方法得到了解决。</p>
<blockquote>
<p>启动Hadoop集群之后slave机器的dataNode节点没有启动 master机器的nameNode节点启动了</p>
</blockquote>
<blockquote>
<p>1、在集群/usr/local/src/hadoop/bin目录下./stop-all.sh暂停所有服务</p>
</blockquote>
<blockquote>
<p>2、将/usr/local/src/hadoop/目录下的 logs、tmp文件夹删除(DataNode存放数据块的位置) 然后重新建立tmp  logs文件夹</p>
</blockquote>
<blockquote>
<p>3、重新格式化: （同样是在bin目录下）./hadoop namenode -format</p>
</blockquote>
<blockquote>
<p>4、重新启动集群：./start-all.sh</p>
</blockquote>
<blockquote>
<p>5、通过jps查看进程 就好了 </p>
</blockquote>
]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>webpack5版本，使用webpack-dev-server报错</title>
    <url>/2021/01/15/webpack5%E7%89%88%E6%9C%AC%EF%BC%8C%E4%BD%BF%E7%94%A8webpack-dev-server%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>在学习Webpack时，需要通过server方式运行，开始使用<code>--save-dev</code>的方式进行安装，无奈报错；搜索相关博客，有的解释使用<code>global</code>方式安装，但是用这种方式安装后，运行依然报错。</p>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;02configuration&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --open --hot&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^5.14.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^4.3.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.11.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h1><p>使用以下命令报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">D:\study\Webpack\webpack-lagou\02configuration&gt;npm run dev</span><br><span class="line"></span><br><span class="line">&gt; 02configuration@<span class="number">1.0</span><span class="number">.0</span> dev D:\study\Webpack\webpack-lagou\02configuration</span><br><span class="line">&gt; webpack-dev-server --open --hot</span><br><span class="line"></span><br><span class="line">internal/modules/cjs/loader.js:<span class="number">968</span></span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">  ^</span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>: Cannot find <span class="built_in">module</span> <span class="string">&#x27;webpack-cli/bin/config-yargs&#x27;</span></span><br><span class="line">Require stack:</span><br><span class="line">- D:\study\Webpack\webpack-lagou\02configuration\node_modules\webpack-dev-server\bin\webpack-dev-server.js</span><br><span class="line">    at <span class="built_in">Function</span>.Module._resolveFilename (internal/modules/cjs/loader.js:<span class="number">965</span>:<span class="number">15</span>)</span><br><span class="line">    at <span class="built_in">Function</span>.Module._load (internal/modules/cjs/loader.js:<span class="number">841</span>:<span class="number">27</span>)</span><br><span class="line">    at Module.require (internal/modules/cjs/loader.js:<span class="number">1025</span>:<span class="number">19</span>)</span><br><span class="line">    at <span class="built_in">require</span> (internal/modules/cjs/helpers.js:<span class="number">72</span>:<span class="number">18</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.&lt;anonymous&gt; (D:\study\Webpack\webpack-lagou\02configuration\node_modules\webpack-dev-server\bin\webpack-dev-server.js:<span class="number">65</span>:<span class="number">1</span>)</span><br><span class="line">    at Module._compile (internal/modules/cjs/loader.js:<span class="number">1137</span>:<span class="number">30</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.Module._extensions..js (internal/modules/cjs/loader.js:<span class="number">1157</span>:<span class="number">10</span>)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:<span class="number">985</span>:<span class="number">32</span>)</span><br><span class="line">    at <span class="built_in">Function</span>.Module._load (internal/modules/cjs/loader.js:<span class="number">878</span>:<span class="number">14</span>)</span><br><span class="line">    at <span class="built_in">Function</span>.executeUserEntryPoint [<span class="keyword">as</span> runMain] (internal/modules/run_main.js:<span class="number">71</span>:<span class="number">12</span>) &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="string">&#x27;MODULE_NOT_FOUND&#x27;</span>,</span><br><span class="line">  <span class="attr">requireStack</span>: [</span><br><span class="line">    <span class="string">&#x27;D:\\study\\Webpack\\webpack-lagou\\02configuration\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno <span class="number">1</span></span><br><span class="line">npm ERR! 02configuration@<span class="number">1.0</span><span class="number">.0</span> dev: <span class="string">`webpack-dev-server --open --hot`</span></span><br><span class="line">npm ERR! Exit status <span class="number">1</span></span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the 02configuration@<span class="number">1.0</span><span class="number">.0</span> dev script.</span><br><span class="line">npm ERR! This is probably not a problem <span class="keyword">with</span> npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log <span class="keyword">of</span> <span class="built_in">this</span> run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\<span class="number">2021</span>-<span class="number">01</span>-14T09_42_44_662Z-debug.log</span><br></pre></td></tr></table></figure>

<p>主要错误是找不到<code>webpack-dev-server</code>的module.<br>由于安装webpack时使用了默认的<code>npm install webpack</code>,并未指定版本，因此默认安装了新版——webpack5.所以有可能是版本的问题</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>后来在 <a href="https://blog.csdn.net/peter_hzq/article/details/109683913">https://blog.csdn.net/peter_hzq/article/details/109683913</a> 找到了类似的问题</p>
<p>我采用第二种方式，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx webpack serve</span><br></pre></td></tr></table></figure>
<p>运行，可以顺利启动</p>
<p>博客中第一种方法：<code>webpack-cli</code>的版本降为<code>3.3.12</code>，该方式未验证是否有效</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>react-transition-group结合多个styled-components组件动画不生效的问题</title>
    <url>/2021/02/04/react-transition-group%E7%BB%93%E5%90%88%E5%A4%9A%E4%B8%AAstyled-components%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="问题相关环境"><a href="#问题相关环境" class="headerlink" title="问题相关环境"></a>问题相关环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;react&quot;: &quot;^16.13.1&quot;,</span><br><span class="line">&quot;react-transition-group&quot;: &quot;^4.4.1&quot;,</span><br><span class="line">&quot;styled-components&quot;: &quot;^5.2.0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>创建sidebar，点击控制按钮时，显示侧边栏的各个Item。但是没有动画，组件的显示与关闭都是瞬间完成，这样看起来很突兀，所以想给元素enter和exit的时候加一个过渡动画。</p>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; CSSTransition,TransitionGroup &#125; <span class="keyword">from</span> <span class="string">&#x27;react-transition-group&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; actionCreators &#125; <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; </span><br><span class="line">    SideBarLeftWrapper,</span><br><span class="line">    SideBarLeftBtn,</span><br><span class="line">    SideBarMenu,</span><br><span class="line">    SideBarMenuItem</span><br><span class="line"> &#125; <span class="keyword">from</span> <span class="string">&#x27;./style&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> menuItemsJson <span class="keyword">from</span> <span class="string">&#x27;../../static/json/sideBar.config.json&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SideBar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">super</span>(props)</span><br><span class="line">      <span class="built_in">this</span>.getMenuItems = <span class="built_in">this</span>.getMenuItems.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getMenuItems = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;isShowMenu&#125; = <span class="built_in">this</span>.props</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">          <span class="xml"><span class="tag">&lt;<span class="name">TransitionGroup</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;</span></span><br><span class="line"><span class="xml">              menuItemsJson.map( (item,index) =&gt; (</span></span><br><span class="line"><span class="xml">                // isShowmenu控制某些css元素的显示与否</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CSSTransition</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">in</span>=<span class="string">&#123;isShowMenu&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">timeout</span>=<span class="string">&#123;200&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">classNames</span>=<span class="string">&#x27;slide&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">unmountOnExit</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                &gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">SideBarMenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">                      <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;iconfont&#x27;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span> <span class="attr">__html:</span> <span class="attr">item.name</span>&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;/<span class="name">SideBarMenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">CSSTransition</span>&gt;</span></span></span><br><span class="line"><span class="xml">              ) )</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">            </span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">TransitionGroup</span>&gt;</span></span></span><br><span class="line">        ) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;handleMenuBtnClick,isShowMenu&#125; = <span class="built_in">this</span>.props</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">SideBarLeftWrapper</span> <span class="attr">isShowMenu</span>=<span class="string">&#123;isShowMenu&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">SideBarLeftBtn</span> <span class="attr">isShowMenu</span>=<span class="string">&#123;isShowMenu&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;handleMenuBtnClick(isShowMenu)&#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                        <span class="attr">className</span>=<span class="string">&quot;iconfont menu-btn&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    &gt;</span><span class="symbol">&amp;#xe7f2;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">SideBarLeftBtn</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  &#123; this.getMenuItems() &#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">SideBarLeftWrapper</span>&gt;</span></span></span><br><span class="line">            </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&#123;</span><br><span class="line">        <span class="attr">isShowMenu</span>: state.getIn([<span class="string">&#x27;sidebar&#x27;</span>,<span class="string">&#x27;isShowMenu&#x27;</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToDispatch = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">handleMenuBtnClick</span>: <span class="function">(<span class="params">isShowMenu</span>) =&gt;</span> &#123;</span><br><span class="line">            dispatch(actionCreators.menuFocus(isShowMenu))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps,mapStateToDispatch)(SideBar);</span><br></pre></td></tr></table></figure>

<h3 id="style-js"><a href="#style-js" class="headerlink" title="style.js"></a>style.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SideBarLeftWrapper = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: <span class="subst">$&#123;props =&gt; (props.isShowMenu ? <span class="string">&#x27;130px&#x27;</span> : <span class="string">&#x27;0&#x27;</span>)&#125;</span>;</span></span><br><span class="line"><span class="string">  height: 96%;</span></span><br><span class="line"><span class="string">  margin: 10px 0 0 10px;</span></span><br><span class="line"><span class="string">  float: left;</span></span><br><span class="line"><span class="string">  z-index: 100;</span></span><br><span class="line"><span class="string">  position: absolute;</span></span><br><span class="line"><span class="string">  transition: all 0.5s;</span></span><br><span class="line"><span class="string">  -moz-transition: width 0.5;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SideBarLeftBtn = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: 20px;</span></span><br><span class="line"><span class="string">  height: 20px;  </span></span><br><span class="line"><span class="string">  background: rgba(246,246,246,0.2);</span></span><br><span class="line"><span class="string">  z-index: 999;</span></span><br><span class="line"><span class="string">  margin: 5px 10px 10px 10px;</span></span><br><span class="line"><span class="string">  margin-left: <span class="subst">$&#123;props =&gt; props.isShowMenu ? <span class="string">&#x27;100px&#x27;</span> : <span class="string">&#x27;5px&#x27;</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  transform: <span class="subst">$&#123;props =&gt; props.isShowMenu ? <span class="string">&#x27;rotate(450deg)&#x27;</span> : <span class="string">&#x27;rotate(0deg)&#x27;</span>&#125;</span>;</span></span><br><span class="line"><span class="string">  transition: all 1s;</span></span><br><span class="line"><span class="string">  cursor: pointer;</span></span><br><span class="line"><span class="string">  .menu-btn&#123;</span></span><br><span class="line"><span class="string">    font-size: 25px;</span></span><br><span class="line"><span class="string">    color: white;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  /* &amp;:hover&#123;</span></span><br><span class="line"><span class="string">    transform:scale(1.3);</span></span><br><span class="line"><span class="string">    -ms-transform:scale(1.3); 	</span></span><br><span class="line"><span class="string">    -moz-transform:scale(1.3); 	</span></span><br><span class="line"><span class="string">    -webkit-transform:scale(1.3); </span></span><br><span class="line"><span class="string">    -o-transform:scale(1.3); 	</span></span><br><span class="line"><span class="string">  &#125; */</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SideBarMenu = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: 98%;</span></span><br><span class="line"><span class="string">  height: 90%;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SideBarMenuItem = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">	float: left;</span></span><br><span class="line"><span class="string">	margin: 5px;</span></span><br><span class="line"><span class="string">	padding: 0;</span></span><br><span class="line"><span class="string">	border: 3px solid;</span></span><br><span class="line"><span class="string">	background: none; </span></span><br><span class="line"><span class="string">	color: #a8d8ea;</span></span><br><span class="line"><span class="string">	vertical-align: middle;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">	position: relative;</span></span><br><span class="line"><span class="string">	z-index: 1;</span></span><br><span class="line"><span class="string">  -webkit-transition: all 1s;</span></span><br><span class="line"><span class="string">	transition: all 1s;</span></span><br><span class="line"><span class="string">  border-radius: 15px;</span></span><br><span class="line"><span class="string">  font-weight: 500;</span></span><br><span class="line"><span class="string">  min-width: 120px;</span></span><br><span class="line"><span class="string">  max-width: 200px;</span></span><br><span class="line"><span class="string">  letter-spacing: 2px;</span></span><br><span class="line"><span class="string">  font-size: 14px;</span></span><br><span class="line"><span class="string">  &amp;:focus &#123;</span></span><br><span class="line"><span class="string">    outline: 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">   &gt; span &#123;</span></span><br><span class="line"><span class="string">    display: block;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  &amp;:after &#123;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  :hover &#123;</span></span><br><span class="line"><span class="string">    border-color: #3f51b5;</span></span><br><span class="line"><span class="string">    background-color: rgba(63, 81, 181, 0.1);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    border-color: #fff;</span></span><br><span class="line"><span class="string">    background-color: #21333C;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;::after &#123;</span></span><br><span class="line"><span class="string">    opacity: 1;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">    -webkit-transform: translate3d(0, 0, 0);</span></span><br><span class="line"><span class="string">    transform: translate3d(0, 0, 0);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;:hover &gt; span &#123;</span></span><br><span class="line"><span class="string">    opacity: 1;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">    border: 3px #ffffff;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;.slide-enter &#123;</span></span><br><span class="line"><span class="string">      opacity:0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;.slide-enter-active &#123;</span></span><br><span class="line"><span class="string">      opacity: 1;</span></span><br><span class="line"><span class="string">      transition: all .5s ease-in;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;.slide-exit &#123;</span></span><br><span class="line"><span class="string">      opacity: 1;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;.slide-exit-active &#123;</span></span><br><span class="line"><span class="string">    opacity: 0;</span></span><br><span class="line"><span class="string">    transition: all .5s ease-in;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>最外层<code>SideBarLeftWrapper</code>为侧边栏容器div，<code>SideBarLeftBtn</code>为列表显示/关闭的空值按钮，点击时改变<strong>isShowMenu</strong>的值，<strong>isShowMenu</strong>变量空值列表元素的显示与否。<code>SideBarMenu</code>为侧边栏各元素的父元素，<code>SideBarMenuItem</code>为具体的每个侧边栏按钮元素，也就是要添加动画的对象。</p>
<p>在实践过程中，<code>SideBarMenuItem</code>元素从json文件中读取，使用map方法循环遍历后返回该元素，如果要为每个元素添加动画，那么要将<code>CSSTransition</code>标签包裹在<strong>每个</strong>元素外面，而且其里面只能有<strong>一个</strong>直接元素，也就是子元素（孙子元素管不着）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">menuItemsJson.map( <span class="function">(<span class="params">item,index</span>) =&gt;</span> (</span><br><span class="line">   <span class="comment">// isShowmenu控制某些css元素的显示与否</span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">CSSTransition</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">in</span>=<span class="string">&#123;isShowMenu&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">timeout</span>=<span class="string">&#123;200&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">classNames</span>=<span class="string">&#x27;slide&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     <span class="attr">unmountOnExit</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">   &gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">SideBarMenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;iconfont&#x27;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span> <span class="attr">__html:</span> <span class="attr">item.name</span>&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">SideBarMenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">CSSTransition</span>&gt;</span></span></span><br><span class="line"> ) )</span><br></pre></td></tr></table></figure>

<p>由于之前在学习React的时候，看到当时的代码，多个<code>CSSTransition</code>标签外面要用<code>TransitionGroup</code>标签包裹起来，而我加上它以后有，反而没有动画</p>
<p><img src="./react-transition-group%E7%BB%93%E5%90%88%E5%A4%9A%E4%B8%AAstyled-components%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1.gif" alt="image"></p>
<p>而当去除了<code>TransitionGroup</code>父元素后，动画则生效了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getMenuItems = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;isShowMenu&#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">          menuItemsJson.map( <span class="function">(<span class="params">item,index</span>) =&gt;</span> (</span><br><span class="line">            <span class="comment">// isShowmenu控制某些css元素的显示与否</span></span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">CSSTransition</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">in</span>=<span class="string">&#123;isShowMenu&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">timeout</span>=<span class="string">&#123;200&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">classNames</span>=<span class="string">&#x27;slide&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">unmountOnExit</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            &gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">SideBarMenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;iconfont&#x27;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span> <span class="attr">__html:</span> <span class="attr">item.name</span>&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">SideBarMenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">CSSTransition</span>&gt;</span></span></span><br><span class="line">          ) )</span><br><span class="line">    ) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="./react-transition-group%E7%BB%93%E5%90%88%E5%A4%9A%E4%B8%AAstyled-components%E7%BB%84%E4%BB%B6%E5%8A%A8%E7%94%BB%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/2.gif" alt="image"></p>
<p>之前在学习完react后，就没有进行实践和练习，这次算是回顾+学习，遇到这个问题也是琢磨了很久，但是至于原因目前还没有摸清楚。</p>
<p>补充： 官网使用的<TransitionGroup>和<CSSTransition>标签搭配，见：<a href="https://reactcommunity.org/react-transition-group/transition-group">https://reactcommunity.org/react-transition-group/transition-group</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]乐观锁与悲观锁</title>
    <url>/2019/06/11/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p>无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。网上最常见的解答是数据库管理系统(DBMS)中锁的机制的介绍。当然不仅仅是在关系型数据库系统中有乐观锁和悲观锁的概念，像memcache(一个分布式内存对象缓存系统)、hibernate、tair(与redis类似,是一个分布式key/value存储系统)等都有类似的概念。</p>
<p>可见，只要是涉及到并发，就很难绕开”锁”。所以不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念。</p>
<h1 id="悲观锁-Pessimistic-Lock"><a href="#悲观锁-Pessimistic-Lock" class="headerlink" title="悲观锁(Pessimistic Lock)"></a>悲观锁(Pessimistic Lock)</h1><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据/修改数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁(一旦加锁，不同线程同时执行时,只能有一个线程执行，其他的线程在入口处等待，直到锁被释放)。</p>
<p>比如:</p>
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>Java的synchronized关键字</li>
</ul>
<p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p>
<p>这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p>
<p>DMBS中悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p>
<p>在数据库中，悲观锁的流程如下：</p>
<blockquote>
<p>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。<br>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。<br>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。<br>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p>
</blockquote>
<p><strong>优点和缺点</strong>:<br>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p>
<h1 id="乐观锁-Optimistic-Lock"><a href="#乐观锁-Optimistic-Lock" class="headerlink" title="乐观锁(Optimistic Lock)"></a>乐观锁(Optimistic Lock)</h1><p>顾名思义，就是很乐观，认为数据一般情况下不会造成冲突(认为操作不会产生并发问题(不会有其他线程对数据进行修改)，因此不会上锁)，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回用户错误的信息，让用户决定如何去做。</p>
<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p>
<p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<p><strong>优点和缺点</strong>：<br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。这样提高了效率，但是虽然事务之间数据竞争的概率是很小的，但是仍可能产生这种概率。</p>
<h1 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h1><p>乐观锁一般使用<code>版本号机制</code>或<code>CAS(compare and swap)</code>算法实现</p>
<h2 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h2><ul>
<li>取出记录时，获取当前<code>version</code></li>
<li>更新时，带上这个<code>version</code></li>
<li>执行更新时， set version = newVersion where version = oldVersion<br>如果version不对，就更新失败</li>
</ul>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update <span class="keyword">table</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;Aron&#x27;</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125; <span class="keyword">and</span> version <span class="operator">=</span> #&#123;version&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>乐观锁的另一种技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p><code>CAS</code>操作中包含三个操作数 :</p>
<ul>
<li>需要读写的内存位置<code>V</code></li>
<li>进行比较的预期原值<code>A</code></li>
<li>拟写入的新值<code>B</code></li>
</ul>
<p>如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值）。CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 ”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p>
<p>简单来说就是：CAS原理就是对v对象进行赋值时，先判断原来的值是否为A，如果为A，就把新值B赋值到V对象上面，如果原来的值不是A（代表V的值放生了变化），就不赋新值。</p>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>由于java的CAS同时具有 <code>volatile</code>读和<code>volatile</code>写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p>
<ul>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ul>
<p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。</p>
<p>仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ul>
<li>首先，声明共享变量为<code>volatile</code>；　　</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>ABA问题</li>
</ul>
<p><code>CAS</code>算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。比如说一个线程<code>one</code>从内存位置V中取出<code>A</code>，这时候另一个线程<code>two</code>也从内存中取出<code>A</code>，并且<code>two</code>进行了一些操作变成了<code>B</code>，然后<code>two</code>又将V位置的数据变成<code>A</code>，这时候线程<code>one</code>进行<code>CAS</code>操作发现内存中仍然是<code>A</code>，然后<code>one</code>操作成功。尽管线程<code>one</code>的<code>CAS</code>操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。因此前面提到的原子操作AtomicStampedReference/AtomicMarkaBleReference就很有用了。这允许一对变化的元素进行原子操作。</p>
<ul>
<li>循环时间长开销大</li>
</ul>
<p>自旋<code>CAS</code>（不成功，就一直循环执行，直到成功）如果长时间不成功，会给<code>CPU</code>带来非常大的执行开销。如果<code>JVM</code>能支持处理器提供的<code>pause</code>指令那么效率会有一定的提升，<code>pause</code>指令有两个作用，第一它可以延迟流水线执行指令（<code>de-pipeline</code>）,使<code>CPU</code>不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（<code>memory order violation</code>）而引起<code>CPU</code>流水线被清空（<code>CPU pipeline flush</code>），从而提高<code>CPU</code>的执行效率。</p>
<ul>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<p>当对一个共享变量执行操作时，我们可以使用循环<code>CAS</code>的方式来保证原子操作，但是对多个共享变量操作时，循环<code>CAS</code>就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量<code>i ＝ 2,j = a</code>，合并一下<code>ij = 2a</code>，然后用<code>CAS</code>来操作<code>ij</code>。从Java 1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行<code>CAS</code>操作。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>二者选择</strong></p>
<ul>
<li><p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。高并发环境下锁粒度把控是一门重要的学问，选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。</p>
</li>
<li><p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p>
</li>
</ul>
<p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>
<p><strong>悲观锁适合写多读少的场景</strong>。因为在使用的时候该线程会独占这个资源，在本文的例子来说就是某个id的文章，如果有大量的评论操作的时候，就适合用悲观锁，否则用户只是浏览文章而没什么评论的话，用悲观锁就会经常加锁，增加了加锁解锁的资源消耗。</p>
<p><strong>乐观锁适合写少读多的场景</strong>。由于乐观锁在发生冲突的时候会回滚或者重试，如果写的请求量很大的话，就经常发生冲突，经常的回滚和重试，这样对系统资源消耗也是非常大。</p>
<p>所以悲观锁和乐观锁没有绝对的好坏，必须结合具体的业务情况来决定使用哪一种方式。另外在阿里巴巴开发手册里也有提到：</p>
<blockquote>
<p>如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。</p>
</blockquote>
<p>阿里巴巴建议以冲突概率20%这个数值作为分界线来决定使用乐观锁和悲观锁，虽然说这个数值不是绝对的，但是作为阿里巴巴各个大佬总结出来的也是一个很好的参考。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.hollischuang.com/archives/934">https://www.hollischuang.com/archives/934</a></p>
<p><a href="https://blog.csdn.net/hongchangfirst/article/details/26004335">https://blog.csdn.net/hongchangfirst/article/details/26004335</a></p>
<p><a href="https://segmentfault.com/a/1190000016611415#articleHeader0">https://segmentfault.com/a/1190000016611415#articleHeader0</a></p>
<p><a href="https://www.cnblogs.com/549294286/p/3766717.html">https://www.cnblogs.com/549294286/p/3766717.html</a></p>
<p><a href="https://zzzzbw.cn/article/18#%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">https://zzzzbw.cn/article/18#%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98</a></p>
]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Maven</title>
    <url>/2019/05/12/%E5%88%9D%E8%AF%86Maven/</url>
    <content><![CDATA[<blockquote>
<p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。<br>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p>
</blockquote>
<h1 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h1><p>首先去<a href="http://maven.apache.org/">官网</a>下载对应的版本.</p>
<p>然后设置环境变量</p>
<p>先定义Maven的路径:<br><img src="%E5%88%9D%E8%AF%86Maven/1.png" alt="设置环境变量1"></p>
<p>在path中添加环境变量<br><img src="%E5%88%9D%E8%AF%86Maven/2.png" alt="设置环境变量2"></p>
<p>检验是否添加成功:<br><img src="%E5%88%9D%E8%AF%86Maven/3.png" alt="检验环境变量"></p>
<h1 id="使用Maven"><a href="#使用Maven" class="headerlink" title="使用Maven"></a>使用Maven</h1><h2 id="Maven-目录结构"><a href="#Maven-目录结构" class="headerlink" title="Maven 目录结构"></a>Maven 目录结构</h2><p>Maven定义了一个标准的目录结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">  - main</span><br><span class="line">    - java</span><br><span class="line">    - resources</span><br><span class="line">    - webapp</span><br><span class="line">  - test</span><br><span class="line">    - java</span><br><span class="line">    - resources</span><br><span class="line"></span><br><span class="line">- target</span><br></pre></td></tr></table></figure>

<p>并不是所有的maven都要使用上面的目录,上面的目录中有一些事可选的.一个最简单的目录应该是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">  - main</span><br><span class="line">    - java</span><br><span class="line">  - test</span><br><span class="line">    - java</span><br></pre></td></tr></table></figure>

<p>下面以构建一个简单的maven项目为例,我构建的一个名为<code>maven01</code>的项目目录结构如下:<br><img src="%E5%88%9D%E8%AF%86Maven/4.png" alt="Maven目录结构"></p>
<p>然后创建两个类,两个类代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.homxuwang.maven01.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.homxuwang.maven01.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Assert.assertEquals(<span class="string">&quot;Hello World!&quot;</span>,<span class="keyword">new</span> HelloWorld().sayHello());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并根据其<code>package</code>创建对应目录:<br><img src="%E5%88%9D%E8%AF%86Maven/5.png" alt="Maven目录结构2"></p>
<p><img src="%E5%88%9D%E8%AF%86Maven/6.png" alt="Maven目录结构3"></p>
<p><img src="%E5%88%9D%E8%AF%86Maven/7.png" alt="Maven目录结构4"></p>
<h2 id="编写pom-xml文件"><a href="#编写pom-xml文件" class="headerlink" title="编写pom.xml文件"></a>编写pom.xml文件</h2><p>为<code>maven01</code>项目编写pom.xml文件,pom.xml文件<strong>与src文件夹同级</strong>.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- groupId是项目的包名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.homxuwang.maven01<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 模块名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven01-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 项目的依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这便是最基本的pom.xml文件.<br><code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code>是固定的.<br><code>&lt;groupId&gt;&lt;/groupId&gt;</code>是项目的包名.<br><code>&lt;artifactId&gt;&lt;/artifactId&gt;</code>为模块名.<br><code>&lt;version&gt;&lt;/version&gt;</code>则是定义发布的版本.<br><code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>中存放相关的依赖包,因为上面的例子中使用了junit依赖,所以这里进行相关设置,junit的版本为4.10.</p>
<p>可以根据上面的例子查看.</p>
<h2 id="使用mvn命令进行编译等操作"><a href="#使用mvn命令进行编译等操作" class="headerlink" title="使用mvn命令进行编译等操作"></a>使用mvn命令进行编译等操作</h2><p>进入到项目目录(我的为maven01),输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure>
<p>进行编译,第一次编译时要下载相应依赖,所以有可能会很慢:</p>
<p><img src="%E5%88%9D%E8%AF%86Maven/8.png" alt="Maven编译"></p>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>
<p>进行测试.</p>
<p><img src="%E5%88%9D%E8%AF%86Maven/9.png" alt="Maven测试"><br><img src="%E5%88%9D%E8%AF%86Maven/10.png" alt="Maven测试1"></p>
<p>可以看到测试结果中,Tests run:1,即成功执行了一个测试.</p>
<p>在src目录下,生成了一个<code>target</code>文件夹,<br><img src="%E5%88%9D%E8%AF%86Maven/11.png" alt="Maven测试"></p>
<p>target文件夹内容如下:<br><code>classes</code>文件夹内就是编译后生成的字节码文件.<br><code>surefire-reports</code>是相应的测试报告.<br><img src="%E5%88%9D%E8%AF%86Maven/12.png" alt="target"></p>
<p>接着使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>
<p>对程序进行打包</p>
<p><img src="%E5%88%9D%E8%AF%86Maven/13.png" alt="生成jar包"></p>
<p>可以看到target文件夹下生成了一个jar包,其文件名就是在pom.xml中定义的 <code>&lt;artifactId&gt;maven01-model&lt;/artifactId&gt;</code>+<code>&lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt;</code>的组合.</p>
<p>这便是maven最基本的操作</p>
<h1 id="maven拓展学习"><a href="#maven拓展学习" class="headerlink" title="maven拓展学习"></a>maven拓展学习</h1><h2 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h2><ul>
<li>mvn -v 查看版本</li>
<li>mvn compile 编译</li>
<li>mvn test 测试</li>
<li>mvn package 打包</li>
<li>mvn clean 删除target文件夹</li>
<li>mvn install 安装jar包到本地仓库中<br>如,再别的项目中如果想要使用maven01的话,那么就得先将maven01安装到本地仓库.然后再新项目的<code>dependencies</code>标签中添加maven01的相关信息.如:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 项目的依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.homxuwang.maven01<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven01-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
其实在加载依赖时,maven首先会扫描本地仓库是否有符合的依赖,如果有则加载,如果没有会到网上的maven中央仓库中进行下载,并放到本地仓库中以供使用.</li>
</ul>
<h2 id="使用archetype插件自动建立目录骨架"><a href="#使用archetype插件自动建立目录骨架" class="headerlink" title="使用archetype插件自动建立目录骨架"></a>使用archetype插件自动建立目录骨架</h2><p>在最开始的例子中,我们要手动创建相应的符合maven开发的目录.而使用archetype插件可以自动生成一个符合maven开发的目录结构.<br>maven规定主代码的目录为:<code>src</code>:<code>main</code>:<code>java</code>:<code>主代码</code><br>测试目录为:<code>src</code>:<code>test</code>:<code>测试代码</code></p>
<p>在相应的项目目录下使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate</span><br></pre></td></tr></table></figure>
<p>然后按照提示进行选择,之后会自动创建对应目录.</p>
<p>第一次使用时会下载一些文件,可能时间会较长.</p>
<p>当然也可以一次性输入命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=[groupId] -DartifactId=[artifactId] -Dversion=[version] -Dpackage=[代码所在的包名]</span><br></pre></td></tr></table></figure>

<h2 id="maven中的坐标和仓库"><a href="#maven中的坐标和仓库" class="headerlink" title="maven中的坐标和仓库"></a>maven中的坐标和仓库</h2><p>maven中的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以组成项目的一个基本坐标,任何的构建使用这个坐标进行<strong>唯一标识</strong><br>一般<code>groupId</code>标签使用[公司网址的反写.项目名]<br><code>artifactId</code>使用[项目名-模块名]<br><code>version</code>则是对应的版本号</p>
<p>而很多的构件都是存放在仓库中的.仓库分为本地仓库和远程仓库.<br>首先maven会在本地仓库找相应的构件,如果找不到则会到远程仓库进行寻找.如果在找不到则会报错.</p>
<p>默认的全球中央仓库的地址是<a href="https://repo.maven.apache.org/maven2">https://repo.maven.apache.org/maven2</a><br>这里包含了大多数的开源项目.</p>
<p>可以在<a href="https://search.maven.org/">https://search.maven.org/</a><br>搜索相应的包.</p>
<p>当然国内也有很多镜像仓库.<br>通过修改<code>[你的maven目录]\conf\settings.xml</code>文件,找到<code>mirrors</code>标签,进行相关镜像仓库的设置。其中给出了设置镜像仓库的格式:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>mirrorId<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>repositoryId<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://my.repository.com/repo/path<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>国内的两个常用的Maven仓库地址:</p>
<ul>
<li>开源中国<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-osc<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus osc<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>阿里<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>更改仓库的位置:<br>maven从远程仓库下载的构件,默认存放在<code>C:\Users\[用户名]\.m2\repository</code>中</p>
<p>更改本地仓库的默认路径,依然要修改<code>[你的maven目录]\conf\settings.xml</code>文件,找到<code>localRepository</code>标签进行修改,注意目录间要使用<code>/</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/path/to/local/repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以将<code>settings.xml</code>文件复制一份到新的仓库文件夹中,这样如果以后修改maven版本就不用再修改settings文件了.</p>
<h2 id="maven的生命周期"><a href="#maven的生命周期" class="headerlink" title="maven的生命周期"></a>maven的生命周期</h2><p>完整的项目构建过程包括:<br><code>清理</code>-&gt;<code>编译</code>-&gt;<code>测试</code>-&gt;<code>打包</code>-&gt;<code>集成测试</code>-&gt;<code>验证</code>-&gt;<code>部署</code></p>
<p>maven的三套生命周期:</p>
<ul>
<li>clean 清理项目</li>
<li>default 构建项目</li>
<li>site 生成项目站点</li>
</ul>
<p>三套生命周期之间的关系：<br>较之于生命周期阶段的前后依赖关系，三套生命周期本身是相互独立的，用户可以仅仅调用clean生命周期的某个阶段，或者仅仅调用default生命周期的某个阶段，而不会对其他生命周期产生任何影响。例如，当用户调用clean生命周期的clean阶段的时候，不会触发default生命周期的任何阶段，反之亦然，当用户调用default生命周期的compile阶段的时候，也不会触发clean生命周期的任何阶段。而当我们执行package时，会自动执行compile和test.</p>
<ul>
<li><p><strong>clean生命周期</strong></p>
<p>clean生命周期的目的是清理项目，它包含三个阶段：</p>
<ul>
<li>pre-clean执行一些清理前需要完成的工作。</li>
<li>clean清理上一次构建生成的文件。</li>
<li>post-clean执行一些清理后需要完成的工作。</li>
</ul>
</li>
<li><p><strong>default生命周期(核心)</strong><br>default 生命周期定义了真正构建时所需要执行的所有步骤，它是所有生命周期中最核心的部分，常用的几个阶段有<code>compile</code>,<code>test</code>,<code>package</code>,<code>install</code>.其包含的阶段如下，这里只对重要的阶段进行解释：</p>
<ul>
<li>validate</li>
<li>initialize</li>
<li>generate-sources</li>
<li>process-sources处理项目主资源文件。一般来说，是对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。</li>
<li>generate-resources</li>
<li>process-resources<br>compile编译项目的主源码。一般来说，是编译src/main/java目录下的Java文件至项目输出的主classpath目录中。</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources处理项目测试资源文件。一般来说，是对src/test/resources目录的内容进行变量替换等工作后，复制到项目输出的测试classpath目录中。</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile编译项目的测试代码。一般来说，是编译src/test/java目录下的Java文件至项目输出的测试classpath目录中。</li>
<li>process-test-classes<br>test使用单元测试框架运行测试，测试代码不会被打包或部署。</li>
<li>prepare-package<br>package接受编译好的代码，打包成可发布的格式，如JAR。</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install将包安装到Maven本地仓库，供本地其他Maven项目使用。</li>
<li>deploy将最终的包复制到远程仓库，供其他开发人员和Maven项目使用。</li>
</ul>
</li>
<li><p><strong>site生命周期</strong><br>site生命周期的目的是建立和发布项目站点，Maven能够基于POM所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。该生命周期包含如下阶段：</p>
<ul>
<li>pre-site执行一些在生成项目站点之前需要完成的工作。</li>
<li>site生成项目站点文档。</li>
<li>post-site执行一些在生成项目站点之后需要完成的工作。</li>
<li>site-deploy将生成的项目站点发布到服务器上。</li>
</ul>
</li>
</ul>
<h2 id="maven的插件"><a href="#maven的插件" class="headerlink" title="maven的插件"></a>maven的插件</h2><p><a href="http://maven.apache.org/plugins">http://maven.apache.org/plugins</a> 可以查看maven提供的插件<br>以使用source插件为例.这个插件可以将项目源码进行打包.</p>
<p>在pom.xml中绑定插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- groupId artifactId version 是maven的坐标 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绑定source到default生命周期的package阶段 </span></span><br><span class="line"><span class="comment">             这样在执行package命令时就可以将源码进行打包</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定阶段 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注</strong>：<br>指定source的目标(即)<code>&lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt;</code>时,可在 <a href="http://maven.apache.org/plugins/maven-source-plugin/">http://maven.apache.org/plugins/maven-source-plugin/</a> 进行查看</li>
</ul>
<h2 id="pom-xml解析"><a href="#pom-xml解析" class="headerlink" title="pom.xml解析"></a>pom.xml解析</h2><p><code>project</code>为根标签,不用多说<br><code>modelVersion</code>指定了当前pom的版本</p>
<ul>
<li><p>坐标信息<br>基本坐标信息由<code>groupId</code> <code>artifactId</code> <code>version</code> <code>packaging</code>构成</p>
<ul>
<li><code>groupId</code>标签定义当前的Maven属于哪个实际的项目。maven项目和实际的项目不是一一对应关系,maven项目提现的是模块化概念,因此一个实际项目往往被划分为很多的模块.</li>
<li><code>artifactId</code>标签表示模块的标识,表示实际项目中的一个模块.一般用[项目名+模块名]进行标识</li>
<li><code>version</code>标签标识版本号.第一个0表示大版本号,第二个0表示分支版本号,第三个0表示小版本号.<code>snapshot-快照</code>,<code>alpha-内部测试</code>,<code>beta-公测</code>,<code>Release-稳定</code>,<code>GA-正式发布</code></li>
<li><code>packaging</code>标签表示maven项目的打包方式.默认为<code>jar</code>,也可以指定为<code>war</code>,<code>zip</code>,<code>pom</code>等</li>
</ul>
<p>其他的一些描述信息:</p>
<ul>
<li><code>name</code>标签表示项目描述名</li>
<li><code>url</code>标签表示项目地址</li>
<li><code>description</code>标签表示项目的描述信息</li>
<li><code>developers</code>标签表示开发人员列表</li>
<li><code>licenses</code>标签表示许可信息</li>
<li><code>organization</code>标签表示组织信息</li>
</ul>
</li>
<li><p>依赖列表dependencies<br>依赖列表放在<code>dependencies</code>标签中，其下可以包含多个依赖项<code>dependency</code>.依赖项里面如何确定一个依赖所在的位置呢？其实也是使用坐标,即<code>groupId</code> <code>artifactId</code> <code>version</code>这三个在上面的坐标信息中有介绍,还可以有:</p>
<ul>
<li><code>type</code>标签</li>
<li><code>scope</code>标签表示<strong>依赖范围</strong>.比如junit依赖,<code>scope</code>标签其中填写test，表示junit只在test的依赖范围内有用.</li>
<li><code>optional</code>标签表示设置以来是否可选,有两个值true,false,默认是false.如果为false则子项默认是继承的,否则要显示引入该依赖</li>
<li><code>exclusions</code>标签表示排除依赖传递列表。其子标签为<code>exclusion</code>表示不需要使用到的依赖.</li>
</ul>
</li>
<li><p>依赖管理dependencyManagement<br>依赖管理放在<code>dependencyManagement</code>标签中.其中也可以声明依赖列表,包含多个依赖,但她不会被引用到依赖中，不会实际运行.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>为构建行为提供支持build<br>在上面介绍过build,为构建项目提供一些支持.其根标签为<code>build</code>,常用的一个字标签为<code>plugins</code>即插件列表,在其下定义<code>plugin</code>,<code>plugin</code>依然要提供插件的坐标.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>继承父模块parent<br>parent通常表示在子模块中对父模块pom的继承</p>
</li>
<li><p>对多个模块进行编译modules<br>可以在<code>modules</code>下指定多个模块<code>module</code>.</p>
</li>
</ul>
<h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>在上一节中简单介绍了<code>scope</code>标签的一些内容.<br>在开发时,如果要用到某个jar包,就要将其引入到项目的classpath构件中,这样项目就能用该框架.maven中提供了三种classpath:编译、测试、运行.所以这里的依赖范围就是用来控制依赖与三种classpath的关系的.<br>主要有6个Dependency Scope</p>
<ul>
<li>compile</li>
<li>provided</li>
<li>runtime</li>
<li>test</li>
<li>system</li>
<li>import</li>
</ul>
<p>在<a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope">这里</a>查看提供的scope值,并有具体描述.</p>
<h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><p>比如C依赖B,而B依赖A.<br>在A打包并install到本地仓库后(保证B添加依赖后能正确编译),在B中添加对A的依赖,即在B的pom.xml中添加依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对B进行编译和打包(使得C可以添加对B的依赖,否则会报错).</p>
<p>然后让C依赖于B,即在C的pom.xml中添加依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后对C进行编译,可以编译成功.</p>
<p>在对C编译成功后,C的maven依赖有A和B,虽然在对C进行添加依赖时只添加了B,但是由于依赖的传递性,A也会成为C的依赖.</p>
<ul>
<li>排除依赖<br>如果C想排除A的依赖,要用到<code>exclusions</code>标签,如下:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  <span class="comment">&lt;!-- declare the exclusion here --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A/artifactId&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
这样就可以去除A的依赖了</li>
</ul>
<h2 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h2><p>假设A和B依赖了不同版本的相同构件,对于依赖于A、B的C来说,它究竟依赖A和B的哪一个版本的构件.这里有两个原则：</p>
<ul>
<li><p>短路优先<br>假设<br>A-&gt;B-&gt;C-&gt;X(jar)<br>A-&gt;D-&gt;X(jar)<br>那么A会依赖路径较短的版本</p>
</li>
<li><p>先声明路径优先<br>如果路径长度相同,则谁先声明,先解析谁</p>
</li>
</ul>
<h2 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h2><ul>
<li>聚合<br>在依赖传递中看到,如果要使用A和B，需要分别对A和B打包编译install，有一种方法可以将多个项目进行install,这个方式称为聚合.<br>进行聚合需要新建一个maven项目,这个项目与几个要打包的项目在同一目录(当然也可以不在同一目录,只是在module中要寻找相应的路径).在pom.xml中,将坐标信息的<code>packaging</code>标签修改为<code>pom</code>.可以将这个pom看成一个pom容器.</li>
</ul>
<p>然后使用<code>modules</code>标签中的<code>module</code>找到要打包的多个项目:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.homxuwang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mavenStudy-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../A<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../B<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../C<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后对这个项目进行<code>install</code>时,会构建modules中的三个项目.</p>
<ul>
<li>继承<br>假设A,B,C三个项目都用到了junit依赖,那么它们就有了重复的配置.在maven中可以将共同的特性封装成一个父类，使用<code>dependencyManagement</code>(使用这个标签,它的内容不会在项目中运行).<br>在父类pom.xml文件中,(这里假设新建一个名为Parent的新的maven项目,让ABC三个项目进行继承).</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.homxuwang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mavenStudy-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的pom.xml中使用了<code>&lt;properties&gt;</code>标签,定义了junit的版本,然后在<code>dependency</code>中的<code>version</code>标签使用<code>$&#123;&#125;</code>对其进行引用.</p>
<p>对于父亲pom，它的main目录和test目录是没有作用的,可以删除.</p>
<p>在子类pom.xml中继承父类的pom,以C为例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 使用parent标签,其中写父亲pom的坐标 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父pom的坐标 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.homxuwang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mavenStudy-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到,<code>dependency</code>中junit的版本号(version标签)已经删除了,但是由于它集成了父pom,其中定义了junit的版本,所以是正确的.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.imooc.com/video/8644">https://www.imooc.com/video/8644</a></p>
<p><a href="https://blog.csdn.net/wangdong5678999/article/details/72848044">https://blog.csdn.net/wangdong5678999/article/details/72848044</a></p>
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>事务隔离级别</title>
    <url>/2019/05/16/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>本文大部分转载自<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md">事务隔离级别(图文详解)</a></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h2 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h2><p><img src="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/1.png" alt="事务的特性"></p>
<ul>
<li><strong>原子性</strong>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性</strong>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。、</li>
</ul>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><p><strong>丢失修改(Lost to modify)<strong>：或者称为</strong>更新遗失(Lost Updata)</strong>.指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。基本上就是某个事务对字段进行更新的信息，因为另一个事务的介入而遗失了更新的内容。<br>例如：甲售票点（甲事务）读出某航班的机票余额A,设A=16.<br>乙售票点（乙事务）读出同一航班的机票余额A,也为16.<br>甲售票点卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库.<br>乙售票点也卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库.<br>结果明明卖出两张机票，数据库中机票余额只减少1。乙事务没有读到甲事务修改后的值。</p>
</li>
<li><p><strong>脏读(Dirty Read)</strong>:当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”(即不干净,不正确的数据)，依据“脏数据”所做的操作可能是不正确的。</p>
</li>
<li><p><strong>不可重复读（Unrepeatable Read）</strong>:指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<br>例如，事务A在事务B更新前后进行数据的读取，事务A得到了不同的结果。</p>
</li>
<li><p><strong>幻读（Phantom Read）</strong>:幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。即同一事务期间，读取到的数据笔数不一致。<br>例如，事务A第一次读取得到5笔数据，此时事务B增加了一条数据，导致事务A再次读取得到6笔数据。</p>
</li>
</ul>
<p><strong>不可重复度和幻读区别</strong>：</p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<ul>
<li><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
</li>
<li><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
</li>
</ul>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)<strong>： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。——即对应解决</strong>丢失修改</strong></li>
<li><strong>READ-COMMITTED(读取已提交)<strong>： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。——对应解决</strong>脏读</strong></li>
<li><strong>REPEATABLE-READ(可重复读)<strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。——对应解决</strong>不可重复读</strong>、<strong>脏读</strong></li>
<li><strong>SERIALIZABLE(可串行化)<strong>： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。——对应解决</strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong></li>
</ul>
<p>下表为各个隔离级别可以预防的问题:</p>
<table>
<thead>
<tr>
<th>隔离行为(级别)</th>
<th>丢失修改</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是<strong>REPEATABLE-READ（可重读）</strong>。我们可以通过SELECT @@tx_isolation;命令来查看</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了SQL标准的SERIALIZABLE(可串行化)隔离级别。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在<strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<h1 id="实际情况演示"><a href="#实际情况演示" class="headerlink" title="实际情况演示"></a>实际情况演示</h1><p>在下面我会使用 2 个命令行mysql ，模拟多线程（多事务）对同一份数据的脏读问题。</p>
<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：START TARNSACTION。</p>
<p>我们可以通过下面的命令来设置隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED<span class="operator">|</span>READ COMMITTED<span class="operator">|</span>REPEATABLE READ<span class="operator">|</span>SERIALIZABLE]</span><br></pre></td></tr></table></figure>

<p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>
<ul>
<li><code>START TARNSACTION |BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
</ul>
<h2 id="脏读-读未提交"><a href="#脏读-读未提交" class="headerlink" title="脏读(读未提交)"></a>脏读(读未提交)</h2><p><img src="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/2.png" alt="脏读(读未提交)"></p>
<h2 id="避免脏读-读已提交"><a href="#避免脏读-读已提交" class="headerlink" title="避免脏读(读已提交)"></a>避免脏读(读已提交)</h2><p><img src="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/3.png" alt="避免脏读(读已提交)"></p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>
<p><img src="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/4.png" alt="不可重复读"></p>
<h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p><img src="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/5.png" alt="可重复读"></p>
<h2 id="防止幻读-可重复读"><a href="#防止幻读-可重复读" class="headerlink" title="防止幻读(可重复读)"></a>防止幻读(可重复读)</h2><p><img src="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/6.png" alt="防止幻读(可重复读)"><br>一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?</p>
<p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md</a></p>
</li>
<li><p>《JAVA JDK8 学习笔记》——林信良 著</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下开启和使用mysql的binlog</title>
    <url>/2019/05/09/windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/</url>
    <content><![CDATA[<p>Mysql Binlog是二进制格式的日志文件。Binlog是用来记录Mysql内部对数据库的改动（只记录对数据的修改操作），主要用于数据库的主从复制以及增量恢复。</p>
<p>binlog作用<br>MySQL的作用类似于Oracle的归档日志，可以用来查看数据库的变更历史（具体的时间点所有的SQL操作）、数据库增量备份和恢复（增量备份和基于时间点的恢复）、Mysql的复制（主主数据库的复制、主从数据库的复制）。</p>
<h1 id="开启binlog"><a href="#开启binlog" class="headerlink" title="开启binlog"></a>开启binlog</h1><p>首先找到<code>my.ini</code>文件.<br><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/1.png" alt="文件目录"></p>
<p>在<code># Binary Logging</code>部分添加以下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog-format=Row</span><br></pre></td></tr></table></figure>
<p>如下图所示:<br><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/2.png" alt="修改my.ini"></p>
<p>修改并保存,然后重启mysql服务:<br><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/3.png" alt="重启mysql服务"></p>
<p>查看是否已经开始binlog,分别使用命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_bin&#x27;; </span><br><span class="line">show binary logs;</span><br></pre></td></tr></table></figure>
<p><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/4.png" alt="查看是否开启binlog"></p>
<p>binlog文件的默认目录(相对于my.ini)为<code>./Data</code>:<br><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/5.png" alt="binlog文件的默认目录"></p>
<p>可以在配置中使用<code>log-bin=路径名</code>改变binlog的位置,如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-bin=D:\logbin</span><br></pre></td></tr></table></figure>

<h1 id="logbin的使用"><a href="#logbin的使用" class="headerlink" title="logbin的使用"></a>logbin的使用</h1><p>首先创建测试数据库:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database logbintest;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>切换数据库:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use logbintest;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

<p>创建表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span>,name <span class="type">varchar</span>(<span class="number">20</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p>插入数据:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;hm&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>执行<code>flush logs;</code>命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> flush logs;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>这时目录下多了一个log-bin文件:<br><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/6.png" alt="备份文件"></p>
<p>可以使用<code>show master status</code>查看当前数据库binary log的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000002 |      154 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>继续输入sql命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>再次执行<code>flush logs;</code>命令和<code>show master status</code>命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> flush logs;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File             <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000003</span> <span class="operator">|</span>      <span class="number">154</span> <span class="operator">|</span>              <span class="operator">|</span>                  <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>接着输入sql命令:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;hey&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">table</span> t1;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">drop</span> database logbintest;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>经过以上操作后,文件夹中有了3个binlog文件,<code>*.index</code>是索引文件.</p>
<p><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/7.png" alt="备份文件"></p>
<p>可以用mysqlbinlog 工具来恢复数据。为了下面讲解的方便，我们先将binlog文件解析成txt文件，在mysql-bin文件目录下执行命令,如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\MySQL\MySQL Server 5.7\Data&gt;mysqlbinlog mysql-bin.000001 &gt; D:/1.txt</span><br><span class="line"></span><br><span class="line">C:\ProgramData\MySQL\MySQL Server 5.7\Data&gt;mysqlbinlog mysql-bin.000002 &gt; D:/2.txt</span><br><span class="line"></span><br><span class="line">C:\ProgramData\MySQL\MySQL Server 5.7\Data&gt;mysqlbinlog mysql-bin.000003 &gt; D:/3.txt</span><br></pre></td></tr></table></figure>
<p>通过这三个命令，可以在D盘下生成3个文件，里面分别记录了日志文件的内容，也就是用户操作的步骤。<br><img src="windows%E4%B8%8B%E5%BC%80%E5%90%AF%E5%92%8C%E4%BD%BF%E7%94%A8mysql%E7%9A%84binlog/8.png" alt="txt文件"></p>
<p>三个文件内容见附录。</p>
<p>下面开始恢复binlog日志到Mysql数据库，这里只将第1个日志文件恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\MySQL\MySQL Server 5.7\Data&gt;mysqlbinlog mysql-bin.000001 | mysql -u[数据库用户名] -p[数据库密码]</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br></pre></td></tr></table></figure>

<p>然后查看是否恢复成功:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> logbintest         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use logbintest;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_logbintest <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> t1                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> hm   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> xx   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>这时候恢复到相应的备份位置了.</p>
<p>接着恢复第三个备份:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\MySQL\MySQL Server 5.7\Data&gt;mysqlbinlog mysql-bin.000003 | mysql -u[用户名] -p[密码]</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br></pre></td></tr></table></figure>
<p>查看数据:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> hm    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> xx    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> test  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> hello <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:<br>直接恢复<code>mysql-bin.000002</code>会提示<code>Table &#39;logbintest.t1&#39; doesn&#39;t exist</code>.我猜想因为<code>mysql-bin.000002</code>文件中不包含创建数据库和表的命令,所以只能在恢复<code>mysql-bin.000001</code>,即恢复了相应数据库和表格的情况下,才能继续恢复数据.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\MySQL\MySQL Server 5.7\Data&gt;mysqlbinlog mysql-bin.000002 | mysql -u[用户名] -p[密码]</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1146 (42S02) at line 35: Table &#x27;logbintest.t1&#x27; doesn&#x27;t exist</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baike.baidu.com/item/Mysql%20Binlog">https://baike.baidu.com/item/Mysql%20Binlog</a></p>
<p><a href="https://www.cnblogs.com/wangwust/p/6433453.html">https://www.cnblogs.com/wangwust/p/6433453.html</a></p>
<p><a href="https://blog.csdn.net/king_kgh/article/details/74890381">https://blog.csdn.net/king_kgh/article/details/74890381</a></p>
<p><a href="https://www.iteblog.com/mysql-binlog_basic_usage/">https://www.iteblog.com/mysql-binlog_basic_usage/</a></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>1.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure>

<p>2.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line"># at 4</span><br><span class="line">#190509 16:40:28 server id 1  end_log_pos 123 CRC32 0xd5ca9838 	Start: binlog v 4, server v 5.7.17-log created 190509 16:40:28</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">fOfTXA8BAAAAdwAAAHsAAAAAAAQANS43LjE3LWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">ATiYytU=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 123</span><br><span class="line">#190509 16:40:28 server id 1  end_log_pos 154 CRC32 0xcbc8683a 	Previous-GTIDs</span><br><span class="line"># [empty]</span><br><span class="line"># at 154</span><br><span class="line">#190509 16:48:03 server id 1  end_log_pos 219 CRC32 0x66c5aab9 	Anonymous_GTID	last_committed=0	sequence_number=1</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 219</span><br><span class="line">#190509 16:48:03 server id 1  end_log_pos 297 CRC32 0x7c1a0b04 	Query	thread_id=3	exec_time=0	error_code=0</span><br><span class="line">SET TIMESTAMP=1557391683/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=3/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1344274432/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C gbk *//*!*/;</span><br><span class="line">SET @@session.character_set_client=28,@@session.collation_connection=28,@@session.collation_server=33/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 297</span><br><span class="line">#190509 16:48:03 server id 1  end_log_pos 351 CRC32 0x6c102375 	Table_map: `logbintest`.`t1` mapped to number 328</span><br><span class="line"># at 351</span><br><span class="line">#190509 16:48:03 server id 1  end_log_pos 396 CRC32 0xec3029be 	Write_rows: table id 328 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">Q+nTXBMBAAAANgAAAF8BAAAAAEgBAAAAAAEACmxvZ2JpbnRlc3QAAnQxAAIDDwI8AAN1IxBs</span><br><span class="line">Q+nTXB4BAAAALQAAAIwBAAAAAEgBAAAAAAEAAgAC//wDAAAABHRlc3S+KTDs</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 396</span><br><span class="line">#190509 16:48:03 server id 1  end_log_pos 427 CRC32 0x57760240 	Xid = 16</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 427</span><br><span class="line">#190509 16:48:19 server id 1  end_log_pos 492 CRC32 0x985b3888 	Anonymous_GTID	last_committed=1	sequence_number=2</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 492</span><br><span class="line">#190509 16:48:19 server id 1  end_log_pos 570 CRC32 0x602ea4d9 	Query	thread_id=3	exec_time=0	error_code=0</span><br><span class="line">SET TIMESTAMP=1557391699/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 570</span><br><span class="line">#190509 16:48:19 server id 1  end_log_pos 624 CRC32 0x0a30970d 	Table_map: `logbintest`.`t1` mapped to number 328</span><br><span class="line"># at 624</span><br><span class="line">#190509 16:48:19 server id 1  end_log_pos 670 CRC32 0x30f313bc 	Write_rows: table id 328 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">U+nTXBMBAAAANgAAAHACAAAAAEgBAAAAAAEACmxvZ2JpbnRlc3QAAnQxAAIDDwI8AAMNlzAK</span><br><span class="line">U+nTXB4BAAAALgAAAJ4CAAAAAEgBAAAAAAEAAgAC//wEAAAABWhlbGxvvBPzMA==</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 670</span><br><span class="line">#190509 16:48:19 server id 1  end_log_pos 701 CRC32 0xe612b29f 	Xid = 17</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 701</span><br><span class="line">#190509 16:49:37 server id 1  end_log_pos 748 CRC32 0x8503b6e4 	Rotate to mysql-bin.000003  pos: 4</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure>

<p>3.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line"># at 4</span><br><span class="line">#190509 16:49:37 server id 1  end_log_pos 123 CRC32 0x67bdb5fc 	Start: binlog v 4, server v 5.7.17-log created 190509 16:49:37</span><br><span class="line"># Warning: this binlog is either in use or was not closed properly.</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">oenTXA8BAAAAdwAAAHsAAAABAAQANS43LjE3LWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">Afy1vWc=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 123</span><br><span class="line">#190509 16:49:37 server id 1  end_log_pos 154 CRC32 0x0e916e92 	Previous-GTIDs</span><br><span class="line"># [empty]</span><br><span class="line"># at 154</span><br><span class="line">#190509 16:50:51 server id 1  end_log_pos 219 CRC32 0x0fcc180d 	Anonymous_GTID	last_committed=0	sequence_number=1</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 219</span><br><span class="line">#190509 16:50:51 server id 1  end_log_pos 297 CRC32 0xd5da7fee 	Query	thread_id=3	exec_time=0	error_code=0</span><br><span class="line">SET TIMESTAMP=1557391851/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=3/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1344274432/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C gbk *//*!*/;</span><br><span class="line">SET @@session.character_set_client=28,@@session.collation_connection=28,@@session.collation_server=33/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 297</span><br><span class="line">#190509 16:50:51 server id 1  end_log_pos 351 CRC32 0x60f30968 	Table_map: `logbintest`.`t1` mapped to number 328</span><br><span class="line"># at 351</span><br><span class="line">#190509 16:50:51 server id 1  end_log_pos 395 CRC32 0xace24246 	Write_rows: table id 328 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">6+nTXBMBAAAANgAAAF8BAAAAAEgBAAAAAAEACmxvZ2JpbnRlc3QAAnQxAAIDDwI8AANoCfNg</span><br><span class="line">6+nTXB4BAAAALAAAAIsBAAAAAEgBAAAAAAEAAgAC//wFAAAAA2hleUZC4qw=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"># at 395</span><br><span class="line">#190509 16:50:51 server id 1  end_log_pos 426 CRC32 0xae6e3d87 	Xid = 20</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 426</span><br><span class="line">#190509 16:51:36 server id 1  end_log_pos 491 CRC32 0xdb44b864 	Anonymous_GTID	last_committed=1	sequence_number=2</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 491</span><br><span class="line">#190509 16:51:36 server id 1  end_log_pos 618 CRC32 0x6dec15c8 	Query	thread_id=3	exec_time=0	error_code=0</span><br><span class="line">use `logbintest`/*!*/;</span><br><span class="line">SET TIMESTAMP=1557391896/*!*/;</span><br><span class="line">DROP TABLE `t1` /* generated by server */</span><br><span class="line">/*!*/;</span><br><span class="line"># at 618</span><br><span class="line">#190509 16:52:34 server id 1  end_log_pos 683 CRC32 0xe3edccf9 	Anonymous_GTID	last_committed=2	sequence_number=3</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 683</span><br><span class="line">#190509 16:52:34 server id 1  end_log_pos 780 CRC32 0xb8287261 	Query	thread_id=3	exec_time=0	error_code=0</span><br><span class="line">SET TIMESTAMP=1557391954/*!*/;</span><br><span class="line">drop database logbintest</span><br><span class="line">/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>系统开发记录</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2019/03/14/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>哈希表中，每一个元素都和一个索引对应。</p>
<p>比如在leetcode中，的<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">387号问题</a>;</p>
<p>相关解决方案:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i ++)</span><br><span class="line">            freq[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i ++)</span><br><span class="line">            <span class="keyword">if</span>(freq[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的每一个字符对应一个索引。每一个类型转化为索引的函数称为哈希函数（上例中就是`ch - ‘a’）。然后在哈希表上进行相应操作。</p>
<p>在建立哈希表时很难保证每一个“键”通过哈希函数的转换对应不同的“索引”，这样会造成哈希冲突。所以关键在于如何解决哈希冲突。哈希表使用空间换时间，是时间和空间之间的平衡。</p>
<h1 id="设计哈希函数"><a href="#设计哈希函数" class="headerlink" title="设计哈希函数"></a>设计哈希函数</h1><p>哈希函数设计时，“键”通过哈希函数得到的“索引”分布越均匀越好。对于一些特殊的领域，有特殊的哈希函数设计方式。</p>
<p>哈希函数的设计遵循三个原则:</p>
<ul>
<li>一致性：如果a==b,则hash(a) == hash(b)</li>
<li>高效性：计算高效简便</li>
<li>均匀性：哈希值均匀分布</li>
</ul>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul>
<li>整型<br>对于整型，小范围正整数可以直接使用</li>
</ul>
<p>小范围的负整数进行偏移相应的能够转化为索引的函数称为哈希函数。</p>
<p>对于大整数，比如身份证号可以采用取模的方法（比如可以取模后四位、后6位）。但是后6位中，有两位是表示日期的，日期最多是1-31，那么就会产生分布不均匀的情况。所以要根据具体问题具体分析，很难有一个通用的解决方法。</p>
<p>在取模时，模一个素数是一个通常的解决方案。</p>
<ul>
<li>浮点型</li>
</ul>
<p>基本数据类型在计算机中都是32位或者64位的二进制表示，只不过计算机根据一定的法则给解析成了浮点数。在处理时，可以吧浮点数的32位或者64位空间转化为整型进行处理。</p>
<ul>
<li>字符串</li>
</ul>
<p>字符串也可以转为整型进行处理。</p>
<p>比如:<br>166 = 1 * 10^2 + 6 * 10^1 + 6 * 10 ^0<br>code = c * 26^3 + o * 26^2 + d * 26^1 + e * 26^0 (看成26进制的整型)<br>code = c * B^3 + o * B^2 + d * B^1 + e * B^0  (看成B进制的整型)<br>hash(code) = ( c * B^3 + o * B^2 + d * B^1 + e * B^0 ) % M (M为取模时选取的素数)<br>也等价于 hash(code) = ( ( ( ( c * B ) + o ) * B + d ) * B + e ) % M</p>
<p>为了避免整型的溢出，也可以先取模在继续进行下一步：<br>hash(code) = ( ( ( ( c % M) * B + o ) % M * B + d ) % M * B + e ) % M</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i ++)</span><br><span class="line">    hash = (hash * B + s.charAt(i)) % M</span><br></pre></td></tr></table></figure>

<ul>
<li>符合类型</li>
</ul>
<p>优先考虑方法也是转化为整型处理。<br>例如 <code>Date: year,month,day</code></p>
<p>hash(date) = (((date.year % M ) * B + date.month) % M * B) + date.day) % M</p>
<h1 id="java中的hashCode"><a href="#java中的hashCode" class="headerlink" title="java中的hashCode"></a>java中的hashCode</h1><p>java中给我们提供了很多现有的hashCode方法。<br>Object对象有<code>hashCode()</code>方法，调用此方法可以返回这个对象的hash值。<br>java中的<code>hashCode()</code>方法返回的hash值都是整型的，如果有需要，用户可以进一步处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        System.out.println(((Integer)a).hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = -<span class="number">2</span>;</span><br><span class="line">        System.out.println(((Integer)b).hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> c = <span class="number">3.1415926</span>;</span><br><span class="line">        System.out.println(((Double)c).hashCode());</span><br><span class="line"></span><br><span class="line">        String d = <span class="string">&quot;hashCode&quot;</span>;</span><br><span class="line">        System.out.println(d.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">-2</span><br><span class="line">219937201</span><br><span class="line">147696667</span><br></pre></td></tr></table></figure>

<p>如果用户想对于自定义的类也能转换为相对应的哈希函数，则只需在类中覆盖来自于Object父类的hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="keyword">int</span> cls;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">int</span> grade,<span class="keyword">int</span> clas,String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.cls = cls;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> B = <span class="number">31</span>;<span class="comment">//将此类的看成有三个作用域的复合类型，直接把三部分看成三个数字，符合类型看成由这三个部分组成的B进制的数，进制数可以自己定义；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        hash = hash * B + grade;</span><br><span class="line">        hash = hash * B + cls;</span><br><span class="line">        hash = hash * B + name.hashCode();</span><br><span class="line">        <span class="comment">//如果出现整型溢出，计算机会做处理，这样不满足数学上的规范，不过对于计算机仍然是有效的</span></span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="number">100</span>,<span class="number">20</span>,<span class="string">&quot;homxu&quot;</span>);</span><br><span class="line">System.out.println(student.hashCode());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">99557671</span><br></pre></td></tr></table></figure>

<p>当一个类能够获得其hash值之后，便能够使用java提供的对于hash的操作。如<code>java.util.HashSet</code>和<code>java.util.HashMap</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Student&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(student);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Student,Integer&gt; scores = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">scores.put(student,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>当然，如果一个类没有自定义其hashCode方法，那么会使用默认的方法，默认方法是将对象的地址映射成一个整型值。所以，当new出来两个数值相同的对象时，他们的hashCode值也是不同的。</p>
<p>在自定义hashCode方法的时候，如果传过去的值相等，那么可能会产生hash冲突，所以一般还要在重写一个Object的<code>equals()</code>方法。以上面的Student类为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123; <span class="comment">//注意这里的参数是object类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == o)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//如果是同一个引用，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(getClass() != o.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//如果类不同，返回false</span></span><br><span class="line">    Student another = (Student)o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade == another.grade &amp;&amp;</span><br><span class="line">            <span class="keyword">this</span>.cls == another.cls &amp;&amp;</span><br><span class="line">            <span class="keyword">this</span>.name.equals(another.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果产生了hash冲突，即使是一样的hash值，也可以区分两个类对象的不同。</p>
<h1 id="链地址法-Seperate-Chaining"><a href="#链地址法-Seperate-Chaining" class="headerlink" title="链地址法(Seperate Chaining)"></a>链地址法(Seperate Chaining)</h1><p>链地址法是哈希冲突的一种处理方法。<br>由之前的内容可知道，在处理哈希值的存储的时候，其实就是将对应的整数取模后，这个值就对应它在数组中的索引。对于会产生负号的值，则进行取绝对值或者<code>(hashCode(value) &amp; 0x7fffffff) % M</code>(按位与进行取负号，效果和取绝对值一样)。</p>
<p>假设产生了哈希冲突，本来索引为1的位置已经存在了元素v1,后来新元素v2也和v1的索引一致，那么这时候扔把v2放在v1的位置，也就是索引处存放的是一个链表，每个索引位置存的都是一个链表，所以<code>Seperate Chaining</code>也由此得名。<br>当然，每一个位置的本质其实是存放的一个查找表，查找表不一定非要用链表，也可以用平衡树结构来实现这个查找表，所以每个位置也可以是一个查找表的结构。在产生哈希冲突时，找到对应的索引位置，然后插入到所以位置对应的TreeMap就可以了。HashMap本质就是一个TreeMap数组。HashSet就是一个TreeSet数组。</p>
<p>在Java8之前，每一个索引位置对应的就是一个链表。<br>Java8开始，当哈希冲突达到一定的程度时，每个位置从链表转为红黑树(即TreeMap，因为Java8的TreeMap底层实现就是红黑树)。</p>
<h1 id="实现一个哈希表"><a href="#实现一个哈希表" class="headerlink" title="实现一个哈希表"></a>实现一个哈希表</h1><p>实现一个简单的哈希表，包括增删改查等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;K,V&gt;[] hashtable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        <span class="keyword">this</span>.size  = <span class="number">0</span>;</span><br><span class="line">        hashtable = <span class="keyword">new</span> TreeMap[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; i ++)</span><br><span class="line">            hashtable[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;<span class="comment">//将key值转变为当前哈希表中的索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt; map = hashtable[hash(key)]; <span class="comment">//先用map暂存当前的hashtable索引对应的TreeMap</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))<span class="comment">//如果对应的索引处包含了当前的元素</span></span><br><span class="line">            map.put(key,value);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            size ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的删除操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt; map = hashtable[hash(key)];</span><br><span class="line">        V ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            ret = map.remove(key);</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的修改操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt; map = hashtable[hash(key)];</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">&quot;doesn&#x27;t exist!&quot;</span>);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的查询操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashtable[hash(key)].containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashtable[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于这个简单实现的哈希表，其M值是开始已经确定好的。选取合适的M值将对哈希表的性能有很大的影响。</p>
<h1 id="时间复杂度和动态空间处理"><a href="#时间复杂度和动态空间处理" class="headerlink" title="时间复杂度和动态空间处理"></a>时间复杂度和动态空间处理</h1><p>在前面的介绍中，假设哈希表有M个地址，如果向其中放入N个元素，那么每个地址平均有N/M个元素。如果每个地址是链表，那么时间复杂度为O(N/M)。如果每个地址是一个平衡树，那么时间复杂度为O(log(N/M))。</p>
<p>哈希表的目的是为了让时间复杂度为或者接近O(1).如果N趋于无穷大的话，那么对于一个静态的数组，它总会产生哈希冲突。所以一个解决办法就是使用动态存储，使其进行自适应。所以和静态数组一样，固定的地址空间是不合理的，所以需要resize操作。但是哈希表的动态操作又和静态数组不同，哈希表的每个索引位置存放的是一个链表或者一个树，如果是链表，那么它是不存在这个位置被“填满”的概念的。所以这里需要考虑的是，平均每个地址承载的元素多过一定的程度，即进行扩容，可以将容忍度定义为upperTol,当N/M &gt;= upperTol时，进行扩容。同理，平均每个地址承载的元素少过一定程度就进行缩容：N / M &lt; lowerTol.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> upperTol = <span class="number">10</span>; <span class="comment">//定义upperTol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> lowerTol = <span class="number">2</span>;  <span class="comment">//定义lowerTol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initCapacity = <span class="number">7</span>;  <span class="comment">//定义初始的大小</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;K,V&gt;[] hashtable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        <span class="keyword">this</span>.size  = <span class="number">0</span>;</span><br><span class="line">        hashtable = <span class="keyword">new</span> TreeMap[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; i ++)</span><br><span class="line">            hashtable[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;<span class="comment">//将key值转变为当前哈希表中的索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt; map = hashtable[hash(key)]; <span class="comment">//先用map暂存当前的hashtable索引对应的TreeMap</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))<span class="comment">//如果对应的索引处包含了当前的元素</span></span><br><span class="line">            map.put(key,value);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            size ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size &gt;= upperTol * M) <span class="comment">//平均每个地址承载的元素多过一定的程度,即N / M &gt;= upperTol</span></span><br><span class="line">                resize(<span class="number">2</span>*M);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的删除操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt; map = hashtable[hash(key)];</span><br><span class="line">        V ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            ret = map.remove(key);</span><br><span class="line">            size --;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size &lt; lowerTol * M &amp;&amp; M / <span class="number">2</span> &gt;= initCapacity) <span class="comment">//平均每个地址承载的元素少过一定的程度,即N / M &lt;= lowerTol；并且缩容时的空间至少为initCapacity</span></span><br><span class="line">                resize(M / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的修改操作</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的查询操作</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newM)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt;[] newHashTable = <span class="keyword">new</span> TreeMap[newM];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; newM ; i ++)</span><br><span class="line">            newHashTable[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldM = M; <span class="comment">//暂存一下之前的M,在循环时作为循环边界</span></span><br><span class="line">        <span class="keyword">this</span>.M = newM; <span class="comment">// 注意hash(key)是对之前的M进行取模，这里要让M变为newM，对现在的M进行取模</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; oldM ; i++)&#123;</span><br><span class="line">            TreeMap&lt;K,V&gt; map = hashtable[i];</span><br><span class="line">            <span class="keyword">for</span>(K key : map.keySet())</span><br><span class="line">                newHashTable[hash(key)].put(key,map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.hashtable = newHashTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表的复杂度分析"><a href="#哈希表的复杂度分析" class="headerlink" title="哈希表的复杂度分析"></a>哈希表的复杂度分析</h1><p>动态数组的均摊复杂度分析，平均复杂度 O(1)</p>
<p>对于哈希表，元素数从N增加到upperTol * N ，地址空间翻倍。平均复杂度O(1).每个操作在O(lowerTol) ~ O(upperTol) → O(1)。<br>缩容同理</p>
<p>在扩容时有一个问题，对于素数M，如果进行扩容，那么扩容后2*M不是素数。其中一个解决方案是，按照素数表中的数字进行扩容，而不是简单的二倍关系。</p>
<p>当然哈希表的均摊复杂度虽然为O(1)，但是它与平衡树结构相比丢失了数据的顺序性。</p>
<p>这样回顾集合和映射的底层实现，如果想实现有序集合和有序映射，那么底层可使用平衡树；如果实现无序集合和无序映射，则使用哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] capacity= &#123;<span class="number">53</span>, <span class="number">97</span>, <span class="number">193</span>, <span class="number">389</span>, <span class="number">769</span>, <span class="number">1543</span>, <span class="number">3079</span>, <span class="number">6151</span>, <span class="number">12289</span>, <span class="number">24593</span>, <span class="number">49157</span>, <span class="number">98317</span>,<span class="number">196613</span>, <span class="number">393241</span>, <span class="number">786433</span>, <span class="number">1572869</span>, <span class="number">3145739</span>, <span class="number">6291469</span>, <span class="number">12582917</span>, <span class="number">25165843</span>, <span class="number">50331653</span>, <span class="number">100663319</span>, <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>, <span class="number">1610612741</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> upperTol = <span class="number">10</span>; <span class="comment">//定义upperTol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> lowerTol = <span class="number">2</span>;  <span class="comment">//定义lowerTol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacityIndex = <span class="number">0</span>;  <span class="comment">//定义capacity数组初始的索引</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;K,V&gt;[] hashtable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = capacity[capacityIndex];</span><br><span class="line">        size  = <span class="number">0</span>;</span><br><span class="line">        hashtable = <span class="keyword">new</span> TreeMap[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; i ++)</span><br><span class="line">            hashtable[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;<span class="comment">//将key值转变为当前哈希表中的索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt; map = hashtable[hash(key)]; <span class="comment">//先用map暂存当前的hashtable索引对应的TreeMap</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))<span class="comment">//如果对应的索引处包含了当前的元素</span></span><br><span class="line">            map.put(key,value);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            size ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size &gt;= upperTol * M &amp;&amp; capacityIndex + <span class="number">1</span> &lt; capacity.length)&#123; <span class="comment">//平均每个地址承载的元素多过一定的程度,即N / M &gt;= upperTol,并且判断边界不会越界</span></span><br><span class="line">                capacityIndex ++;</span><br><span class="line">                resize(capacity[capacityIndex]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的删除操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        TreeMap&lt;K,V&gt; map = hashtable[hash(key)];</span><br><span class="line">        V ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            ret = map.remove(key);</span><br><span class="line">            size --;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size &lt; lowerTol * M &amp;&amp; capacityIndex - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;<span class="comment">//平均每个地址承载的元素少过一定的程度,即N / M &lt;= lowerTol；并且缩容时不会越界</span></span><br><span class="line">                capacityIndex --;</span><br><span class="line">                resize(capacity[capacityIndex]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的修改操作</span></span><br><span class="line">    <span class="comment">//同原来的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表的查询操作</span></span><br><span class="line">    <span class="comment">//同原来的函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newM)</span></span>&#123;</span><br><span class="line">       <span class="comment">//同原来的函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>上述的代码实现中，HashTable的K值是不要求可比较的(Comparable)，但是在使用TreeMap定义hashtable数组时，TreeMap的K是要求可比较的，所以这是一个小bug。</p>
<p>前面提到<br>在Java8之前，每一个索引位置对应的就是一个链表。<br>Java8开始，当哈希冲突达到一定的程度时，每个位置从链表转为红黑树(即TreeMap，因为Java8的TreeMap底层实现就是红黑树)，当然，这种情况要求HashTable的K值是可比较的，不然它的每个索引仍然对应一个链表。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索树</title>
    <url>/2018/07/18/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>二分搜索树（或者说二叉搜索树）是一种树形结构。</p>
<ul>
<li>二分搜索树是二叉树</li>
<li>二分搜索树的每个节点的值：<br>大于其左子树的所有节点的值<br>小于其右子树的所有节点的值</li>
<li>每一棵子数也是二分搜索树</li>
<li>存储的元素必须有<code>可比性</code>(如果是想存储一个自定义的类型，那么要定义好这个数据类型的两个数据之间时如何比较的)</li>
</ul>
<p><img src="%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/1.jpg" alt="二分搜索树"></p>
<p>新建<code>BST</code>类，因为其节点值之间需要进行比较，所以继承<code>Comparable</code>类</p>
<h1 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//声明节点类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> E e;</span><br><span class="line">    <span class="keyword">public</span> Node left,right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.e = e;</span><br><span class="line">      left = <span class="keyword">null</span>;</span><br><span class="line">      right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root; <span class="comment">//根节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">//记录存储的元素个数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span></span>&#123;</span><br><span class="line">      root = <span class="keyword">null</span>;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取节点数量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> size == <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="向二分搜索树添加元素"><a href="#向二分搜索树添加元素" class="headerlink" title="向二分搜索树添加元素"></a>向二分搜索树添加元素</h1><p>采用递归方式向二分搜索树添加新元素，以下代码放入<code>BST</code>类中。<br>根据二分搜索树的性质，根节点和每个子树的节点的左子树都比当前节点的值小，其右子树比当前节点的值都大。<br>本文中的二分搜索树不包括重复元素。如果要插入的值等于当前根节点的值，则跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向二分搜索树添加新的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">  root = add(root,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回插入新节点后二分搜索树的根</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要比较的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要比较的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新节点的根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        node.left = add(node.left,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.compareTo(node.e) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        node.right = add(node.right,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分搜索树的包含方法contains"><a href="#二分搜索树的包含方法contains" class="headerlink" title="二分搜索树的包含方法contains"></a>二分搜索树的包含方法contains</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看二分搜索树种是否包含元素e,从根节点开始比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要比较的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看以node为根的二分搜索树中是否包含元素e,递归算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(node.left,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//e.compareTo(node.e) &gt; 0</span></span><br><span class="line">        <span class="keyword">return</span> contains(node.right,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分搜索树的前序遍历"><a href="#二分搜索树的前序遍历" class="headerlink" title="二分搜索树的前序遍历"></a>二分搜索树的前序遍历</h1><p>从根节点访问左右子树，自上而下，所以称为前序遍历。</p>
<h2 id="前序遍历的递归实现"><a href="#前序遍历的递归实现" class="headerlink" title="前序遍历的递归实现"></a>前序遍历的递归实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树的前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历以node为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 以node为根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前序遍历的非递归实现"><a href="#前序遍历的非递归实现" class="headerlink" title="前序遍历的非递归实现"></a>前序遍历的非递归实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历的非递归实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分搜索树的中序遍历"><a href="#二分搜索树的中序遍历" class="headerlink" title="二分搜索树的中序遍历"></a>二分搜索树的中序遍历</h1><p>和前序遍历不同的是，中序遍历先访问左子树，再访问根节点，最后访问右子树。因为访问根节点在中间顺序，所以称为中序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树的中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">  inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分搜索树的中序遍历打印出的即是二分搜索树排序后的结果。</p>
<h1 id="二分搜索树的后序遍历"><a href="#二分搜索树的后序遍历" class="headerlink" title="二分搜索树的后序遍历"></a>二分搜索树的后序遍历</h1><p>后序遍历的一个应用:为二分搜索树释放内存时，需要先从叶子节点开始释放，然后释放其父亲节点（JAVA有内存回收机制，不需考虑，但是c c++ 等语言需要考虑）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树的后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分搜索树的层序遍历"><a href="#二分搜索树的层序遍历" class="headerlink" title="二分搜索树的层序遍历"></a>二分搜索树的层序遍历</h1><p>二分搜索树的层序遍历采用队列的思想，首先把根节点入队，然后循环判断队列是否为空，如果不为空，则将队首元素出队，接着将这个元素的左右子树入队，如果为空则不进行入队。循环结束后也就实现了层序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分搜索树的层序遍历,使用队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//这里定义Queue底层采用链表进行实现</span></span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            Node cur = q.remove();       <span class="comment">//队首元素出队</span></span><br><span class="line">            System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)        <span class="comment">//队首元素的左子树</span></span><br><span class="line">                q.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)       <span class="comment">//队首元素的右子树</span></span><br><span class="line">                q.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>广度优先遍历的意义：可以更快找到要查询的元素。</p>
<h1 id="寻找二分搜索树的最大最小值"><a href="#寻找二分搜索树的最大最小值" class="headerlink" title="寻找二分搜索树的最大最小值"></a>寻找二分搜索树的最大最小值</h1><p>其实，寻找二分搜索树的最大最小值可以看成寻找一个链表的最后一个不为空的节点。这里给出递归写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找二分搜索树的最小元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;BST is empty&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找二分搜索树的最大元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;BST is empty&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回以node为根的二分搜索树的最大值所在的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除二分搜索树的最大最小节点"><a href="#删除二分搜索树的最大最小节点" class="headerlink" title="删除二分搜索树的最大最小节点"></a>删除二分搜索树的最大最小节点</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从二分搜索树种删除最小值所在的节点，并返回最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    E min = minimum();         <span class="comment">//先找到最小值是多少</span></span><br><span class="line">    root = removeMin(root);    <span class="comment">//进行删除操作</span></span><br><span class="line">    <span class="keyword">return</span> min;                <span class="comment">//返回最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 以node为根</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node rightNode = node.right; <span class="comment">// 保存一下节点的右子树，即使为空也不违反逻辑</span></span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size --;                     <span class="comment">//维护size</span></span><br><span class="line">        <span class="keyword">return</span> rightNode;            <span class="comment">//返回删除节点后新的二分搜索树的根,也即刚才保存的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从二分搜索树种删除最大值所在的节点，并返回最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    E max = maximum();</span><br><span class="line">    root = removeMax(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删掉以node为根的二分搜索树中的最大节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 以node为根</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.right = removeMin(node.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除二分搜索树的任意节点"><a href="#删除二分搜索树的任意节点" class="headerlink" title="删除二分搜索树的任意节点"></a>删除二分搜索树的任意节点</h1><ul>
<li>删除只有左子树或只有右子树的节点，即将其左子树或其右子树代替当前的节点位置即可</li>
<li>删除叶子节点可以将其看做只有左子树或只有右子树的节点，只是其左子树和右子树为空</li>
<li>删除一个既有左子树又有右子树的节点，是删除任意节点的难点。使用Hibbard Deletion方法：1) 找到d待删除节点<code>d</code>的右子树中最小的节点<code>s = min(d-&gt;right)</code>,这个节点就是与<code>d</code>节点值相差最小的节点 2) 找到这个节点后，在<code>d</code>的右子树中删除这个节点,并让这个节点的右子树指向原来<code>d</code>节点的右子树，<code>s-&gt;right = removeMin(d-&gt;right)</code> 3) 让<code>s</code>节点的左子树等于<code>d</code>节点原来的左子树<code>s-&gt;left = d-&gt;left</code>,这时候<code>s</code>节点的左右子树就是<code>d</code>节点删除<code>s</code>节点后的左右子树了 4) 删除<code>d</code>,<code>s</code>称为新的子树的根，让其上一级的根指向此节点即可</li>
<li>或者与上述方法相同，只是在找替代节点时找<code>d</code>节点的左子树中最大值的节点作为<code>s</code>,其也符合逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除二分搜索树的任意元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要删除的元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    root = remove(root,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除函数的递归调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前传入的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要删除的元素的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除后的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        node.left = remove(node.left,e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.compareTo(node.e) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        node.right = remove(node.right,e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//e.compareTo(node.e) == 0</span></span><br><span class="line">        <span class="comment">//待删除节点左子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除节点右子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除节点的左右子树均不为空的情况</span></span><br><span class="line">        <span class="comment">//首先找到比待删除节点大的最小节点，即待删除节点右子树的最小节点</span></span><br><span class="line">        <span class="comment">//用这个节点代替删除节点的位置</span></span><br><span class="line">        Node cur = minimum(node.right);</span><br><span class="line">        cur.right = removeMin(node.right);</span><br><span class="line">        cur.left = node.left;</span><br><span class="line"></span><br><span class="line">        node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/2.png" alt="二分搜索树的删除过程"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图的遍历</title>
    <url>/2019/04/01/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>对于图的遍历，和树一样，也有深度优先遍历和广度优先遍历。<br>对于图的深度优先遍历，是从一个点开始，不停的往下试探，知道不能继续为止。但是与树不同的是，图有可能会存在环，所以要记录一下某个点是否已经被遍历过，如果已经被遍历过，则下面的遍历就不需要继续走这个点了。</p>
<p>以下面的数据为例:<br><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/1.png" alt="图"></p>
<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><p>假设从0开始遍历，看与0相连的第一个节点1，节点1没有遍历过所以遍历了1，此时为<code>0 1</code>；<br>接着看和节点1相邻的节点，只有节点0，节点0已经被遍历过了，不用管，此时1没有其他相邻节点了，此时这条路就算走完了，则退回到节点0；<br>然后看0的下一个没有被遍历的节点为节点2,节点2没有被遍历过，所以将2遍历，此时为<code>0 1 2</code>；<br>接着看和节点2相邻的节点，只有节点0，节点0已经被遍历过，退回到节点0；<br>接着看下一个和0相邻的节点，为节点5，没有被遍历过，所以对节点5进行遍历，此时遍历的元素为<code>0 1 2 5</code>；<br>接着看和节点5相邻的节点，第一个节点为节点0，已经被遍历过；第二个节点为节点3，没有被遍历过，所以进行遍历，此时遍历的元素为<code>0 1 2 5 3</code>；<br>接着看和节点3相邻的节点，第一个为节点4，没有被遍历过，所以进行遍历，此时遍历元素为<code>0 1 2 5 3 4</code>；<br>然后看和节点4相邻的节点，节点3和节点5已经被遍历过了，不进行遍历；节点6没有被遍历过，所以进行遍历，此时遍历的元素为<code>0 1 2 5 3 4 6</code>；<br>然后来到节点6，和节点6相邻的节点0和节点4已经被遍历过了，所以不进行遍历；<br>然后退回到节点4，节点4从节点6退回来之后，没有其他节点，节点4的这条路遍历完了，所以从节点4退回到节点3；对于节点3来说，刚才将节点4遍历了，下一个节点5也已经遍历了，节点3这条路遍历完了；所以又从节点3退回到节点5，对于节点5的下一个节点——节点4也已经遍历过了，所以节点5这条路也遍历完了；退回到节点0，节点0的下一个要遍历的节点6已经被遍历过了，所以节点0这条路也已经便利完了；<br>至此，使用深度优先的方式，将所有节点全部遍历了一遍。</p>
<p>整个过程需要记录一下某个节点是否已经被遍历过。</p>
<h2 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h2><p>深度优先遍历的一个典型应用就是求连通分量。</p>
<p>对于一张有三个部分的图，在图论中，这三部分就是连通分量。连通分量之间没有任何边相连。求连通分量只需整体遍历这个图，从某个点开始遍历，先将这个连通分量遍历完；然后再找一个没有被遍历的点，继续遍历，则也可以将第二部分遍历完；最后将剩下的部分进行遍历。</p>
<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/2.png" alt="图"></p>
<p>以求连通分量为例，实现图的深度优先遍历。<br>创建<code>Component.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">bool</span> *visited; <span class="comment">//记录某个节点是否已经被访问过</span></span><br><span class="line">    <span class="keyword">int</span> ccount; <span class="comment">//连通分量个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//加typename指定adjInterator是一个类型而不是一个成员变量</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() ) &#123;<span class="comment">//从adj的第一个开始，只要不到adj的结尾，就进行循环，每次i变为adj的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] ) <span class="comment">//如果没有被访问过，使用递归方法对它继续进行深度优先遍历，</span></span><br><span class="line">                dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Component(Graph &amp;graph): G(graph)&#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        ccount = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">//如果当前的节点没有被访问过的话，就进行深度优先遍历</span></span><br><span class="line">                dfs(i);     <span class="comment">//遍历之后，所有连通的节点都置为true</span></span><br><span class="line">                ccount ++;  <span class="comment">//遍历之后，连通分量+1；然后接着找没有被遍历的节点作为起点进行深度遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Component()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// COMPONENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<p>新建文件<code>testG3.txt</code>，例子中的图表达为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 8</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 5</span><br><span class="line">0 6</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>

<p>在main函数中进行测试:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ReadGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Component.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename1 = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">    SparseGraph g1 = SparseGraph(<span class="number">13</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g1, filename1)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;SparseGraph&gt; <span class="title">component1</span><span class="params">(g1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG1.txt, Using Sparse Graph, Component Count: &quot;</span>&lt;&lt;component1.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    DenseGraph g2 = DenseGraph(<span class="number">13</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph2</span><span class="params">(g2, filename1)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;DenseGraph&gt; <span class="title">component2</span><span class="params">(g2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG1.txt, Using Dense Graph, Component Count: &quot;</span>&lt;&lt;component2.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TestG3.txt - g3 and g4</span></span><br><span class="line">    <span class="built_in">string</span> filename2 = <span class="string">&quot;testG2.txt&quot;</span>;</span><br><span class="line">    SparseGraph g3 = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph3</span><span class="params">(g3, filename2)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;SparseGraph&gt; <span class="title">component3</span><span class="params">(g3)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG3.txt, Using Sparse Graph, Component Count: &quot;</span>&lt;&lt;component3.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    DenseGraph g4 = DenseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph4</span><span class="params">(g4, filename2)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;DenseGraph&gt; <span class="title">component4</span><span class="params">(g4)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG3.txt, Using Dense Graph, Component Count: &quot;</span>&lt;&lt;component4.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/3.png" alt="测试结果"></p>
<p>相应的，如果能求出连通分量，也能求出两个结点之间是否是相连的。对<code>Component.h</code>做出修改:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">bool</span> *visited; <span class="comment">//记录某个节点是否已经被访问过</span></span><br><span class="line">    <span class="keyword">int</span> ccount; <span class="comment">//连通分量个数</span></span><br><span class="line">    <span class="keyword">int</span> *id;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        id[v] = ccount;  <span class="comment">//在进行dfs操作时，将id[v]的值设置为ccount的值，这样不同连通分量部分的顶点其值不同</span></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//加typename指定adjInterator是一个类型而不是一个成员变量</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() ) &#123;<span class="comment">//从adj的第一个开始，只要不到adj的结尾，就进行循环，每次i变为adj的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] ) <span class="comment">//如果没有被访问过，使用递归方法对它继续进行深度优先遍历，</span></span><br><span class="line">                dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Component(Graph &amp;graph): G(graph)&#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        ccount = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            id[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">//如果当前的节点没有被访问过的话，就进行深度优先遍历</span></span><br><span class="line">                dfs(i);     <span class="comment">//遍历之后，所有连通的节点都置为true</span></span><br><span class="line">                ccount ++;  <span class="comment">//遍历之后，连通分量+1；然后接着找没有被遍历的节点作为起点进行深度遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Component()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// COMPONENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<h2 id="获得两点间的一条路径"><a href="#获得两点间的一条路径" class="headerlink" title="获得两点间的一条路径"></a>获得两点间的一条路径</h2><p>使用深度优先的方式，不一定能获得一条最短路径。在<code>Path.h</code>类中新增一个数组<code>from</code>，用来记录每访问一个节点时，该节点是从哪个节点过来的，根据from数组，就可以倒推出两点之间相应的路径。<br><code>Path.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PATH_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">bool</span>* visited;</span><br><span class="line">    <span class="keyword">int</span>* from; <span class="comment">// 记录路径, from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//加typename指定adjInterator是一个类型而不是一个成员变量</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() ) &#123;<span class="comment">//从adj的第一个开始，只要不到adj的结尾，就进行循环，每次i变为adj的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] ) &#123;</span><br><span class="line">                <span class="comment">//如果没有被访问过，使用递归方法对它继续进行深度优先遍历，并将该节点放入from[]数组，说明是从v节点过来的</span></span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 寻路算法, 寻找图graph从s点到其他点的路径</span></span><br><span class="line">    Path(Graph &amp;graph, <span class="keyword">int</span> s):G(graph)&#123;</span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++ )&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻路算法</span></span><br><span class="line">        <span class="comment">// 其实就是进行深度优先遍历的过程中，记录一下</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Path()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点s到w是否有路</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点到w的具体路径是什么样的</span></span><br><span class="line">    <span class="comment">//因为是从w节点倒着走，所以先存放在stack中，然后在依次放在vector中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            vec.push_back( s.top() );</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s到w的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">        path(w,vec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; vec.size() ; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PATH_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>main.h</code>中进行测试，打印从0到6的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ReadGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Path.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">&quot;testG3.txt&quot;</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;DFS : &quot;</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/4.png" alt="测试结果"></p>
<h2 id="深度优先遍历的复杂度"><a href="#深度优先遍历的复杂度" class="headerlink" title="深度优先遍历的复杂度"></a>深度优先遍历的复杂度</h2><p>稀疏图（邻接表）:O(V+E)<br>稠密图（邻接矩阵）:O(V^2)</p>
<p>深度优先遍历对有向图依然有效</p>
<h1 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h1><p>广度优先遍历，使用队列进行辅助。<br>还是使用最开始的图进行讲解。<br><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/1.png" alt="图"><br>首先将节点0推入队列中，然后开始遍历过程；（和树的遍历一致，先将根节点推入）(此时队列为<code>0</code>)<br>遍历时，每次遍历都将队列首的元素取出来作为遍历的对象，现在队列首是节点0，将其取出，遍历节点0；(此时队列为空,遍历过的节点有<code>0</code>)<br>然后将所有与节点0相邻的节点，如果还没有加入队列中，就将其加入，所以将节点1，节点2，节点5，节点6加入到队列中，这样就完成了一次操作；(此时队列为<code>1 2 5 6</code>,遍历过的节点有<code>0</code>)<br>接着，将队列首的节点1拿出来作为遍历的对象，节点1就被遍历了，而与节点1相邻的节点只有节点0,0已经遍历过；所以继续将节点2从队列首拿出来，作为遍历的对象，而节点2相邻的节点也只有节点0,不用管；(此时队列为<code>5 6</code>，遍历过的节点有<code>0 1 2</code>)<br>接着将队列首的节点5拿出来，作为遍历的对象，对于节点5，它相邻的节点有节点0，节点3，节点4，节点0已经加入过队列并遍历完，所以将节点3，节点4加入到队列中；(此时队列为<code>6 3 4</code>，遍历过的节点有<code>0 1 2 5</code>)<br>继续将队列首的节点6拿出来，作为遍历的对象，节点6的相邻节点有节点0和节点4，需要注意节点0已经被遍历过不需要管，节点4虽然没有被遍历过，但是它已经被加入到队列中（所以在代码实现时，注意需要对加入到队列中的元素进行标记，因为一旦被加入到队列，那么它一定会被遍历），所以这次遍历就算完成;(此时队列为<code>3 4</code>,遍历过的节点有<code>0 1 2 5 6</code>)<br>接着将队列首的节点3拿出来进行遍历，节点3相邻的节点有节点4和节点5，节点5和节点4都已经被加入过队列，这次遍历结束；(此时队列为<code>4</code>，遍历过的节点有<code>0 1 2 5 6 3</code>)<br>最后将队列首的节点4拿出来进行遍历，对于节点4相邻的节点3，节点5，节点6都已经加入过队列，所以这次遍历结束。<br>至此，队列为空，广度优先遍历结束。</p>
<p>其实广度优先遍历，是以距起始节点的距离为顺序进行遍历的。<br>首先0节点自己到自己的距离为0，然后与节点0所有相邻的节点1、2、5、6被推进队列，它们距节点0的距离都为1；<br>接着将节点3,4推入到队列，它们距节点0的距离都为2。<br>所以广度优先遍历有时候也成为层序优先遍历，以遍历的起点开始，一层层的往下推，先遍历的节点距离起始节点近（更严谨的说法是先遍历的节点到起始节点的距离是小于等于后遍历的节点的，比如先遍历节点1后遍历节点6，但是它们到节点0 的距离都是1）。<br>利用这种方法，可以在程序中记录这个距离。在无权图中记录到起始节点的距离，不仅如此，如果像深度优先遍历，同时用<code>from[]</code>记录每一个节点是从哪一个节点过来，还可以将最短路径同时求出来。所以，广度优先遍历的一个应用就是求出<code>无权图</code>的最短路径(这里注意是无权图，但是不局限于有向图还是无向图)。</p>
<p>新建<code>ShortestPath.h</code>类:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHORTESTPATH_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHORTESTPATH_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">bool</span> *visited;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">int</span> *from;  <span class="comment">// 记录路径, from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line">    <span class="keyword">int</span> *ord; <span class="comment">//记录s到每一个节点的距离是多少，即记录路径中节点的次序。ord[i]表示i节点在路径中的次序。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ShortestPath( Graph &amp;graph, <span class="keyword">int</span> s):G(graph)&#123;</span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; graph.V() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; graph.V() ; i++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">            ord[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 无向图最短路径算法, 从s开始广度优先遍历整张图</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(s); <span class="comment">//首先向队列中推入原点s</span></span><br><span class="line">        visited[s] = <span class="literal">true</span>; <span class="comment">//标记s已经被访问</span></span><br><span class="line">        ord[s] = <span class="number">0</span>; <span class="comment">//标记原点到自己的距离为0</span></span><br><span class="line">        <span class="keyword">while</span>( !q.empty() )&#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.front(); <span class="comment">//将队列首的元素取出</span></span><br><span class="line">            q.pop(); <span class="comment">//队列首的元素出队</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,v)</span></span>;   <span class="comment">//遍历与队列首元素v所有相邻的元素</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() )&#123;</span><br><span class="line">                <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">//查看i元素是不是已经被访问过，即是否已经被加入过队列，如果没有的话</span></span><br><span class="line">                    q.push(i); <span class="comment">//把i加入到队列中</span></span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                    from[i] = v; <span class="comment">//是从v节点走到i的</span></span><br><span class="line">                    ord[i] = ord[v] + <span class="number">1</span>; <span class="comment">//从过来的节点的距离+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~ShortestPath()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] from;</span><br><span class="line">        <span class="keyword">delete</span>[] ord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V());</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            vec.push_back( s.top() );</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w,vec);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; vec.size() ; i ++ )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size() - <span class="number">1</span> )</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHORTESTPATH_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<p>使用main函数测试:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ReadGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Path.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ShortestPath.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">&quot;testG3.txt&quot;</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;DFS : &quot;</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">ShortestPath&lt;SparseGraph&gt; <span class="title">bfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;BFS : &quot;</span>;</span><br><span class="line">    bfs.showPath(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/5.png" alt="测试结果"></p>
<p>使用深度优先遍历有可能会找到最短路径，这与图的创建、具体的存储顺序有关；但是使用广度优先遍历，一定能够找到两个连通点的最短路径。此外，在这个图中，如果求0到4的最短路径，有可能取出<code>0-&gt;6-&gt;4</code>或者<code>0-&gt;5-&gt;4</code>，这与在图中遍历的顺序是怎样的有关。</p>
<h2 id="广度优先遍历的复杂度"><a href="#广度优先遍历的复杂度" class="headerlink" title="广度优先遍历的复杂度"></a>广度优先遍历的复杂度</h2><p>广度优先遍历的复杂度和深度优先遍历的复杂度是一样的:</p>
<p>稀疏图（邻接表）:O(V+E)<br>稠密图（邻接矩阵）:O(V^2)</p>
<h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/6.png" alt="程序结构"></p>
<p>其中几个主要的类实现参考<br><a href="https://homxuwang.github.io/2019/03/29/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/">图论基础</a></p>
<p><code>Path.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Graph G; <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;  <span class="comment">//起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited; <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] from;  <span class="comment">// 记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i : G.adj(v) )&#123; <span class="comment">// 遍历所有v的相邻点</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">// 如果没有被遍历过</span></span><br><span class="line">                from[i] = v;   <span class="comment">//将v加入到路径数组</span></span><br><span class="line">                dfs(i);     <span class="comment">//递归进行遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 寻路算法, 寻找图graph从s点到其他点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Path</span><span class="params">(Graph graph , <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">if</span>(!(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that s &gt;= 0 and s &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻路算法</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that w &gt;= 0 and w &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点的路径,存放在vec中</span></span><br><span class="line">    <span class="function">Vector&lt;Integer&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(hasPath(w)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过from数组逆向查找从s到w的路径，存放到栈中</span></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span> (p != -<span class="number">1</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈中取出元素，获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Integer&gt; res = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            res.add( s.pop() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasPath(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = path(w);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.size() ; i++)&#123;</span><br><span class="line">            System.out.print(vec.elementAt(i));</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size() - <span class="number">1</span> )</span><br><span class="line">                System.out.println();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ShortestPath.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Graph G; <span class="comment">//图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;  <span class="comment">//起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited; <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] from; <span class="comment">//记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ord;  <span class="comment">//记录路径中节点的次序，ord[i]表示i节点在路径中的次序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，寻路算法，寻找图graph从s点到其他点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShortestPath</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">if</span>(!(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that s &gt;= 0 and s &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = -<span class="number">1</span>;</span><br><span class="line">            ord[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无向图最短路径算法，s开始广度优先遍历整张图</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        q.add(s);</span><br><span class="line">        visited[s] = <span class="keyword">true</span>;</span><br><span class="line">        ord[s] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : G.adj(v))</span><br><span class="line">                <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                    q.add(i);</span><br><span class="line">                    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                    from[i] = v;</span><br><span class="line">                    ord[i] = ord[v] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that w &gt;= 0 and w &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点的路径，存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector&lt;Integer&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(hasPath(w)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过from数组逆向查找从s到w的路径,存放在栈中</span></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>(p != -<span class="number">1</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈中一次取出元素,获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Integer&gt; res = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line">            res.add(s.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s到w的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(hasPath(w)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = path(w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.size() ; i ++)&#123;</span><br><span class="line">            System.out.print(vec.elementAt(i));</span><br><span class="line">            <span class="keyword">if</span>(i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                System.out.println();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="comment">//若从s到w不可达，则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that w &gt;= 0 and w &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>testG3.txt</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 8</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 5</span><br><span class="line">0 6</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>

<p><code>Main.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG3.txt&quot;</span>;</span><br><span class="line">        SparseGraph g = <span class="keyword">new</span> SparseGraph(<span class="number">7</span>,<span class="keyword">false</span>);</span><br><span class="line">        ReadGraph readGraph = <span class="keyword">new</span> ReadGraph(g,filename);</span><br><span class="line">        g.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较使用深度优先遍历和广度优先遍历获得路径的不同</span></span><br><span class="line">        <span class="comment">//广度优先遍历获得的是无权图的最短路径</span></span><br><span class="line">        Path dfs = <span class="keyword">new</span> Path(g,<span class="number">0</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;DFS: &quot;</span>);</span><br><span class="line">        dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        ShortestPath bfs = <span class="keyword">new</span> ShortestPath(g,<span class="number">0</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;BFS: &quot;</span>);</span><br><span class="line">        bfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验结果:</p>
<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/7.png" alt="实验结果"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>图论基础</title>
    <url>/2019/03/29/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>图主要是节点和边组成的模型。图可以用来表达真实世界中的很多关系，如交通运输、社交网络、互联网等。<br>图分为有向图（Directed Graph）和无向图（Undirected Graph），有向图由于其不对称性，所有有时候会涉及很多比较难的算法。可以把无向图看成一种特殊的有向图。<br>图也可以分为有权图（Weighted Graph）和无权图（Unweighted Graph），权是指节点与节点之间的边的数值。<br>图不一定都要连接起来，比如一个模型中有三个没有连通起来的图。<br>有的图中有可能会有自环边（self-loop）和平行边（parallel-edges），简单图（Simple Graph）就是指没有自环边和平行边的图，因为有了自环边和平行边，那么算法可能会更加复杂。</p>
<h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>一种方法是使用邻接矩阵（Adjacency Matrix）表示一张图。<br>使用邻接矩阵表示这个无向图，a[i,j]代表的值为0或1。0代表不相连，1代表相连。这个矩阵是关于对角线对称的。<br><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png" alt="邻接矩阵表示无向图"><br>也可以使用邻接矩阵表示有向图。例如，0-&gt;1存在有向边，那么a[0,1]=1;但是1-&gt;0不存在有向边，所以a[1,0]=0。<br><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/2.png" alt="邻接矩阵表示有向图"></p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表（Adjacency Lists）只表达和某个顶点相连接的顶点的信息。对于每一行来说都相当于一个链表，存放了对于该节点相连的所有节点。<br><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/3.png" alt="邻接表表示无向图"><br>同样，邻接表也可以表达有向图。<br><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/4.png" alt="邻接表表示有向图"></p>
<p>由此可见，邻接表的占用空间要比邻接矩阵小。<br>邻接表适合表示稀疏图（Sparse Graph）<br>邻接矩阵适合表示稠密图（Dense Graph）</p>
<blockquote>
<p>数据结构中对于稀疏图的定义为：有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图（dense graph）。——百度百科<br>稠密图的一个极端情况就是完全图，即所有的点之间都互相连接。这种情况使用邻接矩阵进行存储会更好。</p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p><code>DenseGraph.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GRAPH_DENSEGRAPH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRAPH_DENSEGRAPH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稠密图 - 邻接矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseGraph</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="comment">//点数和边数</span></span><br><span class="line">    <span class="keyword">bool</span> directed;<span class="comment">//有向还是无向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; g; <span class="comment">//true表示有这条边,false表示没有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DenseGraph( <span class="keyword">int</span> n , <span class="keyword">bool</span> directed)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;<span class="comment">//n个顶点</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;<span class="comment">//初始为0条边</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            g.push_back( <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;( n, <span class="literal">false</span> ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~DenseGraph() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;<span class="comment">//返回顶点数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m;&#125;<span class="comment">//返回边数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//在顶点v和w间建立一条边</span></span><br><span class="line">        <span class="comment">//保证v和w不越界</span></span><br><span class="line">        assert( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line">        <span class="comment">//先判断v和w之间是否已经有边</span></span><br><span class="line">        <span class="keyword">if</span>( hasEdge( v, w )) <span class="comment">//这里避免了产生平行边的情况，这也是使用邻接矩阵的优点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        g[v][w] = <span class="literal">true</span>; <span class="comment">//如果是有向图，只需运行这一句话</span></span><br><span class="line">        <span class="keyword">if</span>( !directed ) <span class="comment">//如果是无向图</span></span><br><span class="line">            g[w][v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        m++; <span class="comment">//维护边数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w )</span></span>&#123; <span class="comment">//判断两个顶点是否已经有边</span></span><br><span class="line">        <span class="comment">//保证v和w不越界</span></span><br><span class="line">        assert( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[v][w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GRAPH_DENSEGRAPH_H</span></span></span><br></pre></td></tr></table></figure>
<p><code>SparseGraph.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GRAPH_SPARSEGRAPH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRAPH_SPARSEGRAPH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏图 - 邻接表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">bool</span> directed;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; g;  <span class="comment">// 图的具体数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SparseGraph( <span class="keyword">int</span> n , <span class="keyword">bool</span> directed )&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">            g.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//初始化时为空，因为初始化时没有顶点相连接，这里也可以用链表实现，使用链表在删除时效率高</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SparseGraph()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在使用邻接表进行表达的时候，通常允许有平行边</span></span><br><span class="line">    <span class="comment">//因为addEdge时，每进行一次添加，都要调用hasEdge进行判断，而hasEdge最差的时间复杂度为O(n)</span></span><br><span class="line">    <span class="comment">//所以addEdge也会退化为O(n)，一般在所有的边添加完成后再进行一次综合检查，去除平行边</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w )</span></span>&#123;</span><br><span class="line">         <span class="comment">//保证v和w不越界</span></span><br><span class="line">        assert( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        g[v].push_back(w);<span class="comment">//v和w相连</span></span><br><span class="line">        <span class="keyword">if</span>( v != w &amp;&amp; !directed ) <span class="comment">//如果v不是自环边且不是有向图</span></span><br><span class="line">            g[w].push_back(v);</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        assert( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; g[v].size() ; i++ )</span><br><span class="line">            <span class="keyword">if</span>( g[v][i] == w )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GRAPH_SPARSEGRAPH_H</span></span></span><br></pre></td></tr></table></figure>

<h1 id="遍历临边——相邻点迭代器"><a href="#遍历临边——相邻点迭代器" class="headerlink" title="遍历临边——相邻点迭代器"></a>遍历临边——相邻点迭代器</h1><p>在图的操作中，有一个基础操作——遍历临边。下图是对0节点表达临边时邻接矩阵和邻接表的不同。这个图也反映了遍历0的临边的方法。</p>
<p><font size = 5 color = red >这个是一个很重要的操作，在后面的很多方法中都用到了它！！！！</font></p>
<p><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/5.png" alt="遍历临边"></p>
<p>下面制作一个迭代器，用来访问一个顶点的所有临边。</p>
<p><code>SparseGraph.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GRAPH_SPARSEGRAPH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRAPH_SPARSEGRAPH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏图 - 邻接表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span>&#123;</span></span><br><span class="line">    <span class="comment">//...........省略代码</span></span><br><span class="line">     <span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">    <span class="comment">// 迭代在这个图中和这个顶点向连的所有顶点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SparseGraph &amp;G; <span class="comment">// 图G的引用</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    adjIterator(SparseGraph &amp;graph, <span class="keyword">int</span> v ): G(graph)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~adjIterator()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图G中与顶点v相连接的第一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( G.g[v].size() )</span><br><span class="line">            <span class="keyword">return</span> G.g[v][index];<span class="comment">//即g[v][0]</span></span><br><span class="line">        <span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回图G中与顶点v相连接的下一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index ++;</span><br><span class="line">        <span class="keyword">if</span>( index &lt; G.g[v].size() )</span><br><span class="line">            <span class="keyword">return</span> G.v[v][index];</span><br><span class="line">        <span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span></span>&#123; <span class="comment">//判断是否迭代完成</span></span><br><span class="line">        <span class="keyword">return</span> index &gt;= G.g[v].size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GRAPH_SPARSEGRAPH_H</span></span></span><br></pre></td></tr></table></figure>



<p>在<code>main</code>中进行测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    srand( time(<span class="literal">NULL</span>) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sparse Graph</span></span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">(N , <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> a = rand()%N;</span><br><span class="line">        <span class="keyword">int</span> b = rand()%N;</span><br><span class="line">        g1.addEdge( a , b );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(E)</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> v = <span class="number">0</span> ; v &lt; N ; v ++ )&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">        <span class="function">SparseGraph::adjIterator <span class="title">adj</span><span class="params">( g1 , v )</span></span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> w = adj.begin() ; !adj.end() ; w = adj.next() )</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;w&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/6.png" alt="测试结果"></p>
<p>可以看到稀疏图冲存在平行边，但是稠密图中没有平行边。稀疏图的遍历时间复杂度为O(E),稠密图的时间复杂度为O(V^2)。E为边数，V为顶点数。</p>
<h1 id="图的算法框架"><a href="#图的算法框架" class="headerlink" title="图的算法框架"></a>图的算法框架</h1><p>创建文件<code>testG1.txt</code>，用文件来表示一个图。如下面的数据：第一行表示有13个节点和13条边，第二行<code>0 5</code>则表示节点0 和 5之间有一条边。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13 13</span><br><span class="line">0 5</span><br><span class="line">4 3</span><br><span class="line">0 1</span><br><span class="line">9 12</span><br><span class="line">6 4</span><br><span class="line">5 4</span><br><span class="line">0 2</span><br><span class="line">11 12</span><br><span class="line">9 10</span><br><span class="line">0 6</span><br><span class="line">7 8</span><br><span class="line">9 11</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>
<p>同样创建第二个文件<code>testG2.txt</code>表示另一个图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 8</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>

<p>下面设计一个从文件中读取图的算法（无论是稀疏图还是稠密图都通用）,封装在<code>ReadGraph.h</code>类中。该类是一个模板类，指定一个图的引用和一个用来表示图的文件，将文件中存放的数据存到图中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> READGRAPH_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READGRAPH_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadGraph</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ReadGraph(Graph &amp;graph,<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">int</span> V,E;</span><br><span class="line"></span><br><span class="line">        assert( file.is_open() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先读取顶点数和边数</span></span><br><span class="line">        assert( getline(file,line) );</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        ss&gt;&gt;V&gt;&gt;E;</span><br><span class="line"></span><br><span class="line">        assert( V == graph.V() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后创建图</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; E ; i++)&#123;</span><br><span class="line">            assert( getline(file,line) );</span><br><span class="line">            <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            ss&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">            assert( a &gt;= <span class="number">0</span> &amp;&amp; a &lt; V );</span><br><span class="line">            assert( b &gt;= <span class="number">0</span> &amp;&amp; b &lt; V );</span><br><span class="line">            graph.addEdge( a , b );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// READGRAPH_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>SparseGraph.h</code>和<code>DenseGraph.h</code>中添加一个方法<code>show()</code>用来打印图:<br><code>SparseGraph.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;vertex &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; g[i].size() ; j++ )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;g[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DenseGraph.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;g[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数中进行测试:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ReadGraph.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两种图的存储方式读取testG1.txt文件</span></span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">( <span class="number">13</span> , <span class="literal">false</span> )</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">( g1 , filename )</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;test G1 in Sparse Graph:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    g1.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DenseGraph <span class="title">g2</span><span class="params">( <span class="number">13</span> , <span class="literal">false</span> )</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph2</span><span class="params">( g2 , filename )</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;test G1 in Dense Graph:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    g2.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两种图的存储方式读取testG2.txt文件</span></span><br><span class="line">    filename = <span class="string">&quot;testG2.txt&quot;</span>;</span><br><span class="line">    <span class="function">SparseGraph <span class="title">g3</span><span class="params">( <span class="number">6</span> , <span class="literal">false</span> )</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph3</span><span class="params">( g3 , filename )</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;test G2 in Sparse Graph:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    g3.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DenseGraph <span class="title">g4</span><span class="params">( <span class="number">6</span> , <span class="literal">false</span> )</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph4</span><span class="params">( g4 , filename )</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;test G2 in Dense Graph:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    g4.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用邻接矩阵和邻接表创建的图的结果:</p>
<p><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/7.png" alt="测试结果G1"></p>
<p><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/10.png" alt="测试结果G2"></p>
<h1 id="java表达"><a href="#java表达" class="headerlink" title="java表达"></a>java表达</h1><p>首先定义图的接口<code>Graph.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>;  <span class="comment">//获取图的顶点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>;  <span class="comment">//获取图的边数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">( <span class="keyword">int</span> v ,<span class="keyword">int</span> w)</span></span>; <span class="comment">//在v和w两个顶点间添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span>;<span class="comment">//查看v和w两个顶点间是否有边</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//打印图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>; <span class="comment">//获取与v顶点连接的所有边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义稠密图<code>DenseGraph.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稠密图 - 邻接矩阵</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DenseGraph</span> <span class="keyword">implements</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> directed; <span class="comment">// 是否为有向图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] g; <span class="comment">//图的具体数据，用二维数组表达</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DenseGraph</span><span class="params">( <span class="keyword">int</span> n , <span class="keyword">boolean</span> directed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)<span class="comment">//保证n要&gt;=0</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of n should be &gt;= 0.&quot;</span>); </span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="number">0</span> ;<span class="comment">//初始化时没有任何边</span></span><br><span class="line">        <span class="keyword">this</span>.directed = directed;</span><br><span class="line">        <span class="comment">//g初始化时为n*n的布尔型矩阵,每个g[i][j]均为false，因为开始时没有任何边</span></span><br><span class="line">        <span class="comment">//false为boolean型变量的默认值</span></span><br><span class="line">        g = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果v和w间已存在边，则直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(hasEdge( v , w ))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        g[v][w] = <span class="keyword">true</span>;<span class="comment">//v和w间建立边</span></span><br><span class="line">        <span class="keyword">if</span>( !directed ) <span class="comment">//如果不是有向图,则继续建立w到v的边</span></span><br><span class="line">            g[w][v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        m ++;<span class="comment">//维护边数，边数加一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断图中是否有v到w的边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[v][w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印显示图的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++)</span><br><span class="line">                System.out.print(g[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回图中v顶点的所有邻边</span></span><br><span class="line">    <span class="comment">//由于java使用引用机制，返回一个Vector不会带来额外开销</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        Vector&lt;Integer&gt; adjV = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(g[v][i])</span><br><span class="line">                adjV.add(i);</span><br><span class="line">        <span class="keyword">return</span> adjV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稀疏图<code>SparseGraph.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏图 - 邻接表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span> <span class="keyword">implements</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> directed; <span class="comment">//是否为有向图</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Integer&gt;[] g; <span class="comment">//图的具体数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SparseGraph</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">boolean</span> directed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of n should be &gt;= 0.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.directed = directed;</span><br><span class="line">        <span class="comment">//g初始化为n个空的vector,表示每一个g[i]都为空，即没有任何边</span></span><br><span class="line">        g = (Vector&lt;Integer&gt;[]) <span class="keyword">new</span> Vector[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            g[i] = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        g[v].add(w);</span><br><span class="line">        <span class="keyword">if</span>(v != w &amp;&amp; !directed) <span class="comment">//如果不是自环边，并且它是无向图，则创建w到v的边</span></span><br><span class="line">            g[w].add(v);</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证图中是否有v到w的边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; g[v].size() ; i++)</span><br><span class="line">            <span class="keyword">if</span>( g[v].elementAt(i) == w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;vertex %d :\t&quot;</span>,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; g[i].size() ; j++)</span><br><span class="line">                System.out.print(g[i].elementAt(j) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中一个顶点的所有邻边</span></span><br><span class="line">    <span class="comment">// 由于java使用引用机制，返回一个Vector不会带来额外开销,</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取图文件<code>ReadGraph.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scanner scanner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadGraph</span><span class="params">(Graph graph, String filename)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        readFile(filename);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> V = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (V &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;number of vertices in a Graph must be nonnegative&quot;</span>);</span><br><span class="line">            <span class="keyword">assert</span> V == graph.V();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> E = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (E &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;number of edges in a Graph must be nonnegative&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = scanner.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = scanner.nextInt();</span><br><span class="line">                <span class="keyword">assert</span> v &gt;= <span class="number">0</span> &amp;&amp; v &lt; V;</span><br><span class="line">                <span class="keyword">assert</span> w &gt;= <span class="number">0</span> &amp;&amp; w &lt; V;</span><br><span class="line">                graph.addEdge(v, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InputMismatchException e) &#123;</span><br><span class="line">            String token = scanner.next();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException(<span class="string">&quot;attempts to read an &#x27;int&#x27; value from input stream, but the next token is \&quot;&quot;</span> + token + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;attemps to read an &#x27;int&#x27; value from input stream, but there are no more tokens available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> filename != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(fis), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                scanner.useLocale(Locale.ENGLISH);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(filename + <span class="string">&quot; doesn&#x27;t exist.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Could not open &quot;</span> + filename, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写main函数然后测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用两种方式读取testG1.txt文件</span></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        SparseGraph g1 = <span class="keyword">new</span> SparseGraph(<span class="number">13</span>,<span class="keyword">false</span>);</span><br><span class="line">        ReadGraph readGraph1 = <span class="keyword">new</span> ReadGraph(g1,filename);</span><br><span class="line">        System.out.println(<span class="string">&quot;test G1 in Sparse Graph:&quot;</span>);</span><br><span class="line">        g1.show();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        DenseGraph g2 = <span class="keyword">new</span> DenseGraph(<span class="number">13</span>,<span class="keyword">false</span>);</span><br><span class="line">        ReadGraph readGraph2 = <span class="keyword">new</span> ReadGraph(g2,filename);</span><br><span class="line">        System.out.println(<span class="string">&quot;test G1 in Dense Graph:&quot;</span>);</span><br><span class="line">        g2.show();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用两种图的存储方式读取testG2.txt文件</span></span><br><span class="line">        filename = <span class="string">&quot;testG2.txt&quot;</span>;</span><br><span class="line">        SparseGraph g3 = <span class="keyword">new</span> SparseGraph(<span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadGraph readGraph3 = <span class="keyword">new</span> ReadGraph(g3, filename);</span><br><span class="line">        System.out.println(<span class="string">&quot;test G2 in Sparse Graph:&quot;</span>);</span><br><span class="line">        g3.show();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        DenseGraph g4 = <span class="keyword">new</span> DenseGraph(<span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadGraph readGraph4 = <span class="keyword">new</span> ReadGraph(g4, filename);</span><br><span class="line">        System.out.println(<span class="string">&quot;test G2 in Dense Graph:&quot;</span>);</span><br><span class="line">        g4.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取结果:<br><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/8.png" alt="测试结果"><br><img src="%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/9.png" alt="测试结果"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>堆和堆排序</title>
    <url>/2019/04/07/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>在<a href="https://homxuwang.github.io/2018/08/12/%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/">优先队列</a>这一文章中，实现优先队列使用了最大堆的数据结构。这一次将详细讲解堆。</p>
<blockquote>
<p>数据结构二叉堆能够很好地实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。如果我们将所有元素画成一棵二叉树，将每个较大元素和两个较小的元素用边连接就可以很容易看出这种结构。</p>
</blockquote>
<blockquote>
<p>定义：当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为有序堆。</p>
</blockquote>
<ul>
<li>堆中某个结点的值总是不大于其父结点的值</li>
<li>堆总是一棵完全二叉树</li>
<li>层数越高并<font color=red>不一定</font>值越大</li>
</ul>
<h1 id="堆的基本实现"><a href="#堆的基本实现" class="headerlink" title="堆的基本实现"></a>堆的基本实现</h1><p>如果用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点(父结点和两个子结点)。由于二叉堆是一个完全二叉树，因此可以使用数组来表示它。</p>
<blockquote>
<p>定义。二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存(不使用数组的第一个位置)。</p>
</blockquote>
<p>下面均以最大堆为例进行介绍。</p>
<p>下图为算法第四版中堆的表示：<br><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/1.png" alt="堆的数组表示"></p>
<blockquote>
<p>在一个堆中，位置k的结点的父亲结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。这样在不使用指针的情况下我们也可以通过计算数组的索引在树中上下移动:从a[k]向上一层就令k等于k/2，向下一层则令k等于2k或2k+1.</p>
</blockquote>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/2.png" alt="堆的数组表示"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parent(i) = i / 2</span><br><span class="line"></span><br><span class="line">left child   (i) = 2 * i</span><br><span class="line">right chilld (i) = 2 * i + 1</span><br></pre></td></tr></table></figure>

<h1 id="堆的算法"><a href="#堆的算法" class="headerlink" title="堆的算法"></a>堆的算法</h1><blockquote>
<p>在有序化的过程中我们会遇到两种情况。当某个结点的优先级上升(或是在堆底加入一个新的元素)时，我们需要由下至上恢复堆的顺序。当某个结点的优先级下降(例如，将根节点替换为一个较小的元素)时，我们需要由上至下恢复堆的顺序。</p>
</blockquote>
<h2 id="由下至上的堆有序化-上浮"><a href="#由下至上的堆有序化-上浮" class="headerlink" title="由下至上的堆有序化(上浮)"></a>由下至上的堆有序化(上浮)</h2><p>以下面的图为例，在堆中添加一个元素，相当于在数组末尾添加了一个元素.</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/3.png" alt="添加一个元素"></p>
<p>此时加入的元素<code>52</code>打破了堆的定义，它变得比它的父结点更大，所以需要交换它和它的父结点来修复堆。交换后这个节点比它的两个子结点都大(一个是曾经的父结点，另一个比它更小，因为它是曾经父结点的子结点)，但这个节点仍可能比它现在的父结点更大。所以要一遍遍地用相同的方法进行恢复，将这个结点不断上移，直到遇到一个比它大的父结点。</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/4.png" alt="上浮操作"></p>
<p>只要记住位置k的结点的父结点是[k/2]。在《算法(第四版)》中，这个方法定义为<code>swim()</code>，意为当一个节点太大的时候它需要浮(swim)到堆的更高层也有的地方将此方法定义为<code>shiftUp()</code>。这里只需明白其本质含义，理解起来就不难了。<br><code>swim()</code>方法中的循环可以保证只有位置k上的节点大于它的父结点时，堆的有序状态才会被打破。因此只要该节点不再大于它的父结点，堆的有序状态就恢复了。</p>
<p>首先需要两个辅助函数<code>less()</code>和<code>exch()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助函数less():比较索引i处的值是否小于索引j处的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data[i].compareTo(data[j]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数交换堆中索引为i和j的两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Item t = data[i];</span><br><span class="line">    data[i] = data[j];</span><br><span class="line">    data[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现<code>swim()</code>函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大堆核心辅助函数——swim()，进行元素上浮操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">        exch(k/<span class="number">2</span>,k);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些辅助函数在元素插入的时候进行相关调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count + <span class="number">1</span> &gt; capacity)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    data[count + <span class="number">1</span>] = item;  <span class="comment">//因为索引0位置不用，所以要+1</span></span><br><span class="line">    count ++;</span><br><span class="line">    <span class="comment">//上面两行可以写成data[++count] = item;</span></span><br><span class="line">    swim(  count );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="由上至下的堆有序化-下沉"><a href="#由上至下的堆有序化-下沉" class="headerlink" title="由上至下的堆有序化(下沉)"></a>由上至下的堆有序化(下沉)</h2><p>与上浮操作对应的操作就是下沉(sink或叫Shift Down)操作。</p>
<blockquote>
<p>如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小而被打破了，那么我们可以通过将它和它的两个子结点中较大者交换来恢复堆。交换可能会在子结点处继续打破堆的有序状态，因此我们需要不断地用相同的方式将其修复，将结点向下移动直到它的子结点都比它更小或是到达了堆的底部。</p>
</blockquote>
<p>上浮操作对应了堆的插入操作，下沉操作则对应了堆的取出元素的操作(也就是在优先队列中出队操作时，需要调用堆的取出元素操作，进而需要使用sink来维护堆)。</p>
<p>在取出元素时，只能取出根结点的元素(即最大值)。在取出根结点的元素后，将数组最后的元素放到根结点，然后从根结点开始下沉。(这是根据堆是完全二叉树的性质，将最后一个元素放到根结点，整个堆仍是一个完全二叉树)</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/5.png" alt="下沉操作"></p>
<p>下沉操作函数<code>sink()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大堆核心辅助函数——sink(),进行元素下沉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;<span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; less(j,j+<span class="number">1</span>)) <span class="comment">//判断是否有右孩子,如果有的话得到左孩子和右孩子中较大的值</span></span><br><span class="line">            j ++;</span><br><span class="line">        <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(!less(k,j)) <span class="comment">//data[k].compareTo(data[j]) &gt;= 0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        exch(k,j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在《算法(第四版)》中，取出最大值的函数为<code>delMax()</code>，个人觉得”删除”不是很合适。所以使用了bobo老师的命名<code>extractMax()</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从最大堆中取出堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    exch(<span class="number">1</span>,count);</span><br><span class="line">    count --;</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现最大堆的完成代码:见附录一</p>
<h2 id="Heapify"><a href="#Heapify" class="headerlink" title="Heapify"></a>Heapify</h2><p>对于给定的一个完全二叉树，它不满足堆的性质，如图。但是，对于给定的二叉树来说，它的所有叶子节点(即没有孩子的结点)，他们本身就是一个最大堆(黄色标记的节点)，每个堆中的元素只有一个。</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/6.png" alt="一个普通完全二叉树"></p>
<p>对于一个完全二叉树来说，第一个非叶子节点的索引是[完全二叉树的元素个数/2]得到的索引值.即对于这个完全二叉树来说，第一个非叶子结点的索引是[10/2=5].</p>
<p>从后向前考虑每一个不是叶子结点的结点。上面提到了，第一个非叶子结点是索引为5的结点，它和它的子结点62不满足堆的性质，所以对其进行<code>sink()</code>操作；然后对索引为4的结点进行<code>sink()</code>操作;接着是索引为3的节点、索引为2的节点、索引为1的节点(根节点).然后操作完成。</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/7.png" alt="将数组转化为堆"></p>
<p>看看算法第四版中的描述:</p>
<blockquote>
<p>一个更聪明更有效的办法是从右至左用sink()函数构造子堆。数组的每个位置都已经是一个子堆的根节点了，sink()对于这些子堆也适用。如果一个根节点的两个子结点都已经是堆了，那么在该节点上调用sink()可以将它们变成一个堆。这个过程会递归的建立起堆的秩序。开始时我们只需要扫描数组中的一半元素，因为我们可以跳过大小为1的子堆。最后我们在位置1上调用sink()方法,扫描结束。在排序的第一阶段，堆的构造方法和我们的想象有所不同，因为我们的目标是构造一个堆有序的数组并使最大元素位于数组的开头(次大的元素在附近)而非构造函数结束的末尾。</p>
</blockquote>
<p>新的构造函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line"><span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(Item[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">    data = (Item[]) <span class="keyword">new</span> Comparable[n+<span class="number">1</span>];</span><br><span class="line">    capacity = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    count = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = count / <span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i --)&#123; <span class="comment">//从第一个不是叶子结点的节点开始</span></span><br><span class="line">        sink(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要强调，堆排序的效率其实不如快速排序和归并排序，它在处理一些动态问题时是有优势的。</p>
<p>使用这种方式建堆比一个个插入元素建堆的效率是要高的。将n个元素逐个插入到一个空堆中，算法复杂度为O(nlogn).但是heapify的过程，算法复杂度为O(n).</p>
<p>使用这种方法初始化堆，然后进行堆排序虽然在速度上有了一定提升，但是和上面的堆排序一样，他们的空间复杂度都为O(n),即都需要重新构建n个空间的数组来进行相应操作，但是其实可以对其进行优化，使得排序在原数组上进行.</p>
<h2 id="原地堆排序"><a href="#原地堆排序" class="headerlink" title="原地堆排序"></a>原地堆排序</h2><p>所谓原地堆排序就是直接在相应的数组上进行排序，而不用再额外开辟n个空间将数组复制到堆中，原地堆排序的空间复杂度为O(1).<br>前面的知识我们知道，其实一个堆就是一个数组，只是它的索引从1开始，空间是n+1.所以我们完全可以把传入的数组看成一个堆，然后在它上面进行相应操作。</p>
<p>①、②：首先，将传入的数组使用heapify操作，将其变成一个最大堆。在最大堆中，第一个元素的位置就是整个数组中最大值.</p>
<p>③：然后，将最大的元素V放在数组末尾的位置，即让arr[0]:V与arr[n-1]:W交换。<br>这时候，前面的数组arr[0…n-2]部分不再满足最大堆的性质，因为第一个位置为W，它不是最大值。</p>
<p>④：所以这时候对元素W进行下沉操作，将绿色部分的数组再次转换为最大堆。这时，整个堆中最大的元素又在arr[0]位置，堆末尾的元素在倒数第2个位置arr[n-2]处。</p>
<p>⑤：此时再将堆首和堆尾的元素进行交换。此时的最大元素arr[0]放在了arr[n-2]位置处。由于这次交换，又打破了最大堆的性质，前面的数组(绿色部分)不再是最大堆。</p>
<p>⑥：这时候继续对索引为0的位置进行下沉操作。使得前半部分数组再次成为最大堆。</p>
<p>这样依次进行操作，知道堆中所有的元素都进入到蓝色部分。</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/8.png" alt="原地堆排序"></p>
<p>整个算法直接在原数组上进行，空间复杂度为O(1).</p>
<p>由于数组都是从索引0开始的，所以在对其操作时，需要注意相应的索引都应-1.</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/9.png" alt="原地堆排序的数组"></p>
<p>这时候计算孩子和父亲时需要注意:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//父节点</span><br><span class="line">parent(i) = (i-1) / 2</span><br><span class="line"></span><br><span class="line">//孩子节点</span><br><span class="line">left child   (i) = 2 * i + 1</span><br><span class="line">right child  (i) = 2 * i + 2</span><br><span class="line"></span><br><span class="line">//最后一个非叶子节点的索引</span><br><span class="line">index = (count-1) / 2</span><br></pre></td></tr></table></figure>

<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不产生实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HeapSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对数组进行hepify操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意，此时的堆是从0开始索引的</span></span><br><span class="line">        <span class="comment">//从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">        <span class="comment">//最后一个元素的索引 = n - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span> ) / <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">            sink2(arr,n,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt; <span class="number">0</span> ; i --)&#123;</span><br><span class="line">            <span class="comment">//依次交换数组首个元素和索引为i的元素</span></span><br><span class="line">            exch(arr,<span class="number">0</span>,i);</span><br><span class="line">            <span class="comment">//交换后对数组首元素进行下沉操作，使数组前部分扔为最大堆</span></span><br><span class="line">            sink(arr,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Object[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sink下沉操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 用来处理的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 用于下沉的元素索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] arr,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>; <span class="comment">//左孩子</span></span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>].compareTo(arr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[k].compareTo(arr[j]) &gt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           exch(arr,k,j);</span><br><span class="line">           k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化的下沉过程, 使用赋值的方式取代不断的exch,</span></span><br><span class="line">    <span class="comment">// 该优化思想和我们之前对插入排序进行优化的思路是一致的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink2</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Comparable e = arr[k];</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>].compareTo(arr[j]) &gt; <span class="number">0</span> )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( e.compareTo(arr[j]) &gt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            arr[k] = arr[j];</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[k] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="索引堆-Index-Heap"><a href="#索引堆-Index-Heap" class="headerlink" title="索引堆 - Index Heap"></a>索引堆 - Index Heap</h1><p>前面的介绍中，在进行堆排序时，实际上是在数组中进行了操作，排序的过程让元素在数组中的位置发生改变。当然这只是简单的元素。如果在实际应用中用了更复杂的结构，如字符串，让它进行交换会产生很大的性能消耗；又如本来堆排好序后是表示任务的优先级，现在要改变指定索引处任务则需要进行遍历、修改数据结果等操作，这都要消耗很大的性能。所以引入索引堆。</p>
<p>以最大索引堆为例,对于索引堆来说，将索引和数据分开存储，而真正表征堆的数组，是由索引构建成的，如下图，二叉堆的每个结点存的是索引号，当将数组构建成堆后，data域并没有改变，真正改变的是index域。index数组发生了改变，形成了一个堆-索引堆。</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/10.png" alt="索引堆"></p>
<p>那么如何解读索引堆呢？<br>看上图，此时堆顶的元素是10，意思是堆顶的元素是索引10指向的data[10]:62;<br>相应的，堆顶元素的左孩子为9，即对应data数组中索引为9的元素data[9]:41,右孩子为7,即对应data数组中索引为7的元素data[7]:28…依次类推</p>
<p>这样做的优点是：</p>
<ul>
<li>构建索引堆的过程只是索引的位置发生交换，而索引就只是简单的int型，如果data中存储的是很复杂的数据结构，仅交换索引的效率是很高的；</li>
<li>如果想对堆中的数据进行操作，比如将进程号为7的系统任务提高优先级，将data[7]:28提高为data[7]:38,进行完提高优先级操作后，这时候还要进行一系列操作维持堆的性质，这时候只需要根据新的data[]数组改变index数组就可以了。</li>
</ul>
<p>简单的解释就是在数据比较的时候比较的是data中的数据，在进行交换的时候交换的是index的索引。</p>
<p>索引堆的代码实现：见附录二</p>
<h2 id="索引堆的优化"><a href="#索引堆的优化" class="headerlink" title="索引堆的优化"></a>索引堆的优化</h2><p>在索引堆的代码中，进行change操作时，维护indexes数组时对indexes数组进行了一次遍历，使得其时间复杂度变为了O(n).其实有方法将其时间复杂度提升.</p>
<p>改进方法的思路成为反向查找。如下图，在原来两个数组的基础上又多了一个数组rev(reverse),rev[i]表示i这个索引在数组中的位置是什么。</p>
<p>举例来说，如果用户把位置4处的data:13修改了，修改了之后，就要维护4这个索引在堆中的位置，即维护indexes数组，那么可以通过rev[4]找到其在堆中的位置，即rev[4] = 9,索引4在堆中的位置就是在indexes[9]处。</p>
<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/11.png" alt="优化索引堆"></p>
<p>使用rev数组，在更新操作时就可以使用O(1)复杂度更新索引在indexes中的位置。</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>10</td>
<td>9</td>
<td>7</td>
<td>8</td>
<td>5</td>
<td>6</td>
<td>3</td>
<td>1</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>data</td>
<td>15</td>
<td>17</td>
<td>19</td>
<td>13</td>
<td>22</td>
<td>16</td>
<td>28</td>
<td>30</td>
<td>41</td>
<td>62</td>
</tr>
<tr>
<td>rev</td>
<td>8</td>
<td>10</td>
<td>7</td>
<td>9</td>
<td>5</td>
<td>6</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>reverse和indexes的关系:<br><code>reverse[i] 表示索引i在indexes(堆)中的位置</code></p>
<p>如果对堆进行了改动，那么reverse也要进行改动:<br><code>indexes[i] = j reverse[j] = i</code></p>
<p><code>indexes[reverse[i]] = i reverse[indexes[i]] = i</code></p>
<p>在书写代码时需要注意，在change函数操作时，输入索引i时，即使<code>i&gt;=1 &amp;&amp; i &lt; capacity</code>满足，但是也不意味着i处的元素在堆中。因此需要引入辅助函数<code>contain(i)</code>来检查索引堆是否包含该索引。需要在<code>getItem</code>和<code>change</code>方法中进行调用.</p>
<p>修改后的代码请见附录三(只写出了发生改变的函数).</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>可以使用堆实现优先队列，动态选择优先级最高的任务执行。</p>
<p>可以借用堆实现多路归并排序。</p>
<p>有了二叉堆的基础，可以基于用数组表示的完全三叉树构造堆，或者构造多叉堆。</p>
<p>本篇的用例都是以最大堆为例进行讲解和代码编写，转换一下逻辑也可以实现最小堆。</p>
<p>本篇中的数组采用的是固定大小的数组，也可是使用动态数组来实现，没有了capacity的限制，动态调整堆中数组的大小。</p>
<h1 id="附录一"><a href="#附录一" class="headerlink" title="附录一"></a>附录一</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 在堆的有关操作中，需要比较堆中元素的大小，所以Item需要extends Comparable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Item[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;  <span class="comment">//能够容纳的元素数量</span></span><br><span class="line">    <span class="comment">//构造函数,构造一个空的堆，能够容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个布尔值，表示堆是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count + <span class="number">1</span> &gt; capacity)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[count + <span class="number">1</span>] = item;  <span class="comment">//因为索引0位置不用，所以要+1</span></span><br><span class="line">        count ++;</span><br><span class="line">        <span class="comment">//上面两行可以写成data[++count] = item;</span></span><br><span class="line">        swim(  count );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从最大堆中取出堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        exch(<span class="number">1</span>,count);</span><br><span class="line">        count --;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大堆核心辅助函数——swim()，进行元素上浮操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">            exch(k/<span class="number">2</span>,k);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大堆核心辅助函数——sink(),进行元素下沉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;<span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; less(j,j+<span class="number">1</span>))  <span class="comment">//判断是否有右孩子,如果有的话得到左孩子和右孩子中较大的值</span></span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(!less(k,j)) <span class="comment">//data[k].compareTo(data[j]) &gt;= 0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            exch(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//辅助函数less():比较索引i处的值是否小于索引j处的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[i].compareTo(data[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//辅助函数交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Item t = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 MaxHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MaxHeap&lt;Integer&gt; maxHeap = <span class="keyword">new</span> MaxHeap&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">100</span>; <span class="comment">// 堆中元素个数</span></span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">100</span>; <span class="comment">// 堆中元素取值范围[0, M)</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )</span><br><span class="line">            maxHeap.insert( <span class="keyword">new</span> Integer((<span class="keyword">int</span>)(Math.random() * M)) );</span><br><span class="line"></span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[N];</span><br><span class="line">        <span class="comment">// 将maxheap中的数据逐渐使用extractMax取出来</span></span><br><span class="line">        <span class="comment">// 取出来的顺序应该是按照从大到小的顺序取出来的</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )&#123;</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保arr数组是从大到小排列的</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; i ++ )</span><br><span class="line">            <span class="keyword">assert</span> arr[i-<span class="number">1</span>] &gt;= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录二"><a href="#附录二" class="headerlink" title="附录二"></a>附录二</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大索引堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;   <span class="comment">//存储最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] indexes;<span class="comment">//存储最大索引堆中的索引</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数,构造一个空堆,可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity +<span class="number">1</span> ];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个布尔值,表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>]; <span class="comment">//对用户来说，索引从0开始，所以这里要+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向最大索引堆中插入一个新的元素,新元素的索引为i,元素为item</span></span><br><span class="line">    <span class="comment">//传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i , Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count + <span class="number">1</span> &gt; capacity)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对用户而言是从索引0开始，但是内部还是从1开始</span></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item; <span class="comment">//将item插入到data[i]处</span></span><br><span class="line">        indexes[count + <span class="number">1</span> ] = i;  <span class="comment">//之前是插入到data堆中，现在则插入到indexes堆底</span></span><br><span class="line">        count ++;</span><br><span class="line"></span><br><span class="line">       swim(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从最大索引堆中取出堆顶元素,即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        exchIndexes(<span class="number">1</span>,count);</span><br><span class="line">        count --;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;  <span class="comment">//对用户来说，索引从0开始，所以要-1</span></span><br><span class="line">        exchIndexes( <span class="number">1</span> , count );</span><br><span class="line">        count --;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]-<span class="number">1</span>;  <span class="comment">//对用户来说，索引是从0开始的，所以要减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i , Item newItem)</span></span>&#123;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到indexes[j] = i ,j表示data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">//之后进行sink(j)、swim(j) (前后顺序可变)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; count ; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indexes[j] == i)&#123;</span><br><span class="line">                swim(j);</span><br><span class="line">                sink(j);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换索引堆中的索引i和j</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchIndexes</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = indexes[i];</span><br><span class="line">        indexes[i] = indexes[j];</span><br><span class="line">        indexes[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在索引堆中，数据之间的比较根据data的大小进行比较，但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]].compareTo(data[indexes[k]])&lt; <span class="number">0</span>)&#123; <span class="comment">//原来直接对于data数组的操作要通过indexes索引堆间接找到data中的元素</span></span><br><span class="line">            exchIndexes(k,k/<span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * k &lt;= count)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]].compareTo(data[indexes[j]]) &gt; <span class="number">0</span>)</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="keyword">if</span>(data[indexes[k]].compareTo(data[indexes[j]]) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            exchIndexes(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录三"><a href="#附录三" class="headerlink" title="附录三"></a>附录三</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大索引堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;   <span class="comment">//存储最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] indexes;<span class="comment">// 最大索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] reverse;<span class="comment">// 最大索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数,构造一个空堆,可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity +<span class="number">1</span> ];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>]; <span class="comment">//reverse表示i索引在堆中的位置</span></span><br><span class="line">        <span class="comment">//取标记值,i不存在时应为0.因为索引是从1开始计数，0没有意义.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++)</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回索引堆中的元素个数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个布尔值,表示索引堆中是否为空</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(contain(i)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;index i is not in the heap!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>]; <span class="comment">//对用户来说，索引从0开始，所以这里要+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向最大索引堆中插入一个新的元素,新元素的索引为i,元素为item</span></span><br><span class="line">    <span class="comment">//传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i , Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count + <span class="number">1</span> &gt; capacity)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在插入一个新元素前，还需要保证索引i所在的位置是没有元素的</span></span><br><span class="line">        <span class="keyword">if</span>(contain(i))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;index i is not in the heap!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对用户而言是从索引0开始，但是内部还是从1开始</span></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item; <span class="comment">//将item插入到data[i]处</span></span><br><span class="line">        indexes[count + <span class="number">1</span> ] = i;  <span class="comment">//之前是插入到data堆中，现在则插入到indexes堆底</span></span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        count ++;</span><br><span class="line"></span><br><span class="line">       swim(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从最大索引堆中取出堆顶元素,即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        exchIndexes(<span class="number">1</span>,count);</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>; <span class="comment">//因为交换后，相当于把栈顶元素放到了最后，然后用count--就相当于删除这个元素，删除这个元素那么它的reverse值指向0就可以了.</span></span><br><span class="line"></span><br><span class="line">        count --;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;  <span class="comment">//对用户来说，索引从0开始，所以要-1</span></span><br><span class="line">        exchIndexes( <span class="number">1</span> , count );</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>; <span class="comment">//因为交换后，相当于把栈顶元素放到了最后，然后用count--就相当于删除这个元素，删除这个元素那么它的reverse值指向0就可以了.</span></span><br><span class="line"></span><br><span class="line">        count --;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(count &gt; <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count should be &gt; 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]-<span class="number">1</span>;  <span class="comment">//对用户来说，索引是从0开始的，所以要减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i , Item newItem)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(contain(i)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;index i is not in the heap!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到indexes[j] = i ,j表示data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">//之后进行sink(j)、swim(j) (前后顺序可变)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有了 reverse 之后可以非常简单的通过reverse直接定位索引i在indexes中的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = reverse[i];</span><br><span class="line">        swim(j);</span><br><span class="line">        sink(j);</span><br><span class="line"><span class="comment">//        for(int j = 1 ; j &lt; count ; j ++)&#123;</span></span><br><span class="line"><span class="comment">//            if(indexes[j] == i)&#123;</span></span><br><span class="line"><span class="comment">//                swim(j);</span></span><br><span class="line"><span class="comment">//                sink(j);</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换索引堆中的索引i和j</span></span><br><span class="line">    <span class="comment">// 由于有了反向索引reverse数组，</span></span><br><span class="line">    <span class="comment">// indexes数组发生改变以后， 相应的就需要维护reverse数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchIndexes</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = indexes[i];</span><br><span class="line">        indexes[i] = indexes[j];</span><br><span class="line">        indexes[j] = t;</span><br><span class="line"></span><br><span class="line">        reverse[indexes[i]] = i;</span><br><span class="line">        reverse[indexes[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在索引堆中，数据之间的比较根据data的大小进行比较，但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]].compareTo(data[indexes[k]])&lt; <span class="number">0</span>)&#123; <span class="comment">//原来直接对于data数组的操作要通过indexes索引堆间接找到data中的元素</span></span><br><span class="line">            exchIndexes(k,k/<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//下面两行写在了exchIndexes中</span></span><br><span class="line">            <span class="comment">// reverse[indexes[k/2]] = k / 2;</span></span><br><span class="line">            <span class="comment">// reverse[indexes[k]] = k;</span></span><br><span class="line"></span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * k &lt;= count)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]].compareTo(data[indexes[j]]) &gt; <span class="number">0</span>)</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="keyword">if</span>(data[indexes[k]].compareTo(data[indexes[j]]) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            exchIndexes(k,j);</span><br><span class="line">            <span class="comment">//下面两行写在了exchIndexes中</span></span><br><span class="line">            <span class="comment">// reverse[indexes[k]] = k;</span></span><br><span class="line">            <span class="comment">// reverse[indexes[j]] = j;</span></span><br><span class="line"></span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断索引是否在堆中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;i out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse[ i + <span class="number">1</span> ] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试索引堆中的索引数组index和反向数组reverse</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">testIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] copyReverseIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ ) &#123;</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line">            copyReverseIndexes[i] = reverse[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        copyReverseIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(copyIndexes);</span><br><span class="line">        Arrays.sort(copyReverseIndexes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引和反向索引进行排序后,</span></span><br><span class="line">        <span class="comment">// 两个数组都应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i-<span class="number">1</span>] + <span class="number">1</span> != copyIndexes[i] ||</span><br><span class="line">                    copyReverseIndexes[i-<span class="number">1</span>] + <span class="number">1</span> != copyReverseIndexes[i] )&#123;</span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 IndexMaxHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">        IndexMaxHeap&lt;Integer&gt; indexMaxHeap = <span class="keyword">new</span> IndexMaxHeap&lt;Integer&gt;(N);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )</span><br><span class="line">            indexMaxHeap.insert( i , (<span class="keyword">int</span>)(Math.random()*N) );</span><br><span class="line">        <span class="keyword">assert</span> indexMaxHeap.testIndexes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/12.png" alt="测试结果"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring常用注解</title>
    <url>/2019/07/01/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>@Configuration 放在对应类的上面,告诉spring这是一个配置类。</p>
<p>配置类 == 配置文件</p>
<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>@ComponentScan 按照一定规则自动扫描指定包中的组件，加入到IOC容器中。<br>几个常用的值：</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>@ComponentScan(value = “com.study”)  设置要扫描的包路径</p>
<h3 id="excludeFilters"><a href="#excludeFilters" class="headerlink" title="excludeFilters"></a>excludeFilters</h3><p>excludeFilters : Filter[] excludeFilters() default {}; </p>
<p>其核心是设置Filter数组，即过滤规则数组，所以在介绍<code>excludeFilters</code>之前，要介绍<code>@ComponentScan.Filter</code>：</p>
<h4 id="ComponentScan-Filter"><a href="#ComponentScan-Filter" class="headerlink" title="@ComponentScan.Filter"></a>@ComponentScan.Filter</h4><p>指定扫描时按照什么规则排除组件,是一个Filter数组，其中Filter数组中可以设置排除规则type:</p>
<ul>
<li>FilterType.ANNOTATION : 按照注解进行过滤</li>
<li>FilterType.ASSIGNABLE_TYPE: 按照指定类型进行过滤</li>
<li>FilterType.ASPECTJ : ASPECTJ表达式(基本不用</li>
<li>FilterType.REGEX : 使用正则表达式</li>
<li>FilterType.CUSTOM : 使用自定义规则</li>
</ul>
<p>如：</p>
<p>按照注解进行过滤，排除用<code>@Service</code>进行注解的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">   value = &quot;com.study&quot;,</span></span><br><span class="line"><span class="meta">   excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">      @ComponentScan.Filter(type = FilterType.ANNOTATION , value = &#123;Service.class&#125;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<p>按照指定类进行过滤,如排除<code>BookService</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">   value = &quot;com.study&quot;,</span></span><br><span class="line"><span class="meta">   excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">      @ComponentScan.Filter(type = FilterType.ANNOTATION , value = &#123;Service.class&#125;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<p>按照自定义规则进行过滤,这时候要自己定义过滤规则(一个继承了<code>org.springframework.core.type.filter.TypeFilter</code>接口的类):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">   value = &quot;com.study&quot;,</span></span><br><span class="line"><span class="meta">   excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">       @ComponentScan.Filter(type = FilterType.CUSTOM,classes = &#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<p>如<code>MyTypeFilter.java</code>,可以获取到类名中含有<code>er</code>的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.ClassMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReader 读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReaderFactory 可以获取到其他任何类的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前正在扫描的类注解的信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">//获取当前正在扫描的类的信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">//获取当前类的路径信息(如：类的路径)</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比如获取类名</span></span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        System.out.println(<span class="string">&quot;----&gt;&quot;</span> +className);</span><br><span class="line">        <span class="keyword">if</span> (className.contains(<span class="string">&quot;er&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="includeFilters"><a href="#includeFilters" class="headerlink" title="includeFilters"></a>includeFilters</h3><p>includeFilters的使用方法和excludeFilters相似,指定扫描时按照什么规则加载组件。只不过要将<code>useDefaultFilters</code>设置为<code>false</code>(默认为true)。这和用配置文件配置也相似,在xml中设置use-default-filters为false:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>includeFilters的设置方法如下,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">                value = &quot;com.study&quot;,</span></span><br><span class="line"><span class="meta">//                excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">//                    @ComponentScan.Filter(type = FilterType.ANNOTATION , value = &#123;Service.class&#125;)</span></span><br><span class="line"><span class="meta">//                &#125;,</span></span><br><span class="line"><span class="meta">                includeFilters = &#123;</span></span><br><span class="line"><span class="meta">//                        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;),</span></span><br><span class="line"><span class="meta">//                        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = &#123;BookService.class&#125;,</span></span><br><span class="line"><span class="meta">                        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = &#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">                &#125;,</span></span><br><span class="line"><span class="meta">                useDefaultFilters = false</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<h2 id="ComponentScans"><a href="#ComponentScans" class="headerlink" title="@ComponentScans"></a>@ComponentScans</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScans &#123;</span><br><span class="line"></span><br><span class="line">	ComponentScan[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看其源码可以知道，它的value是一个ComponentScan数组，即我们可以配置多个ComponentScan。</p>
<p>它的写法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScans(value = &#123;</span></span><br><span class="line"><span class="meta">        @ComponentScan(</span></span><br><span class="line"><span class="meta">                value = &quot;com.study&quot;,</span></span><br><span class="line"><span class="meta">               excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">                   @ComponentScan.Filter(type = FilterType.ANNOTATION , value = &#123;Service.class&#125;)</span></span><br><span class="line"><span class="meta">               &#125;,</span></span><br><span class="line"><span class="meta">        ),</span></span><br><span class="line"><span class="meta">        @ComponentScan(</span></span><br><span class="line"><span class="meta">                value = &quot;com.study&quot;,</span></span><br><span class="line"><span class="meta">                includeFilters = &#123;</span></span><br><span class="line"><span class="meta">                        @ComponentScan.Filter(type = FilterType.CUSTOM,classes = &#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">                &#125;,</span></span><br><span class="line"><span class="meta">                useDefaultFilters = false</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><p>@Scope注解和在配置文件中配置scope属性类似，即设置是单实例还是多实例。</p>
<p>可取值:</p>
<ul>
<li>ConfigurableBeanFactory#SCOPE_PROTOTYPE    prototype —- 多实例的  多实例情况下，ioc容器启动时不会调用方法去创建对象，而是在获取时才会调用方法创建对象</li>
<li>ConfigurableBeanFactory#SCOPE_SINGLETON    singleton —- 单实例的  单实例情况下，ioc容器启动时即调用方法创建对象放到容器中，以后获取就从Ioc容器中拿就可以了</li>
<li>org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST    request —- 同一个请求创建一个实例</li>
<li>org.springframework.web.context.WebApplicationContext#SCOPE_SESSION    session —- 同一个session创建一个实例</li>
</ul>
<p>最后两个并不常用，所以了解即可。</p>
<p>使用方法，如在要注入的类上面写上对应的值即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;person02&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">//多实例的</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;创建了person02 Bean&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><p>懒加载，一般对@Scope(“singleton”) 的组件使用。<br>一般情况下，使用@Scope(“singleton”)标注的组件，在容器加载前就已经创建好了实例，但是使用@Lazy注解标注的话，在第一次使用该组件时才创建组件到IOC容器中。</p>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p>@Conditional - 按照条件注册bean，since 4.0 ，4.0版本才引入的这个注解</p>
<p>从其源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，它可以标注在类上面，也可以标注在方法上面.并且其参数是实现Condition接口的数组，Condition接口有个matches方法，如果匹配了规则则返回true，否则返回false</p>
<p>即@Conditional({Condition})</p>
<p>例,使用规则，如果是windows系统，给容器注册(“bill”),如果是linux系统，给容器注册(“linus”):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;bill&quot;)</span></span><br><span class="line"><span class="meta">@Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;Bill Gates&quot;</span>,<span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = &quot;linus&quot;)</span></span><br><span class="line"><span class="meta">@Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;Linus&quot;</span>,<span class="number">48</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是linux系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 判断条件能使用的上下文环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata 标注了Condition注解的注释信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取到ioc当前使用的beanfactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">        <span class="comment">//2.获取到类加载器</span></span><br><span class="line">        ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">        <span class="comment">//3.获取运行环境信息</span></span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        <span class="comment">//4.获取到bean定义的注册类,从其源码可以看出，它可以注册一个bean的定义，也能移除一个bean的定义，也可以查看是否含有一个bean，也能查询bean</span></span><br><span class="line">        <span class="comment">//所以可以根据容器中bean的注册情况，给容器中注册、删除组件等</span></span><br><span class="line">        BeanDefinitionRegistry registry = context.getRegistry();</span><br><span class="line"></span><br><span class="line">        String osName = environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(osName.contains(<span class="string">&quot;linux&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…省略WindowsCondition.java</p>
<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>给容器快速导入一个组件</p>
<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Color.class, Red.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@import的源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment">	 * or regular component classes to import.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可看出，它除了可以传入要导入的Class之外，也可以传入实现了 ImportSelector和ImportBeanDefinitionRegistrar接口的类。</p>
<h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>自定义逻辑，返回需要导入的组件。<br>从其源码可以看出，返回的是一个String数组，这是定义了要导入的组件的全类名的String数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如，下面将导入对应包下的Blue类和Yellow类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportSelector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义逻辑，返回需要导入的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值就是要导入到容器中的组件全类名</span></span><br><span class="line">    <span class="comment">//AnnotationMetadata: 当前标注@import 注解的类的所有注解信息(即除了@import 可以获取这个被标注的类的其他的注解)</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回要注册的组件的全类名数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.study.bean.Blue&quot;</span>,<span class="string">&quot;com.study.bean.Yellow&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p>这是官方的解释:</p>
<blockquote>
<p>Register bean definitions as necessary based on the given annotation metadata of the importing {@code @Configuration} class.</p>
</blockquote>
<p>使用ImportBeanDefinitionRegistrar接口实现的类,可以自由发挥，动态的生成一些Bean。</p>
<p>例如,动态添加一个RainBow组件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata 当前类的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry BeanDefinition注册类，可以把所有需要添加到容器中的类，调用BeanDefinitionRegistry.registerBeanDefinition 方法手动注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看容器中是否已有蓝色和红色组件</span></span><br><span class="line">        <span class="keyword">boolean</span> blue = registry.containsBeanDefinition(<span class="string">&quot;com.study.bean.Blue&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> red = registry.containsBeanDefinition(<span class="string">&quot;com.study.bean.Red&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(blue &amp;&amp; red)&#123;</span><br><span class="line">            <span class="comment">//第一个参数指定bean的名字</span></span><br><span class="line">            <span class="comment">// 第二个参数是BeanDefinition接口，使用 RootBeanDefinition 实现,即指定bean的定义信息(哪个类，scope等。。。。)</span></span><br><span class="line">            RootBeanDefinition rainBowRootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow.class);</span><br><span class="line">            registry.registerBeanDefinition(<span class="string">&quot;rainBow&quot;</span>,rainBowRootBeanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给容器中注册组件小节"><a href="#给容器中注册组件小节" class="headerlink" title="给容器中注册组件小节"></a>给容器中注册组件小节</h2><p>给容器中注册组件：</p>
<ul>
<li>1.包扫描+组件标注注解(@Controller/@Service/@Repository/@Component) [有局限性，自己写的类很方便引入，但是第三方包不方便引入]</li>
<li><ol start="2">
<li>@Bean[ 导入第三方包里面的组件,使用无参构造器创建一个组件]</li>
</ol>
</li>
<li><ol start="3">
<li>@Import [快速给容器中注册一个组件]</li>
</ol>
<ul>
<li><ol>
<li>@Import 要导入到容器中的组件，容器中就会自动注册这个组件，Id默认是全类名</li>
</ol>
</li>
<li>2）ImportSelector:是一个接口，返回selectImports的String[]数组,这个数组即为要导入的类的全类名数组{@link com.study.condition.MyImportSelector}</li>
<li><ol start="3">
<li>ImportBeanDefinitionRegistrar: 也是一个接口，有个方法registerBeanDefinitions</li>
</ol>
</li>
</ul>
</li>
<li><ol start="4">
<li>使用Spring提供的FactoryBean(工厂Bean),一般的Bean，容器会调用一般的Bean的无参构造器，默认创建一个对象注册到容器中。它是一个接口{@link org.springframework.beans.factory.FactoryBean}</li>
</ol>
</li>
</ul>
<h3 id="使用Spring提供的FactoryBean"><a href="#使用Spring提供的FactoryBean" class="headerlink" title="使用Spring提供的FactoryBean"></a>使用Spring提供的FactoryBean</h3><p>这里补充一下上面提到的使用Spring提供的FactoryBean(工厂Bean)</p>
<p>让要添加到容器中的类实现FactoryBean<T> 接口。</p>
<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Color.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以设置是否是单实例</span></span><br><span class="line">    <span class="comment">//true为单实例 false为多实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时,直接返回这个类的对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ColorFactoryBean <span class="title">colorFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ColorFactoryBean();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意:虽然下面的 colorFactoryBean 注册到了容器中，但是对它进行获取，得到的是Color实例，即获取的是调用getObject创建的对象，</li>
<li>若就是要获取工厂Bean本身的话,要在id前面加一个&amp;标识，如下面的:getBean(“&amp;colorFactoryBean”) 源码:{@link org.springframework.beans.factory.BeanFactory}</li>
</ul>
<h1 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h1><p>bean的生命周期是指bean创建—初始化—销毁的过程</p>
<p>一般都遵循下面的流程：</p>
<p> 构造(对象创建)<br>     单实例:在容器启动时创建对象<br>     多实例:在每次获取的时候创建对象</p>
<p> 初始化之前调用BeanPostProcessor.postProcessBeforeInitialization()<br> 初始化：<br>     对象创建完成并赋值好后，调用初始化方法<br> 初始化之后调用BeanPostProcessor.postProcessAfterInitialization()</p>
<p> 销毁：<br>     单实例：bean容器关闭的时候销毁<br>     多实例：容器不关闭时不销毁</p>
<h2 id="使用Bean定义初始化和销毁方法"><a href="#使用Bean定义初始化和销毁方法" class="headerlink" title="使用Bean定义初始化和销毁方法"></a>使用Bean定义初始化和销毁方法</h2><p>让容器管理bean的生命周期，我们可以自定义初始化和销毁方法,在bean进行到当前生命周期的时候,容器调用对应方法。</p>
<p>1).使用以前的xml配置: init-method=””   destory-method=””</p>
<p>2).看@Bean的源码,含有两个值initMethod 和destoryMethond.用它们来制定对应的init和destory方法<br>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car...Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car...init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car...destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现接口InitializingBean-DisposableBean"><a href="#实现接口InitializingBean-DisposableBean" class="headerlink" title="实现接口InitializingBean/DisposableBean"></a>实现接口InitializingBean/DisposableBean</h2><p>还有一种方式是让要注册的bean实现接口:</p>
<ul>
<li><p>{@link org.springframework.beans.factory.InitializingBean} 它的afterPropertiesSet()方法定义初始化逻辑（在其bean的属性都赋值完成后）</p>
</li>
<li><p>{@link org.springframework.beans.factory.DisposableBean}  它的destroy()方法定义销毁逻辑</p>
</li>
</ul>
<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat ... constructor...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat  .... destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat ...afterPropertiesSet...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用JSR250规范中定义的两个注解-PostConstruct-PreDestroy"><a href="#使用JSR250规范中定义的两个注解-PostConstruct-PreDestroy" class="headerlink" title="使用JSR250规范中定义的两个注解 @PostConstruct/@PreDestroy"></a>使用JSR250规范中定义的两个注解 @PostConstruct/@PreDestroy</h2><p>从字面意思就很好理解这两个注解的意思。</p>
<ul>
<li><p> @PostConstruct : 在bean创建完成并且属性赋值完成后执行一些初始化方法.(@Target(METHOD)标注在方法上）</p>
</li>
<li><p> @PreDestroy : 在bean被移除之前进行回调通知.（@Target(METHOD)标注在方法上）</p>
</li>
</ul>
<p>从这两个的源码可以看出,他们是标注在方法上的注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span> (RUNTIME)</span><br><span class="line"><span class="meta">@Target(METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostConstruct &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog....constructor...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象创建完成后调用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog....@PostConstruct...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容器移除对象之前</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog....@PreDestroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>看官方注释的解释:</p>
<blockquote>
<p>Apply this BeanPostProcessor to the given new bean instance <i>before</i> any bean initialization callbacks (like InitializingBean’s {@code afterPropertiesSet} or a custom init-method). The bean will already be populated with property values.</p>
</blockquote>
<p>BeanPostProcessor 接口定义了一个你可以自己实现的回调方法，来实现你自己的实例化逻辑、依赖解决逻辑等，如果你想要在Spring完成对象实例化、配置、初始化之后实现自己的业务逻辑，你可以补充实现一个或多个BeanPostProcessor的实现。</p>
<p>即在bean初始化前后进行一些处理工作 。它是一个接口。<br>其中有两个要实现的方法:</p>
<ul>
<li>postProcessBeforeInitialization() : 初始化之前进行一些后置处理工作 (详情见源码介绍</li>
<li> postProcessAfterInitialization()  : 初始化之后进行一些后置处理工作 (详情见源码介绍</li>
</ul>
<p>我们可以看到注释postProcessBeforeInitialization方法是在所有的bean的InitializingBean的afterPropertiesSet方法之前执行而postProcessAfterInitialization方法则是在所有的bean的InitializingBean的afterPropertiesSet方法之后执行的。——<a href="https://www.jianshu.com/p/fb39f568cd5e">摘自</a></p>
<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器：初始化前后进行处理工作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBeanPostProcessor...constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessBeforeInitialization:&quot;</span> + beanName + <span class="string">&quot; ---&gt; &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessAfterInitialization:&quot;</span> + beanName + <span class="string">&quot; ---&gt; &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanPostProcessor在Spring底层还有很多应用，要多加学习。</p>
<h1 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h1><h2 id="Value赋值"><a href="#Value赋值" class="headerlink" title="@Value赋值"></a>@Value赋值</h2><p>在要注入的属性域上面用@Value().</p>
<ul>
<li>1.基本数值</li>
<li>2.可以写SpEL:#{}</li>
<li>3.取出配置文件(properties文件)中的值（在运行的环境变量中的值）: ${}</li>
</ul>
<p>3的使用见下一小节</p>
<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;20-2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.nickName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line"></span><br><span class="line">    getters/setters..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PropertySource加载外部配置文件"><a href="#PropertySource加载外部配置文件" class="headerlink" title="@PropertySource加载外部配置文件"></a>@PropertySource加载外部配置文件</h2><p>使用@PropertySource读取外部配置文件中的k/v 保存到运行的环境变量中,使用${}取出配置文件中的值。配置文件的值可以在上下文环境获取到</p>
<p>PropertySource的有 @Repeatable(PropertySources.class)标注, 可以标注<br>多个PropertySource.可以使用PropertySources 传入多个PropertySource</p>
<p>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表名是配置文件</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;,encoding = &quot;UTF-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfPropertyValue</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>见上一小节，在Person中就可以用@Value取出配置文件中的值了</p>
<h2 id="自动装配-Autowried-amp-Qualifier-amp-Primary"><a href="#自动装配-Autowried-amp-Qualifier-amp-Primary" class="headerlink" title="自动装配:@Autowried&amp;@Qualifier&amp;@Primary"></a>自动装配:@Autowried&amp;@Qualifier&amp;@Primary</h2><p>自动装配： Spring使用依赖注入(DI),完成对IOC容器中各个组件的依赖关系赋值</p>
<ul>
<li>1.) @Autowired<ul>
<li>1.当一个类中需要另一个组件时，标注了@Autowried，默认优先按照类型去容器中找对应的组件,类似于applicationContext.getBean(Bean.class);</li>
<li>2.如果按照类型找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找</li>
</ul>
</li>
<li>2.) @Qualifier<ul>
<li>使用@Qualifier(“”) 指定要装配的组件的id，而不是使用属性名</li>
</ul>
</li>
<li>3.) @Primary<ul>
<li>没有明确指定的情况下,让容器自动装配时默认使用首选的bean.</li>
</ul>
</li>
<li>4.) 使用自动装配默认一定要将属性赋值好；没有的话就会报错。<ul>
<li>可以使用@Autowired(required=false) 使其变为非必须的(如果没有要的组件的话就为 null,而不是报错</li>
</ul>
</li>
</ul>
<h2 id="自动装配-Resource-amp-Inject"><a href="#自动装配-Resource-amp-Inject" class="headerlink" title="自动装配:@Resource&amp;@Inject"></a>自动装配:@Resource&amp;@Inject</h2><p>Spring还支持使用@Resource(JSR250)和@Inject(JSR330)【这两个是java规范注解】进行自动装配</p>
<ul>
<li>@Resource: 可以和@Autowried一样实现自动装配功能，默认按照属性名称装配。也可以使用name设置要装配的组件的Id:@Resource(name=””), 没有支持@Primary功能和@Autowried(required=false)功能</li>
<li>@Inject: 使用时需要先导入依赖:{@url <a href="https://mvnrepository.com/artifact/javax.inject/javax.inject/1%7D">https://mvnrepository.com/artifact/javax.inject/javax.inject/1}</a>  功能与@Autowried一样，默认支持Primary的特性,但不支持@Autowried(required=false)功能</li>
</ul>
<h2 id="自动装配-方法、构造器位置的自动装配"><a href="#自动装配-方法、构造器位置的自动装配" class="headerlink" title="自动装配:方法、构造器位置的自动装配"></a>自动装配:方法、构造器位置的自动装配</h2><p>@Autuwried 能标注的位置不只是在组件上面，还可以在构造器，方法，参数，属性  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, </span></span><br><span class="line"><span class="meta">ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br></pre></td></tr></table></figure>

<p>1.)如果<code>标注在方法</code>上，Spring创建当前对象，就会调用方法，完成赋值。其中，方法使用的参数，自定义类型的值从IOC容器中获取<br>2.)如果<code>标注在有参构造器</code>上,那么Spring在启动时就会调用有参构造器，如果构造器要用到组件，那么也会从容器中获取。如果只有一个有参构造器，那么其@Autowried可以省略<br>3.)如果<code>标注在方法位置</code>:标注的方法创建对象的时候，方法参数的值从容器中获取，所以默认不写@Autowried是一样的，都能自动装配<br>如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAutowired</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(<span class="meta">@Autowried</span> Car car)</span></span>&#123; <span class="comment">//或者省略@Autowried</span></span><br><span class="line">        Color color = <span class="keyword">new</span> Color();</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注:默认加载IOC容器中的组件，会启动调用无参构造器创建对象，然后再进行初始化赋值等操作。</p>
<h2 id="自动装配-Aware注入Spring底层组件"><a href="#自动装配-Aware注入Spring底层组件" class="headerlink" title="自动装配:Aware注入Spring底层组件"></a>自动装配:Aware注入Spring底层组件</h2><p>自定义组件想要使用Spring容器底层的一些组件(如ApplicationContex  BeanFactor xxx等)，即:把Spring底层的一些组件注入到自定义的bean中进行使用.那么让自定义组件实现 xxxAware 接口.从{@link org.springframework.beans.factory.Aware} 介绍</p>
<blockquote>
<p>Marker superinterface indicating that a bean is eligible to be notified by the Spring container of a particular framework object through a callback-style method.</p>
</blockquote>
<p>可以看出,它提供了一些可以使用Spring 容器底层对象的功能。类似于回调函数的风格，Aware接口规定的方法在对象创建的时候就会被调用，注入相关组件。</p>
<p>如,实现三个Aware接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span>, <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传入的ioc&quot;</span> + applicationContext);</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext; <span class="comment">//在后面也可以使用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前bean的名字: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能够解析字符串的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">        String s = resolver.resolveStringValue(<span class="string">&quot;你好 $&#123;os.name&#125; 我是 #&#123;20*18&#125;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;解析的字符串:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationContextAware接口是用来获取applicationContext上下文:</p>
<blockquote>
<p>Interface to be implemented by any object that wishes to be notified of the {@link ApplicationContext} that it runs in.</p>
</blockquote>
<p>BeanNameAware的介绍:</p>
<blockquote>
<p>Interface to be implemented by beans that want to be aware of their bean name in a bean factory.</p>
</blockquote>
<p>EmbeddedValueResolverAware的介绍:</p>
<blockquote>
<p>Interface to be implemented by any object that wishes to be notified of a <b>StringValueResolver</b> for the <b> resolution of embedded definition values.</p>
</blockquote>
<p>EmbeddedValueResolverAware的方法中的参数StringValueResolver可以解析字符串中的值,即将<code>#&#123;&#125;</code>或者<code>$&#123;&#125;</code>的值解析</p>
<p>xxxAware的功能是使用xxxProcessor来处理的，每个都有对应的xxxProcessor.如ApplicationContextAware —&gt; ApplicationContextAwareProcessor.</p>
<h2 id="自动装配-Profile"><a href="#自动装配-Profile" class="headerlink" title="自动装配:@Profile"></a>自动装配:@Profile</h2><p>@Profile的功能:Spring提供的可以根据当前环境，动态的激活和切换一系列组件的功能。如开发环境、测试环境、生产环境用的数据库不一样，但是不同的环境不用修改代码。@Profile就是指定组件在哪个环境下才能被注册到容器中。如果不指定，则任何环境下都能注册这个组件。</p>
<p>如@Profile(“test”) @Profile(“dev”) @Profile(“prod”)</p>
<ul>
<li><p>1.加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中。默认是default环境<br>使用:</p>
<ul>
<li>1.使用命令行动态参数:在虚拟机参数位置加载-DSpring.profiles.active</li>
<li>使用代码: ①使用AnnotationConfigApplicationContext的无参构造器创建一个applicationContext对象, ②设置需要激活的环境 ③注册主配置类 ④启动刷新容器<br>如:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//1.调用AnnotationConfigApplicationContext的无参构造器</span></span><br><span class="line">      AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">      <span class="comment">//2.设置要激活的环境</span></span><br><span class="line">      applicationContext.getEnvironment().setActiveProfiles(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      <span class="comment">//3.注册主配置类</span></span><br><span class="line">      applicationContext.register(MainConfigOfProfile.class);</span><br><span class="line">      <span class="comment">//4启动刷新容器</span></span><br><span class="line">      applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">      applicationContext.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2.如果写在配置类上，那么只有是指定环境的时候，整个配置类里面的所有配置才能开始生效</p>
</li>
<li><p>3.没有标注环境标识的bean，在任何环境下都是加载的</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（一）——Hadoop相关知识</title>
    <url>/2018/04/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h2 id="Hadoop的应用现状和构成简介"><a href="#Hadoop的应用现状和构成简介" class="headerlink" title="Hadoop的应用现状和构成简介"></a>Hadoop的应用现状和构成简介</h2><p>下图为Hadoop在企业中的 应用架构</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="Hadoop在企业中的应用架构"></p>
<p>访问层不用多说，满足企业的数据分析、数据挖掘和数据实时查询功能。<br>为了满足访问层的需求，大数据层的各个技术对其进行支撑。<br>（1）离线分析：大量数据拿过来之后进行批量处理。其中MR是MapReduce的简称，Hive数据仓库和Pig也可以进行离线数据分析。<br>（2）实时查询：其中Hbase是一个可以支持几十亿行数据的非常好的分布式数据库。<br>（3）BI分析：Mahout是Hadoop平台上的一款数据挖掘应用。可以把各种数据挖掘，机器学习和商务智能的算法用MapReduce实现。否则开发人员要自己用MapReduce写决策树算法。</p>
<p>下图为一些大数据计算模式及其代表产品</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt="大数据计算模式及其代表产品"></p>
<p>下图为Hadoop项目结构</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt="Hadoop项目结构"></p>
<p>YARNz专门负责调度内存，CPU，带宽等计算资源。而上面的事完成具体的计算工作的。</p>
<p>Tez会把很多的MapReduce作业进行分析优化，构建成一个有向无环图，保证获得最好的处理效率。</p>
<p>Spark与MapReduce类似，也是进行相应的计算。但是Spark是基于内存的，而MapReduce是基于磁盘的计算。MR在计算时，先把数据写到磁盘中，然后c处理结束后再写到分布式文件系统中。所以Spark的性能要高。</p>
<p>Pig实现流数据处理，较MR属于轻量级。它也支持类似于SQL的语句。是一种轻量级的脚本语言。</p>
<p>Oozie是一个工作流管理系统，可以把一个工作分成不同的工作环节。</p>
<p>Zookeeper提供分布式协调一致性服务。</p>
<p>Hbase是一个非关系型数据库，可以支持随机读写。</p>
<p>Flume是专门负责日志收集的，分析一些实时生成的数据流。</p>
<p>Sqoopy用于在Hadoop与传统数据库之间进行数据传递（导入导出等）。可以把之前存到关系型数据库（如Oracle）中的数据导入到HDFS、Hive或者Hbase中，反之亦可。</p>
<p>Ambari是一个安装部署工具，可以在一个集群上面智能化的管理一整套Hadoop上的各个套件。</p>
<p>Hadoop各组件的功能如下：</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" alt="Hadoop组件及功能"></p>
<h2 id="Hadoop集群的节点类型"><a href="#Hadoop集群的节点类型" class="headerlink" title="Hadoop集群的节点类型"></a>Hadoop集群的节点类型</h2><p>Hadoop框架中最核心的设计是为海量数据提供存储的<code>HDFS</code>和对数据进行计算的<code>MapReduce</code></p>
<p>MapReduce的作业主要包括：<br>（1）从磁盘或从网络读取数据，即IO密集工作；<br>（2）计算数据，即CPU密集工作</p>
<p>•Hadoop集群的整体性能取决于CPU、内存、网络以及存储之间的性能平衡。因此运营团队在选择机器配置时要针对不同的工作节点选择合适硬件类型<br>•一个基本的Hadoop集群中的节点主要有:</p>
<p>•NameNode：负责协调集群中的数据存储</p>
<p>•DataNode：存储被拆分的数据块</p>
<p>•JobTracker：协调数据计算任务</p>
<p>•TaskTracker：负责执行由JobTracker指派的任务</p>
<p>•SecondaryNameNode：帮助NameNode收集文件系统运行的状态信息</p>
<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>全称：Hadoop Distributed File System.解决海量数据的分布式存储问题。</p>
<h2 id="分布式文件系统的结构"><a href="#分布式文件系统的结构" class="headerlink" title="分布式文件系统的结构"></a>分布式文件系统的结构</h2><p>分布式文件系统在物理结构上是由计算机集群中的多个节点构成的，这些节点分为两类，一类叫“主节点”(Master Node)或者也被称为“名称结点”(NameNode)，另一类叫“从节点”（Slave Node）或者也被称为“数据节点”(DataNode)</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" alt="大规模文件系统的整体结构"></p>
<p>HDFS的三个节点：Namenode，Datanode，Secondary Namenode</p>
<p>Namenode：HDFS的守护进程，用来管理文件系统的命名空间，负责记录文件是如何分割成数据块，以及这些数据块分别被存储到那些数据节点上，它的主要功能是对内存及IO进行集中管理。</p>
<p>Datanode：文件系统的工作节点，根据需要存储和检索数据块，并且定期向namenode发送他们所存储的块的列表。</p>
<p>Secondary Namenode：辅助后台程序，与NameNode进行通信，以便定期保存HDFS元数据的快照。</p>
<p>HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群包括一个名称节点（<br>NameNode）和若干个数据节点（DataNode）（如图所示）。名称节点作为中心服务器，负责管理文件系统的命名空间及客户端对文件的访问。集群中的数据节点一般是一个节点运行一个数据节点进程，负责处理文件系统客户端的读/写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作。每个数据节点的数据实际上是保存在本地Linux文件系统中的。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" alt="HDFS体系结构"><br>HDFS的缺点：</p>
<p>1.不适合低延迟的数据访问<br>2.无法高效存储大量小文件<br>3.不支持多用户写入及任意修改文件</p>
<h3 id="名称节点和数据节点"><a href="#名称节点和数据节点" class="headerlink" title="名称节点和数据节点"></a>名称节点和数据节点</h3><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" alt="HDFS主要组件的功能"></p>
<p>在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），保存了两个核心的数据结构，即FsImage和EditLog。</p>
<p>•FsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据</p>
<p>•操作日志文件EditLog中记录了所有针对文件的创建、删除、重命名等操作</p>
<p>•名称节点记录了每个文件中各个块所在的数据节点的位置信息。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" alt="名称节点的数据结构"></p>
<p>客户端在访问数据时，先通过名称节点，获取元数据信息，从而知道被访问的数据存到哪些数据节点，获得数据块具体存储位置的信息之后，客户端就会到各个机器上去获取它所需要的数据。写入操作类似，客户端先访问名称节点，一个大文件（如1TB,2TB）要怎么写，然后名称节点会告诉它，把文件分成多少块，每个块放到哪个数据节点上。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" alt="局限性"></p>
<h4 id="FsImage-文件"><a href="#FsImage-文件" class="headerlink" title="FsImage 文件"></a>FsImage 文件</h4><p>•FsImage文件包含文件系统中所有目录和文件inode的序列化形式。每个inode是一个文件或目录的元数据的内部表示，并包含此类信息：文件的复制等级、修改和访问时间、访问权限、块大小以及组成文件的块。对于目录，则存储修改时间、权限和配额元数据</p>
<p>•FsImage文件没有记录块存储在哪个数据节点。而是由名称节点把这些映射保留在内存中，当数据节点加入HDFS集群时，数据节点会把自己所包含的块列表告知给名称节点，此后会定期执行这种告知操作，以确保名称节点的块映射是最新的。</p>
<p>在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行<br>EditLog文件中的各项操作，使得内存中的元数据和实际的同步，存在内存中的元数据支持客户端的读操作。</p>
<p>•一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的EditLog文件</p>
<p>•名称节点起来之后，HDFS中的更新操作会重新写到EditLog文件中，因为FsImage文件一般都很大（GB级别的很常见），如果所有的更新操作都往FsImage文件中添加，这样会导致系统运行的十分缓慢，但是，如果往EditLog文件里面写就不会这样，因为EditLog 要小很多。每次执行写操作之后，且在向客户端发送成功代码之前，edits文件都需要同步更新</p>
<h4 id="第二名称节点"><a href="#第二名称节点" class="headerlink" title="第二名称节点"></a>第二名称节点</h4><p>第二名称节点是HDFS架构中的一个组成部分，它是用来保存名称节点中对HDFS 元<br>数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png"></p>
<p>SecondaryNameNode的工作情况：</p>
<p>（1）SecondaryNameNode会定期和NameNode通信，请求其停止使用EditLog文件，暂时将新的写操作写到一个新的文件edit.new上来，这个操作是瞬间完成，上层写日志的函数完全感觉不到差别；</p>
<p>（2）SecondaryNameNode通过HTTP GET方式从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下；</p>
<p>（3）SecondaryNameNode将下载下来的FsImage载入到内存，然后一条一条地执行EditLog文件中的各项更新操作，使得内存中的FsImage保持最新；这个过程就是EditLog和FsImage文件合并；</p>
<p>（4）SecondaryNameNode执行完（3）操作之后，会通过post方式将新的FsImage文件发送到NameNode节点上；</p>
<p>（5）NameNode将从SecondaryNameNode接收到的新的FsImage替换旧的FsImage文件，同时将edit.new替换EditLog文件，通过这个过程EditLog就变小。</p>
<h4 id="数据节点（DataNode）"><a href="#数据节点（DataNode）" class="headerlink" title="数据节点（DataNode）"></a>数据节点（DataNode）</h4><p>数据节点是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客<br>户端或者是名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表</p>
<p>•每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中</p>
<h2 id="HDFS存储原理"><a href="#HDFS存储原理" class="headerlink" title="HDFS存储原理"></a>HDFS存储原理</h2><h3 id="冗余数据保存"><a href="#冗余数据保存" class="headerlink" title="冗余数据保存"></a>冗余数据保存</h3><p>作为一个分布式文件系统，为了保证系统的容错性和可用性，HDFS采用了多副<br>本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上，数据块1被分别存放到数据节点A和C上，数据块2被存放在数据节点A和B上。这种多副本方式具有以下几个优点：<br>（1） 加快数据传输速度</p>
<p>（2） 容易检查数据错误</p>
<p>（3） 保证数据可靠性</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" alt="HDFS数据块多副本存储"></p>
<h3 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h3><h4 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h4><p>•第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点</p>
<p>•第二个副本：放置在与第一个副本不同的机架的节点上</p>
<p>•第三个副本：与第一个副本相同机架的其他节点上</p>
<p>•更多副本：随机节点</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" alt="Block的副本放置策略"></p>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>•HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API<br>获取自己所属的机架ID</p>
<p>•当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据</p>
<h3 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h3><p>HDFS具有较高的容错性，可以兼容廉价的硬件，它把硬件出错看作一种常态，<br>而不是异常，并设计了相应的机制检测数据错误和进行自动恢复，主要包括以下几种情形：名称节点出错、数据节点出错和数据出错。</p>
<h4 id="名称节点出错"><a href="#名称节点出错" class="headerlink" title="名称节点出错"></a>名称节点出错</h4><p>名称节点保存了所有的元数据信息，其中，最核心的两大数据结构是FsImage和Editlog，如果这两个文件发生损坏，那么整个HDFS实例将失效。因此，HDFS设<br>置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和<br>Editlog数据进行恢复。</p>
<h4 id="数据节点出错"><a href="#数据节点出错" class="headerlink" title="数据节点出错"></a>数据节点出错</h4><p>•每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态</p>
<p>•当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的心跳信息，这时，这些数据节点就会被标记为“宕机”，节点上面的所有数据都会被标记为“不可读”，名称节点不会再给它们发送任何I/O请求</p>
<p>•这时，有可能出现一种情形，即由于一些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子•名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本</p>
<p>•HDFS和其它分布式文件系统的最大区别就是可以调整冗余数据的位置</p>
<h4 id="数据出错"><a href="#数据出错" class="headerlink" title="数据出错"></a>数据出错</h4><p>•网络传输和磁盘错误等因素，都会造成数据错误</p>
<p>•客户端在读取到数据后，会采用md5和sha1对数据块进行校验，以确定读取到正确的数据</p>
<p>•在文件被创建时，客户端就会对每一个文件块进行信息摘录，并把这些信息写入到同一个路径的隐藏文件里面</p>
<p>•当客户端读取文件的时候，会先读取该信息文件，然后，利用该信息文件对每个读取的数据块进行校验，如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块</p>
<p>本笔记的来源源自林子雨老师的MOOC课程和课件，地址：<a href="https://www.icourse163.org/course/XMU-1002335004">https://www.icourse163.org/course/XMU-1002335004</a></p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（九）——流计算</title>
    <url>/2018/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="什么是流数据"><a href="#什么是流数据" class="headerlink" title="什么是流数据"></a>什么是流数据</h1><p>• 近年来，在Web应用、网络监控、传感监测等领域，兴起了一种新的数据密集型应用——流数据，即数据以大量、快速、时变的流形式持续到达<br>• 实例：PM2.5检测、电子商务网站用户点击流<br>• 流数据具有如下特征：<br>– 数据快速持续到达，潜在大小也许是无穷无尽的<br>– 数据来源众多，格式复杂<br>– 数据量大，但是不十分关注存储，一旦经过处理，要么被丢弃，要么被归档存储<br>– 注重数据的整体价值，不过分关注个别数据<br>– 数据顺序颠倒，或者不完整，系统无法控制将要处理的新到达的数据元素的顺序<br>• 对静态数据和流数据的处理，对应着两种截然不同的计算模式：批量计算和实时计算<br>•批量计算：充裕时间处理静态数据，如Hadoop<br>•流数据不适合采用批量计算，因为流数据不适合用传统的关系模型建模<br>•流数据必须采用实时计算，响应时间为秒级<br>•在大数据时代，数据格式复杂、来源众多、数据量巨大，对实时计算提出了很大的挑战。因此，针对流数据的实时计算——流计算，应运而生</p>
<h1 id="流计算的概念"><a href="#流计算的概念" class="headerlink" title="流计算的概念"></a>流计算的概念</h1><p>• 流计算秉承一个基本理念，即 数据的价值随着时间的流逝而降低，如用户点击流。因此，当事件出现时就应该立即进行处理，而不是缓存起来进行批量处理。为了及时处理流数据，就需要一个低延迟、可扩展、高可靠的处理引擎<br>• 对于一个流计算系统来说，它应达到如下需求：<br>– 高性能<br>– 海量式<br>– 实时性<br>– 分布式<br>– 易用性<br>– 可靠性</p>
<h1 id="流计算与Hadoop"><a href="#流计算与Hadoop" class="headerlink" title="流计算与Hadoop"></a>流计算与Hadoop</h1><p>• Hadoop设计的初衷是面向大规模数据的批量处理<br>• MapReduce是专门面向静态数据的批量处理的，内部各种实现机制都为批处理做了高度优化，不适合用于处理持续到达的动态数据• 可能会想到一种“变通”的方案来降低批处理的时间延迟——将基于MapReduce的批量处理转为小批量处理，将输入数据切成小的片段，每隔一个周期就启动一次MapReduce作业。但这种方式也无法有效处理流数据<br>– 切分成小片段，可以降低延迟，但是也增加了附加开销，还要处理片段之间依赖关系<br>– 需要改造MapReduce以支持流式处理<br>结论：鱼和熊掌不可兼得，Hadoop擅长批处理，但是不适合流计算<br>• 当前业界诞生了许多专门的流数据实时计算系统来满足各自需求：<br>• 商业级：IBM InfoSphere Streams和IBM StreamBase<br>• 开源流计算框架：<br>– Twitter Storm：免费、开源的分布式实时计算系统，可简单、高效、可靠地处理大量的流数据<br>– Yahoo! S4（Simple Scalable Streaming System）：开源流计算平台，是通用的、分布式的、可扩展的、分区容错的、可插拔的流式系统<br>• 公司为支持自身业务开发的流计算框架：<br>– Facebook Puma<br>– Dstream（百度）<br>– 银河流数据处理平台（淘宝）</p>
<h1 id="流计算处理流程"><a href="#流计算处理流程" class="headerlink" title="流计算处理流程"></a>流计算处理流程</h1><p>• 传统的数据处理流程，需要先采集数据并存储在关系数据库等数据管理系统中，之后由用户通过查询操作和数据管理系统进行交互<br>• 传统的数据处理流程隐含了两个前提：<br>–  存储的数据是旧的。存储的静态数据是过去某一时刻的快照，这些数据在查询时可能已不具备时效性了<br>–  需要用户主动发出查询</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/1.png" alt="传统的数据处理流程"></p>
<p>• 流计算的处理流程一般包含三个阶段：数据实时采集、数据实时计算、实时查询服务</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/2.png" alt="流计算处理流程示意图"></p>
<h2 id="数据实时采集"><a href="#数据实时采集" class="headerlink" title="数据实时采集"></a>数据实时采集</h2><p>• 数据实时采集阶段通常采集多个数据源的海量数据，需要保证实时性、低延迟与稳定可靠<br>• 以日志数据为例，由于分布式集群的广泛应用，数据分散存储在不同的机器上，因此需要实时汇总来自不同机器上的日志数据<br>• 目前有许多互联网公司发布的开源分布式日志采集系统均可满足每秒数百MB的数据采集和传输需求，如：</p>
<p>– <code>Facebook的Scribe</code></p>
<p>– <code>LinkedIn的Kafka</code></p>
<p>– <code>淘宝的Time Tunnel</code></p>
<p>– <code>基于Hadoop的Chukwa和Flume</code></p>
<p>• 数据采集系统的基本架构一般有以下三个部分：<br>– Agent：主动采集数据，并把数据推送到Collector部分<br>– Collector：接收多个Agent的数据，并实现有序、可靠、高性能的转发<br>– Store：存储Collector转发过来的数据（对于流计算不存储数据）</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/3.png" alt="数据采集系统基本架构"></p>
<h2 id="数据实时计算"><a href="#数据实时计算" class="headerlink" title="数据实时计算"></a>数据实时计算</h2><p>• 数据实时计算阶段对采集的数据进行实时的分析和计算，并反馈实时结果<br>• 经流处理系统处理后的数据，可视情况进行存储，以便之后再进行分析计算。在时效性要求较高的场景中，处理之后的数据也可以直接丢弃</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/4.png" alt="数据实时计算流程"></p>
<h2 id="实时查询服务"><a href="#实时查询服务" class="headerlink" title="实时查询服务"></a>实时查询服务</h2><p>• 实时查询服务：经由流计算框架得出的结果可供用户进行实时查询、展示或储存<br>• 传统的数据处理流程，用户需要主动发出查询才能获得想要的结果。而在流处理流程中，实时查询服务可以不断更新结果，并将用户所需的结果实时推送给用户<br>• 虽然通过对传统的数据处理系统进行定时查询，也可以实现不断地更新结果和结果推送，但通过这样的方式获取的结果，仍然是根据过去某一时刻的数据得到的结果，与实时结果有着本质的区别<br>• 可见，流处理系统与传统的数据处理系统有如下不同：<br>– 流处理系统处理的是实时的数据，而传统的数据处理系统处理的是预先存储好的静态数据<br>– 用户通过流处理系统获取的是实时结果，而通过传统的数据处理系统，获取的是过去某一时刻的结果<br>– 流处理系统无需用户主动发出查询，实时查询服务可以主动将实时结果推送给用户</p>
<h1 id="开源流计算框架Storm"><a href="#开源流计算框架Storm" class="headerlink" title="开源流计算框架Storm"></a>开源流计算框架Storm</h1><p>• Twitter Storm是一个免费、开源的分布式实时计算系统，Storm对于实时计算的意义类似于Hadoop对于批处理的意义，Storm可以简单、高效、可靠地处理流数据，并支持多种编程语言</p>
<p>• Storm框架可以方便地与数据库系统进行整合，从而开发出强大的实时计算系统</p>
<p>• Twitter是全球访问量最大的社交网站之一，Twitter开发Storm流处理框架也是为了应对其不断增长的流数据实时处理需求</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/5.png"></p>
<h2 id="Storm的特点"><a href="#Storm的特点" class="headerlink" title="Storm的特点"></a>Storm的特点</h2><p>• Storm可用于许多领域中，如实时分析、在线机器学习、持续计算、远程RPC、数据提取加载转换等</p>
<p>• Storm具有以下主要特点：<br>– 整合性<br>– 简易的API<br>– 可扩展性<br>– 可靠的消息处理<br>– 支持各种编程语言<br>– 快速部署<br>– 免费、开源</p>
<h2 id="Storm设计思想"><a href="#Storm设计思想" class="headerlink" title="Storm设计思想"></a>Storm设计思想</h2><p>• Storm主要术语包括Streams、Spouts、Bolts、Topology和Stream Groupings</p>
<p>• <code>Streams</code> ：Storm将流数据Stream描述成一个无限的Tuple序列，这些Tuple序列会以分布式的方式并行地创建和处理</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/6.png"></p>
<p>•每个tuple是一堆值，每个值有一个名字，并且每个值可以是任何类型<br>•Tuple本来应该是一个Key-Value的Map，由于各个组件间传递的tuple的字段名称已经事先定义好了，所以Tuple只需要按序填入各个Value，所以就是一个Value List（值列表）</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/7.png"></p>
<p>• <code>Spout</code>：Storm认为每个Stream都有一个源头，并把这个源头抽象为Spout</p>
<p>• 通常Spout会从外部数据源（队列、数据库等）读取数据，然后封装成Tuple形式，发送到Stream中。Spout是一个主动的角色，在接口内部有个nextTuple函，Storm框架会不停的调用该函数</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/8.png"></p>
<p>• <code>Bolt</code> ：Storm将Streams的状态转换过程抽象为Bolt。Bolt即可以处理Tuple，也可以将处理后的Tuple作为新的Streams发送给其他Bolt</p>
<p>• Bolt可以执行过滤、函数操作、Join、操作数据库等任何操作<br>• Bolt是一个被动的角色，其接口中有一个execute(Tuple input)方法，在接收到消息之后会调用此函数，用户可以在此方法中执行自己的处理逻辑</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/9.png"></p>
<p>• <code>Topology</code> ：Storm将Spouts和Bolts组成的网络抽象成Topology，它可以被提交到Storm集群执行。Topology可视为流转换图，图中节点是一个Spout或<br>Bolt，边则表示Bolt订阅了哪个Stream。当Spout或者Bolt发送元组时，它会把元组发送到每个订阅了该Stream的Bolt上进行处理<br>• Topology里面的每个处理组件（Spout或Bolt）都包含处理逻辑， 而组件之间的连接则表示数据流动的方向<br>• Topology里面的每一个组件都是并行运行的<br>•在Topology里面可以指定每个组件的并行度，Storm会在集群里面分配那么多的线程来同时计算<br>•在Topology的具体实现上，Storm中的Topology定义仅仅是一些Thrift结构体（二进制高性能的通信中间件），支持各种编程语言进行定义</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/10.png"></p>
<p>• <code>Stream Groupings</code> ：Storm中的Stream Groupings用于告知Topology如何在两个组件间（如Spout和Bolt之间，或者不同的Bolt之间）进行Tuple的传送。每一个Spout和Bolt都可以有多个分布式任务，一个任务在什么时候、以什么方式发送Tuple就是由Stream Groupings来决定的</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/11.png"></p>
<p>目前，Storm中的Stream Groupings有如下几种方式：</p>
<p>(1)ShuffleGrouping：随机分组，随机分发Stream中的Tuple，保证每个Bolt的Task接收Tuple数量大致一致<br>(2)FieldsGrouping：按照字段分组，保证相同字段的Tuple分配到同一个Task中<br>(3)AllGrouping：广播发送，每一个Task都会收到所有的Tuple<br>(4)GlobalGrouping：全局分组，所有的Tuple都发送到同一个Task中<br>(5)NonGrouping：不分组，和ShuffleGrouping类似，当前Task的执行会和它的被订阅者在同一个线程中执行<br>(6)DirectGrouping：直接分组，直接指定由某个Task来执行Tuple的处理</p>
<h2 id="Storm框架设计"><a href="#Storm框架设计" class="headerlink" title="Storm框架设计"></a>Storm框架设计</h2><p>•Storm运行任务的方式与Hadoop类似：Hadoop运行的是MapReduce作业，而Storm运行的是“Topology”<br>•但两者的任务大不相同，主要的不同是：MapReduce作业最终会完成计算并结束运行，而Topology将持续处理消息（直到人为终止）</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/12.png"></p>
<p>• Storm集群采用“Master—Worker”的节点方式：<br>– Master节点运行名为“Nimbus”的后台程序（类似Hadoop中的“JobTracker”），负责在集群范围内分发代码、为Worker分配任务和监测故障<br>– Worker节点运行名为“Supervisor”的后台程序，负责监听分配给它所在机器的工作，即根据Nimbus分配的任务来决定启动或停止Worker进程，一个Worker节点上同时运行若干个Worker进程<br>• Storm使用Zookeeper来作为分布式协调组件，负责Nimbus和多个Supervisor之间的所有协调工作。借助于Zookeeper，若Nimbus进程或Supervisor进程意外终止，重启时也能读取、恢复之前的状态并继续工作，使得Storm极其稳定</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/13.png" alt="Storm集群架构示意图"></p>
<p><code>worker进程</code></p>
<p>(1)Worker进程:每个worker进程都属于一个特定的Topology，每个Supervisor节点的worker可以有多个，每个worker对Topology中的每个组件（Spout或Bolt）运行一个或者多个executor线程来提供task的运行服务<br>(2)Executor：executor是产生于worker进程内部的线程，会执行同一个组件的一个或者多个task。<br>(3)Task:实际的数据处理由task完成Worker、Executor和Task的关系</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/14.png" alt="Worker、Executor和Task的关系"></p>
<p>• 基于这样的架构设计，Storm的工作流程如下图所示：<br>•所有Topology任务的提交必须在Storm客户端节点上进行，提交后，由Nimbus节点分配给其他Supervisor节点进行处理<br>•Nimbus节点首先将提交的Topology进行分片，分成一个个Task，分配给相应的Supervisor，并将Task和Supervisor相关的信息提交到Zookeeper集群上<br>•Supervisor会去Zookeeper集群上认领自己的Task，通知自己的Worker进程进行Task的处理</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/15.png" alt="Storm工作流程示意图"></p>
<h1 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h1><h2 id="Spark-Streaming设计"><a href="#Spark-Streaming设计" class="headerlink" title="Spark Streaming设计"></a>Spark Streaming设计</h2><p>•Spark Streaming可整合多种输入数据源，如Kafka、Flume、HDFS，甚至是普通的TCP套接字。经处理后的数据可存储至文件系统、数据库，或显示在仪表盘里</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/16.png" alt="Spark Streaming支持的输入、输出数据源"></p>
<p>Spark Streaming的基本原理是将实时输入数据流以时间片（秒级）为单位进行拆分，然后经Spark引擎以类似批处理的方式处理每个时间片数据</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/17.png" alt="Spark Streaming执行流程"></p>
<p>Spark Streaming最主要的抽象是DStream（Discretized Stream，离散化数据流），表示连续不断的数据流。在内部实现上，Spark Streaming的输入数据按照时间片（如1秒）分成一段一段的DStream，每一段数据转换为Spark中的RDD，并且对DStream的操作都最终转变为对相应的RDD的操作</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/18.png" alt="DStream操作示意图"></p>
<h2 id="Spark-Streaming与Storm的对比"><a href="#Spark-Streaming与Storm的对比" class="headerlink" title="Spark Streaming与Storm的对比"></a>Spark Streaming与Storm的对比</h2><p>•Spark Streaming和Storm最大的区别在于，Spark Streaming无法实现毫秒级的流计算，而Storm可以实现毫秒级响应</p>
<p>•Spark Streaming构建在Spark上，一方面是因为Spark的低延迟执行引擎（100ms+）可以用于实时计算，另一方面，相比于Storm，RDD数据集更容易做高效的容错处理</p>
<p>•Spark Streaming采用的小批量处理的方式使得它可以同时兼容批量和实时数据处理的逻辑和算法，因此，方便了一些需要历史数据和实时数据联合分析的特定应用场合</p>
<h1 id="Samza"><a href="#Samza" class="headerlink" title="Samza"></a>Samza</h1><p>1.作业</p>
<p>一个作业（Job）是对一组输入流进行处理转化成输出流的程序。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/19.png"></p>
<p>2.分区</p>
<p>•Samza的流数据单位既不是Storm中的元组，也不是Spark Streaming中的DStream，而是一条条消息<br>•Samza中的每个流都被分割成一个或多个分区，对于流里的每一个分区而言，都是一个有序的消息序列，后续到达的消息会根据一定规则被追加到其中一个分区里</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/20.png"></p>
<p>3.任务</p>
<p>•一个作业会被进一步分割成多个任务（Task）来执行，其中，每个任务负责处理作业中的一个分区<br>•分区之间没有定义顺序，从而允许每一个任务独立执行<br>•YARN调度器负责把任务分发给各个机器，最终，一个工作中的多个任务会被分发到多个机器进行分布式并行处理</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/21.png"></p>
<p>4.数据流图</p>
<p>•一个数据流图是由多个作业构成的，其中，图中的每个节点表示包含数据的流，每条边表示数据传输<br>•多个作业串联起来就完成了流式的数据处理流程<br>•由于采用了异步的消息订阅分发机制，不同任务之间可以独立运行</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/22.png"></p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>•Samza系统架构主要包括<br>•流数据层（Kafka）<br>•执行层（YARN）<br>•处理层（Samza API）<br>•流处理层和执行层都被设计成可插拔的，开发人员可以使用其他框架来替代YARN和Kafka</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/24.png"></p>
<p>处理分析过程如下：</p>
<p>•Samza客户端需要执行一个Samza作业时，它会向YARN的ResouceManager提交作业请求</p>
<p>•ResouceManager通过与NodeManager沟通为该作业分配容器（包含了CPU、内存等资源）来运行Samza ApplicationMaster</p>
<p>•Samza ApplicationMaster进一步向ResourceManager申请运行任务的容器</p>
<p>•获得容器后，Samza ApplicationMaster与容器所在的NodeManager沟通，启动该容器，并在其中运行Samza Task Runner</p>
<p>•Samza Task Runner负责执行具体的Samza任务，完成流数据处理分析</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%B5%81%E8%AE%A1%E7%AE%97/25.png"></p>
<h1 id="Storm、Spark-Streaming和Samza的应用场景"><a href="#Storm、Spark-Streaming和Samza的应用场景" class="headerlink" title="Storm、Spark Streaming和Samza的应用场景"></a>Storm、Spark Streaming和Samza的应用场景</h1><p>•从编程的灵活性来讲，Storm是比较理想的选择，它使用Apache Thrift，可以用任何编程语言来编写拓扑结构（Topology）</p>
<p>•当需要在一个集群中把流计算和图计算、机器学习、SQL查询分析等进行结合时，可以选择Spark Streaming，因为，在Spark上可以统一部署Spark SQL，Spark Streaming、MLlib，GraphX等组件，提供便捷的一体化编程模型</p>
<p>•当有大量的状态需要处理时，比如每个分区都有数十亿个元组，则可以选择Samza。当应用场景需要毫秒级响应时，可以选择Storm和Samza，因为Spark Streaming无法实现毫秒级的流计算</p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（七）——数据仓库Hive</title>
    <url>/2018/05/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/</url>
    <content><![CDATA[<h1 id="数据仓库概念"><a href="#数据仓库概念" class="headerlink" title="数据仓库概念"></a>数据仓库概念</h1><p>数据仓库（Data Warehouse）是一个面向主题的（Subject Oriented）、集成<br>的（Integrated）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/1.png" alt="数据仓库的体系结构"></p>
<h1 id="Hive简介"><a href="#Hive简介" class="headerlink" title="Hive简介"></a>Hive简介</h1><p>•Hive是一个构建于Hadoop顶层的数据仓库工具</p>
<p>•支持大规模数据存储、分析，具有良好的可扩展性</p>
<p>•某种程度上可以看作是用户编程接口，本身不存储和处理数据</p>
<p>•依赖分布式文件系统HDFS存储数据</p>
<p>•依赖分布式并行计算模型MapReduce处理数据</p>
<p>•定义了简单的类似SQL 的查询语言——HiveQL</p>
<p>•用户可以通过编写的HiveQL语句运行MapReduce任务</p>
<p>•可以很容易把原来构建在关系数据库上的数据仓库应用程序移植到Hadoop平台上</p>
<p>•是一个可以提供有效、合理、直观组织和使用数据的分析工具</p>
<p>Hive具有的特点非常适用于数据仓库</p>
<p>1 采用批处理方式处理海量数据</p>
<p>•Hive需要把HiveQL语句转换成MapReduce任务进行运行</p>
<p>•数据仓库存储的是静态数据，对静态数据的分析适合采用批处理方式，不需要快速响应给出结果，而且数据本身也不会频繁变化</p>
<p>2 提供适合数据仓库操作的工具</p>
<p>•Hive本身提供了一系列对数据进行提取、转换、加载（ETL）的工具，可以存储、查询和分析存储在Hadoop中的大规模数据</p>
<p>•这些工具能够很好地满足数据仓库各种应用场景</p>
<h1 id="Hive与Hadoop生态系统中其他组件的关系"><a href="#Hive与Hadoop生态系统中其他组件的关系" class="headerlink" title="Hive与Hadoop生态系统中其他组件的关系"></a>Hive与Hadoop生态系统中其他组件的关系</h1><p>•Hive 依赖于HDFS  存储数据</p>
<p>•Hive 依赖于MapReduce  处理数据</p>
<p>• 在某些场景下Pig 可以作为Hive 的替代工具</p>
<p>•HBase 提供数据的实时访问</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/2.png" alt="Hive与Hadoop生态系统中其他组件的关系"></p>
<h1 id="Hive-与传统数据库的对比分析"><a href="#Hive-与传统数据库的对比分析" class="headerlink" title="Hive 与传统数据库的对比分析"></a>Hive 与传统数据库的对比分析</h1><p>Hive在很多方面和传统的关系数据库类似，但是它的底层依赖的是HDFS和MapReduce，所以在很多方面又有别于传统数据库</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/3.png" alt="Hive 与传统数据库的对比分析"></p>
<h1 id="Hive-在企业中的部署和应用"><a href="#Hive-在企业中的部署和应用" class="headerlink" title="Hive 在企业中的部署和应用"></a>Hive 在企业中的部署和应用</h1><ol>
<li>Hive在企业大数据分析平台中的应用</li>
</ol>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/4.png" alt="Hive 在企业中的部署和应用"></p>
<ol start="2">
<li>Hive 在Facebook 公司中的应用</li>
</ol>
<p>•基于Oracle的数据仓库系统已经无法满足激增的业务需求</p>
<p>•Facebook公司开发了数据仓库工具Hive，并在企业内部进行了大量部署</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/5.png" alt="Hive 在Facebook 公司中的应用"></p>
<h1 id="Hive系统架构"><a href="#Hive系统架构" class="headerlink" title="Hive系统架构"></a>Hive系统架构</h1><p>•用户接口模块包括CLI、HWI、JDBC、ODBC、Thrift Server</p>
<p>•驱动模块（Driver）包括编译器、优化器、执行器等，负责把HiveSQL语句转换成一系列MapReduce作业</p>
<p>•元数据存储模块（Metastore）是一个独立的关系型数据库（自带derby数据库，或MySQL数据库）</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/6.png" alt="Hive系统架构"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/7.png" alt="Hive对外访问接口"></p>
<h1 id="Hive-HA基本原理"><a href="#Hive-HA基本原理" class="headerlink" title="Hive HA基本原理"></a>Hive HA基本原理</h1><p>问题：在实际应用中，Hive也暴露出不稳定的问题</p>
<p>解决方案：Hive HA（High Availability）</p>
<p>•由多个Hive实例进行管理的，这些Hive实例被纳入到一个资源池中，并由HAProxy提供一个统一的对外接口</p>
<p>•对于程序开发人员来说，可以把它认为是一台超强“Hive”</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/8.png" alt="Hive HA基本原理"></p>
<h1 id="Hive工作原理"><a href="#Hive工作原理" class="headerlink" title="Hive工作原理"></a>Hive工作原理</h1><h2 id="SQL语句转换成MapReduce作业的基本原理"><a href="#SQL语句转换成MapReduce作业的基本原理" class="headerlink" title="SQL语句转换成MapReduce作业的基本原理"></a>SQL语句转换成MapReduce作业的基本原理</h2><ol>
<li>join的实现原理</li>
</ol>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/9.png" alt="join的实现原理"></p>
<ol start="2">
<li>group by 的实现原理</li>
</ol>
<p>存在一个分组（Group By）操作，其功能是把表Score的不同片段按照rank和<br>level的组合值进行合并，计算不同rank和level的组合值分别有几条记录：<br>select rank, level ,count(*) as value from score group by rank, level</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/10.png" alt="group by 的实现原理"></p>
<h2 id="Hive中SQL查询转换成MapReduce作业的过程"><a href="#Hive中SQL查询转换成MapReduce作业的过程" class="headerlink" title="Hive中SQL查询转换成MapReduce作业的过程"></a>Hive中SQL查询转换成MapReduce作业的过程</h2><p>•当用户向Hive输入一段命令或查询时，Hive需要与Hadoop交互工作来完成该操作：</p>
<p>•驱动模块接收该命令或查询编译器</p>
<p>•对该命令或查询进行解析编译</p>
<p>•由优化器对该命令或查询进行优化计算</p>
<p>•该命令或查询通过执行器进行执行</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/11.png" alt="Hive中SQL查询转换成MapReduce作业的过程"></p>
<p>第1步：由Hive驱动模块中的编译器对用户输入的SQL语言进行词法和语法解析，将SQL语句转化为抽象语法树的形式</p>
<p>第2步：抽象语法树的结构仍很复杂，不方便直接翻译为MapReduce算法程序，因此，把抽象语法书转化为查询块</p>
<p>第3步：把查询块转换成逻辑查询计划，里面包含了许多逻辑操作符</p>
<p>第4步：重写逻辑查询计划，进行优化，合并多余操作，减少MapReduce任务数量</p>
<p>第5步：将逻辑操作符转换成需要执行的具体MapReduce任务</p>
<p>第6步：对生成的MapReduce任务进行优化，生成最终的MapReduce任务执行计划</p>
<p>第7步：由Hive驱动模块中的执行器，对最终的MapReduce任务进行执行输出</p>
<p>几点说明：</p>
<p>• 当启动MapReduce程序时，Hive本身是不会生成MapReduce算法程序的</p>
<p>• 需要通过一个表示“Job执行计划”的XML文件驱动执行内置的、原生的Mapper和Reducer模块</p>
<p>• Hive通过和JobTracker通信来初始化MapReduce任务，不必直接部署在JobTracker所在的管理节点上执行</p>
<p>• 通常在大型集群上，会有专门的网关机来部署Hive工具。网关机的作用主要是远程操作和管理节点上的JobTracker通信来执行任务</p>
<p>• 数据文件通常存储在HDFS上，HDFS由名称节点管理</p>
<h1 id="Impala"><a href="#Impala" class="headerlink" title="Impala"></a>Impala</h1><h2 id="Impala简介"><a href="#Impala简介" class="headerlink" title="Impala简介"></a>Impala简介</h2><p>• Impala是由Cloudera公司开发的新型查询系统，它提供SQL语义，能查询存储在Hadoop的HDFS和HBase上的PB级大数据，在性能上比Hive高出3~30倍</p>
<p>• Impala的运行需要依赖于Hive的元数据</p>
<p>• Impala是参照 Dremel系统进行设计的</p>
<p>• Impala采用了与商用并行关系数据库类似的分布式查询引擎，可以直接与HDFS和HBase进行交互查询</p>
<p>• Impala和Hive采用相同的SQL语法、ODBC驱动程序和用户接口</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/12.png" alt="Impala简介"></p>
<h2 id="Impala系统架构"><a href="#Impala系统架构" class="headerlink" title="Impala系统架构"></a>Impala系统架构</h2><p>Impala和Hive、HDFS、HBase等工具是统一部署在一个Hadoop平台上的Impala主要由Impalad，State Store和CLI三部分组成</p>
<p>图中虚线组件是Impala的组件<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/13.png" alt="Impala系统架构"></p>
<p>Impala主要由Impalad，State Store和CLI三部分组成</p>
<ol>
<li>Impalad</li>
</ol>
<p>• 负责协调客户端提交的查询的执行</p>
<p>• 包含Query Planner、Query Coordinator和Query Exec Engine三个模块</p>
<p>• 与HDFS的数据节点（HDFS DN）运行在同一节点上</p>
<p>• 给其他Impalad分配任务以及收集其他Impalad的执行结果进行汇总</p>
<p>• Impalad也会执行其他Impalad给其分配的任务，主要就是对本地HDFS和HBase里的部分数据进行操作</p>
<ol start="2">
<li>State Store</li>
</ol>
<p>• 会创建一个statestored进程</p>
<p>• 负责收集分布在集群中各个Impalad进程的资源信息，用于查询调度</p>
<ol start="3">
<li>CLI</li>
</ol>
<p>• 给用户提供查询使用的命令行工具</p>
<p>• 还提供了Hue、JDBC及ODBC的使用接口</p>
<p>说明：Impala中的元数据直接存储在Hive中。Impala采用与Hive相同的元数据、SQL语法、ODBC驱动程序和用户接口，从而使得在一个Hadoop平台上，可以统一部署Hive和Impala等分析工具，同时支持批处理和实时查询</p>
<h2 id="Impala查询执行过程"><a href="#Impala查询执行过程" class="headerlink" title="Impala查询执行过程"></a>Impala查询执行过程</h2><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/14.png" alt="Impala查询执行过程"></p>
<p>Impala执行查询的具体过程：</p>
<p>• 第0步，当用户提交查询前，Impala先创建一个负责协调客户端提交的查询的Impalad进程，该进程会向Impala State Store提交注册订阅信息，State Store会创建一个statestored进程，statestored进程通过创建多个线程来处理Impalad的注册订阅信息。</p>
<p>• 第1步，用户通过CLI客户端提交一个查询到impalad进程，Impalad的Query Planner对SQL语句进行解析，生成解析树；然后，Planner把这个查询的解析树变成若干PlanFragment，发送到Query Coordinator</p>
<p>• 第2步，Coordinator通过从MySQL元数据库中获取元数据，从HDFS的名称节点中获取数据地址，以得到存储这个查询相关数据的所有数据节点。</p>
<p>• 第3步，Coordinator初始化相应impalad上的任务执行，即把查询任务分配给所有存储这个查询相关数据的数据节点。</p>
<p>• 第4步，Query Executor通过流式交换中间输出，并由Query Coordinator汇聚来自各个impalad的结果。</p>
<p>• 第5步，Coordinator把汇总后的结果返回给CLI客户端。</p>
<h1 id="Impala与Hive的比较"><a href="#Impala与Hive的比较" class="headerlink" title="Impala与Hive的比较"></a>Impala与Hive的比较</h1><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93Hive/15.png" alt="Impala与Hive的比较"></p>
<p>Hive与Impala的 不同点总结如下：</p>
<ol>
<li><p>Hive适合于长时间的批处理查询分析，而Impala适合于实时交互式SQL查询</p>
</li>
<li><p>Hive依赖于MapReduce计算框架，Impala把执行计划表现为一棵完整的执行计划树，直接分发执行计划到各个Impalad执行查询</p>
</li>
<li><p>Hive在执行过程中，如果内存放不下所有数据，则会使用外存，以保证查询能顺序执行完成，而Impala在遇到内存放不下数据时，不会利用外存，所以Impala目前处理查询时会受到一定的限制</p>
</li>
</ol>
<p>Hive与Impala的 相同点总结如下：</p>
<ol>
<li><p>Hive与Impala使用相同的存储数据池，都支持把数据存储于HDFS和HBase中</p>
</li>
<li><p>Hive与Impala使用相同的元数据</p>
</li>
<li><p>Hive与Impala中对SQL的解释处理比较相似，都是通过词法分析生成执行计划</p>
</li>
</ol>
<p>总结</p>
<p>•Impala的目的不在于替换现有的MapReduce工具</p>
<p>•把Hive与Impala配合使用效果最佳</p>
<p>•可以先使用Hive进行数据转换处理，之后再使用Impala在Hive处理后的结果数据集上进行快速的数据分析</p>
<p>转自林子雨老师的公开课  视频地址：<a href="http://www.icourse163.org/learn/XMU-1002335004#/learn/content?type=detail&amp;id=1003836807&amp;cid=1004616536&amp;replay=true">http://www.icourse163.org/learn/XMU-1002335004#/learn/content?type=detail&amp;id=1003836807&amp;cid=1004616536&amp;replay=true</a></p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（三）——HBase相关知识（二）</title>
    <url>/2018/04/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="HBase功能组件"><a href="#HBase功能组件" class="headerlink" title="HBase功能组件"></a>HBase功能组件</h1><p>• HBase的实现包括三个主要的功能组件：<br>– （1）库函数：链接到每个客户端<br>– （2）一个Master主服务器（充当管家的作用）<br>– （3）许多个Region服务器</p>
<p>• 主服务器Master负责管理和维护HBase表的分区信息，维护Region服务器列表，分配Region，负载均衡</p>
<p>• 一个大的表会被分成很多个Region，Region服务器负责存储和维护分配给自己的Region，处理来自客户端的读写请求</p>
<p>• 客户端并不是直接从Master主服务器上读取数据，而是在获得Region的存储位置信息后，直接从Region服务器上读取数据</p>
<p>• 客户端并不依赖Master，而是通过Zookeeper来获得Region位置信息，大多数客户端甚至从来不和Master通信，这种设计方式使得Master负载很小</p>
<h2 id="表和Region"><a href="#表和Region" class="headerlink" title="表和Region"></a>表和Region</h2><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" alt="一个HBase表被划分成多个Region"></p>
<p>•开始只有一个Region，后来不断分裂</p>
<p>•Region拆分操作非常快，接近瞬间，因为拆分之后的Region读取的仍然是原存储文件，直到“合并”过程把存储文件异步地写到独立的文件之后，才会读取新文件</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" alt="一个Region会分裂成多个新的Region"></p>
<p>这种拆分只是逻辑上的拆分，只是数据的指向发生了变化，它的实际存储还是在原来的旧的Region中的数据。<br>当读新的Region时，后台会有一个合并操作，会把拆分的数据进行重新操作，最终会写到新的文件中去。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" alt="不同的Region可以分布在不同的Region服务器上"></p>
<p>一个Region只能存到一个Region服务器上。</p>
<h2 id="Region的定位"><a href="#Region的定位" class="headerlink" title="Region的定位"></a>Region的定位</h2><p>那么有一个问题，当一个Region被拆成很多个Region时，这些Region会把它打散，分布到不同的地方存储，那么怎么知道它被存到哪里去了呢？</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" alt="映射表"></p>
<p>•元数据表，又名.META.表，存储了Region和Region服务器的映射关系</p>
<p>•当HBase表很大时， .META.表也会被分裂成多个Region</p>
<p>•根数据表，又名-ROOT-表，记录所有元数据的具体位置</p>
<p>•-ROOT-表只有唯一一个Region，名字是在程序中被写死的</p>
<p>•Zookeeper文件记录了-ROOT-表的位置</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" alt="HBase的三层结构"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" alt="HBase的三层结构中各层次的名称和作用"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" alt="Region定位"></p>
<p>•一个-ROOT-表最多只能有一个Region，也就是最多只能有128MB，按照每行（一个映射条目）占用1KB内存计算，128MB空间可以容纳128MB/1KB=2^17 行，也就是说，一个-ROOT-表可以寻址2^17 个.META.表的Region。</p>
<p>•同理，每个.META.表的 Region可以寻址的用户数据表的Region个数是128MB/1KB=2^17 。</p>
<p>•最终，三层结构可以保存的Region数目是(128MB/1KB) × (128MB/1KB) = 2^34 个Region</p>
<p>所以三层架构能够满足企业的需求。</p>
<p>客户端访问数据时的“三级寻址”<br>•为了加速寻址，客户端会缓存位置信息，同时，需要解决缓存失效问题</p>
<p>•寻址过程客户端只需要询问Zookeeper服务器，不需要连接Master服务器</p>
<p>这里的缓存机制采用的是惰性缓存，如果在使用缓存获取数据时，获取不到数据，那么就失效了，这时候再次进行三级寻址过程，以解决缓存失效问题。</p>
<h1 id="HBase运行机制"><a href="#HBase运行机制" class="headerlink" title="HBase运行机制"></a>HBase运行机制</h1><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" alt="HBase的系统架构"></p>
<p>• 1. 客户端<br>– 客户端包含访问HBase的接口，同时在缓存中维护着已经访问过的Region位置信息，用来加快后续数据访问过程</p>
<p>• 2. Zookeeper服务器<br>– Zookeeper可以帮助选举出一个Master作为集群的总管，并保证在任何时刻总有唯一一个Master在运行，这就避免了Master的“单点失效”问题Zookeeper是一个很好的集群管理工具，被大量用于分布式计算，提供配置维护、域名服务、分布式同步、组服务等。提供管家的功能，维护整个HBase集群。虽然有很多备用的Master，但是它保证只有一个Master是运行的。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" alt="ZooKeeper"></p>
<p>• 3. Master<br>• 主服务器Master主要负责表和Region的管理工作：<br>– 管理用户对表的增加、删除、修改、查询等操作<br>– 实现不同Region服务器之间的负载均衡<br>– 在Region分裂或合并后，负责重新调整Region的分布<br>– 对发生故障失效的Region服务器上的Region进行迁移</p>
<p>• 4. Region服务器<br>– Region服务器是HBase中最核心的模块，负责维护分配给自己的Region，并响应用户的读写请求</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" alt="Region服务器向HDFS文件系统中读写数据"></p>
<h2 id="Region服务器工作原理"><a href="#Region服务器工作原理" class="headerlink" title="Region服务器工作原理"></a>Region服务器工作原理</h2><p>1.用户读写数据过程</p>
<p>•用户写入数据时，被分配到相应Region服务器去执行</p>
<p>•用户数据首先被写入到MemStore和Hlog中</p>
<p>•只有当操作写入Hlog之后，commit()调用才会将其返回给客户端</p>
<p>•当用户读取数据时，Region服务器会首先访问MemStore缓存，如果找不到，再去磁盘上面的StoreFile中寻找</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" alt="用户读写数据过程"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/12.png" alt="用户读写数据过程"></p>
<p>2.缓存的刷新</p>
<p>•系统会周期性地把MemStore缓存里的内容刷写到磁盘的StoreFile文件中，清空缓存，并在Hlog里面写入一个标记</p>
<p>•每次刷写都生成一个新的StoreFile文件，因此，每个Store包含多个StoreFile文件</p>
<p>•每个Region服务器都有一个自己的HLog 文件，每次启动都检查该文件，确认最近一次执行缓存刷新操作之后是否发生新的写入操作；如果发现更新，则先写入MemStore，再刷写到StoreFile，最后删除旧的Hlog文件，开始为用户提供服务</p>
<p>3.StoreFile 的合并</p>
<p>•每次刷写都生成一个新的StoreFile，数量太多，影响查找速度</p>
<p>•调用Store.compact()把多个合并成一个</p>
<p>•合并操作比较耗费资源，只有数量达到一个阈值才启动合并</p>
<h2 id="Store工作原理"><a href="#Store工作原理" class="headerlink" title="Store工作原理"></a>Store工作原理</h2><p>•Store是Region服务器的核心</p>
<p>•多个StoreFile合并成一个</p>
<p>•单个StoreFile过大时，又触发分裂操作，1个父Region被分裂成两个子Region</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/13.png" alt="StoreFile的合并和分裂过程"></p>
<h2 id="HLog工作原理"><a href="#HLog工作原理" class="headerlink" title="HLog工作原理"></a>HLog工作原理</h2><p>• 分布式环境必须要考虑系统出错。HBase采用HLog保证系统恢复</p>
<p>• HBase系统为每个Region服务器配置了一个HLog文件，它是一种预<br>写式日志（Write Ahead Log）</p>
<p>• 用户更新数据必须首先写入日志后，才能写入MemStore缓存，并且<br>，直到MemStore缓存内容对应的日志已经写入磁盘，该缓存内容才能被刷写到磁盘</p>
<p>• Zookeeper会实时监测每个Region服务器的状态，当某个Region服<br>务器发生故障时，Zookeeper会通知Master</p>
<p>• Master首先会处理该故障Region服务器上面遗留的HLog文件，这个遗留的HLog文件中包含了来自多个Region对象的日志记录</p>
<p>• 系统会根据每条日志记录所属的Region对象对HLog数据进行拆分，<br>分别放到相应Region对象的目录下，然后，再将失效的Region重新<br>分配到可用的Region服务器中，并把与该Region对象相关的HLog日<br>志记录也发送给相应的Region服务器</p>
<p>• Region服务器领取到分配给自己的Region对象以及与之相关的HLog日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写入到MemStore缓存中，然后，刷新到磁盘的StoreFile文件中，完成数据恢复</p>
<p>• 共用日志优点：提高对表的写操作性能；缺点：恢复时需要分拆日志</p>
<p>本笔记参考自厦门大学林子雨老师的公开课：<a href="https://www.icourse163.org/course/XMU-1002335004">https://www.icourse163.org/course/XMU-1002335004</a></p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（八）——Spark</title>
    <url>/2018/05/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/</url>
    <content><![CDATA[<h1 id="Spark的特点"><a href="#Spark的特点" class="headerlink" title="Spark的特点"></a>Spark的特点</h1><p>•运行速度快：使用DAG执行引擎以支持循环数据流与内存计算</p>
<p>•容易使用：支持使用Scala、Java、Python和R语言进行编程，可以通过Spark Shell进行交互式编程</p>
<p>•通用性：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件</p>
<p>•运行模式多样：可运行于独立的集群模式中，可运行于Hadoop中，也可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、HBase、Hive等多种数据源</p>
<h1 id="Scala简介"><a href="#Scala简介" class="headerlink" title="Scala简介"></a>Scala简介</h1><p>Scala是一门现代的多范式编程语言，运行于Java平台（JVM，Java 虚拟机），并兼容现有的Java程序</p>
<p>Scala的特性：</p>
<p>•Scala具备强大的并发性，支持函数式编程，可以更好地支持分布式系统</p>
<p>•Scala语法简洁，能提供优雅的API</p>
<p>Scala兼容Java，运行速度快，且能融合到Hadoop生态圈中</p>
<p>Scala是Spark的主要编程语言，但Spark还支持Java、Python、R作为编程语言</p>
<p>Scala的优势是提供了REPL（Read-Eval-Print Loop，交互式解释器），提高程序开发效率</p>
<h1 id="Spark与Hadoop的对比"><a href="#Spark与Hadoop的对比" class="headerlink" title="Spark与Hadoop的对比"></a>Spark与Hadoop的对比</h1><p>Hadoop存在如下一些缺点：</p>
<p>•表达能力有限</p>
<p>•磁盘IO开销大</p>
<p>•延迟高</p>
<p>•任务之间的衔接涉及IO开销</p>
<p>•在前一个任务执行完成之前，其他任务就无法开始，难以胜任复杂、多阶段的计算任务</p>
<p>Spark在借鉴Hadoop MapReduce优点的同时，很好地解决了MapReduce所面临的问题</p>
<p>相比于Hadoop MapReduce，Spark主要具有如下优点：</p>
<p>•Spark的计算模式也属于MapReduce，但不局限于Map和Reduce操作，还提供了多种数据集操作类型，编程模型比Hadoop MapReduce更灵活</p>
<p>•Spark提供了内存计算，可将中间结果放到内存中，对于迭代运算效率<br>更高</p>
<p>Spark基于DAG的任务调度执行机制，要优于Hadoop MapReduce的迭代执行机制</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/1.png" alt="Hadoop与Spark的执行流程对比"></p>
<p>•使用Hadoop进行迭代计算非常耗资源</p>
<p>•Spark将数据载入内存后，之后的迭代计算都可以直接使用内存中的中间结果作运算，避免了从磁盘中频繁读取数据</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/2.png" alt="Hadoop与Spark执行逻辑回归的时间对比"></p>
<h1 id="Spark生态系统"><a href="#Spark生态系统" class="headerlink" title="Spark生态系统"></a>Spark生态系统</h1><p>在实际应用中，大数据处理主要包括以下三个类型：</p>
<p>•复杂的批量数据处理：通常时间跨度在数十分钟到数小时之间</p>
<p>•基于历史数据的交互式查询：通常时间跨度在数十秒到数分钟之间</p>
<p>•基于实时数据流的数据处理：通常时间跨度在数百毫秒到数秒之间</p>
<p>当同时存在以上三种场景时，就需要同时部署三种不同的软件</p>
<p>•比如: MapReduce / Impala / Storm这样做难免会带来一些问题：</p>
<p>•不同场景之间输入输出数据无法做到无缝共享，通常需要进行数据格式的转换</p>
<p>•不同的软件需要不同的开发和维护团队，带来了较高的使用成本</p>
<p>•比较难以对同一个集群中的各个系统进行统一的资源协调和分配</p>
<p>•Spark的设计遵循“一个软件栈满足不同应用场景”的理念，逐渐形成了一套完整的生态系统</p>
<p>•既能够提供内存计算框架，也可以支持SQL即席查询、实时流式计算、机器学习和图计算等</p>
<p>•Spark可以部署在资源管理器YARN之上，提供一站式的大数据解决方案</p>
<p>•因此，Spark所提供的生态系统足以应对上述三种场景，即同时支持批处理、交互式查询和流数据处理</p>
<p>Spark生态系统已经成为伯克利数据分析软件栈BDAS（Berkeley Data Analytics Stack）的重要组成部分</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/3.png" alt="BDAS架构"></p>
<p>Spark的生态系统主要包含了Spark Core、Spark SQL、Spark Streaming、MLLib和GraphX 等组件</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/4.png" alt="Spark生态系统组件的应用场景"></p>
<h1 id="Spark运行架构"><a href="#Spark运行架构" class="headerlink" title="Spark运行架构"></a>Spark运行架构</h1><p>•RDD：是Resillient Distributed Dataset（弹性分布式数据集）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型</p>
<p>•DAG：是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系</p>
<p>•Executor：是运行在工作节点（WorkerNode）的一个进程，负责运行Task</p>
<p>•Application：用户编写的Spark应用程序</p>
<p>•Task：运行在Executor上的工作单元</p>
<p>•Job：一个Job包含多个RDD及作用于相应RDD上的各种操作</p>
<p>•Stage：是Job的基本调度单位，一个Job会分为多组Task，每组Task被称为Stage，或者也被称为TaskSet，代表了一组关联的、相互之间没有Shuffle依<br>赖关系的任务组成的任务集</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/5.png" alt="基本概念"></p>
<p>•Spark运行架构包括集群资源管理器（Cluster Manager）、运行作业任务的工作节点（Worker Node）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务的执行进程（Executor）</p>
<p>•资源管理器可以自带或Mesos或YARN</p>
<p>与Hadoop MapReduce计算框架相比，Spark所采用的Executor有两个优点：</p>
<p>•一是利用多线程来执行具体的任务，减少任务的启动开销</p>
<p>•二是Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备，有效减少IO开销</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/6.png" alt="Spark运行架构"></p>
<p>•一个Application由一个Driver和若干个Job构成，一个Job由多个Stage构成，一个Stage由多个没有Shuffle关系的Task组成</p>
<p>•当执行一个Application时，Driver会向集群管理器申请资源，启动xecutor，并向Executor发送应用程序代码和文件，然后在Executor上执行Task，运行结束后，执行结果会返回给Driver，或者写到HDFS或者其他数据库中</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/7.png" alt="Spark中各种概念之间的相互关系"></p>
<h1 id="Spark运行基本流程"><a href="#Spark运行基本流程" class="headerlink" title="Spark运行基本流程"></a>Spark运行基本流程</h1><p>（1）首先为应用构建起基本的运行环境，即由Driver创建一个SparkContext，进行资源的申请、任务的分配和监控</p>
<p>（2）资源管理器为Executor分配资源，并启动Executor进程</p>
<p>（3）SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAGScheduler解析成Stage，然后把一个个TaskSet提交给底层调度器TaskScheduler处理；Executor向SparkContext申请Task，Task Scheduler将Task发放给Executor运行，并提供应用程序代码</p>
<p>（4）Task在Executor上运行，把执行结果反馈给TaskScheduler，然后反馈给<br>DAGScheduler，运行完毕后写入数据并释放所有资源</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/8.png" alt="Spark运行基本流程图"></p>
<p>总体而言，Spark运行架构具有以下特点：</p>
<p>（1）每个Application都有自己专属的Executor进程，并且该进程在Application运行期间一直驻留。Executor进程以多线程的方式运行Task</p>
<p>（2）Spark运行过程与资源管理器无关，只要能够获取Executor进程并保持通信即可</p>
<p>（3）Task采用了数据本地性和推测执行等优化机制</p>
<h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><p>1.设计背景</p>
<p>•许多迭代式算法（比如机器学习、图算法等）和交互式数据挖掘工具，共同之处是，不同计算阶段之间会重用中间结果</p>
<p>•目前的MapReduce框架都是把中间结果写入到HDFS中，带来了大量的数据复制、磁盘IO和序列化开销</p>
<p>•RDD就是为了满足这种需求而出现的，它提供了一个抽象的数据架构，我们不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，避免中间数据存储</p>
<p>2.RDD 概念</p>
<p>•一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算</p>
<p>•RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和group by）而创建得到新的RDD</p>
<p>•RDD提供了一组丰富的操作以支持常见的数据运算，分为“动作”（Action）和“转换”（Transformation）两种类型</p>
<p>•RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改（不适合网页爬虫）</p>
<p>•表面上RDD的功能很受限、不够强大，实际上RDD已经被实践证明可以高效地表达许多框架的编程模型（比如MapReduce、SQL、Pregel）</p>
<p>•Spark用Scala语言实现了RDD的API，程序员可以通过调用API实现对RDD的各种操作</p>
<p>RDD典型的执行过程如下：</p>
<p>•RDD读入外部数据源进行创建</p>
<p>•RDD经过一系列的转换（Transformation）操作，每一次都会产生不同的RDD，供给下一个转换操作使用</p>
<p>•最后一个RDD经过“动作”操作进行转换，并输出到外部数据源这一系列处理称为一个Lineage（血缘关系），即DAG拓扑排序的结果</p>
<p>优点：惰性调用、管道化、避免同步等待、不需要保存中间结果、每次操作变得简单</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/9.png" alt="Spark运行基本流程图"></p>
<p>3.RDD特性</p>
<p>Spark采用RDD以后能够实现高效计算的原因主要在于：</p>
<p>（1）高效的容错性</p>
<p>•现有容错机制：数据复制或者记录日志</p>
<p>•RDD：血缘关系、重新计算丢失分区、无需回滚系统、重算过程在不同节点之间并行、只记录粗粒度的操作</p>
<p>（2）中间结果持久化到内存，数据在内存中的多个RDD操作之间进行传递，避免了不必要的读写磁盘开销</p>
<p>（3）存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化</p>
<p>4.RDD之间的依赖关系</p>
<p>窄依赖表现为一个父RDD的分区对应于一个子RDD的分区或多个父RDD的分区对应于一个子RDD的分区</p>
<p>•宽依赖则表现为存在一个父RDD的一个分区对应一个子RDD的多个分区</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/10.png" alt="窄依赖与宽依赖的区别"></p>
<p>5.Stage的划分</p>
<p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分Stage，具体划分方法是：</p>
<p>•在DAG中进行反向解析，遇到宽依赖就断开</p>
<p>•遇到窄依赖就把当前的RDD加入到Stage中</p>
<p>•将窄依赖尽量划分在同一个Stage中，可以实现流水线计算被分成三个Stage，在Stage2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/11.png" alt="根据RDD分区的依赖关系划分Stage"><br>流水线操作实例分区7通过map操作生成的分区9，可以不用等待分区8到分区10这个map操作的计算结束，而是继续进行union操作，得到分区13，这样流水线执行大大提高了计算的效率</p>
<p>Stage的类型包括两种：ShuffleMapStage和ResultStage，具体如下：</p>
<p>（1）ShuffleMapStage：不是最终的Stage，在它之后还有其他Stage，所以，它的输出一定需要经过Shuffle过程，并作为后续Stage的输入；这种Stage是以Shuffle为输出边界，其输入边界可以是从外部获取数据，也可以是另一个ShuffleMapStage的输出，其输出可以是另一个Stage的开始；在一个Job里可能有该类型的Stage，也可能没有该类型Stage；</p>
<p>（2）ResultStage：最终的Stage，没有输出，而是直接产生结果或存储。这种Stage是直接输出结果，其输入边界可以是从外部获取数据，也可以是另一个ShuffleMapStage的输出。在一个Job里必定有该类型Stage。<br>因此，一个Job含有一个或多个Stage，其中至少含有一个ResultStage。</p>
<p>6.RDD运行过程</p>
<p>通过上述对RDD概念、依赖关系和Stage划分的介绍，结合之前介绍的Spark运行<br>基本流程，再总结一下RDD在Spark架构中的运行过程：</p>
<p>（1）创建RDD对象；</p>
<p>（2）SparkContext负责计算RDD之间的依赖关系，构建DAG；</p>
<p>（3）DAGScheduler负责把DAG图分解成多个Stage，每个Stage中包含了多个<br>Task，每个Task会被TaskScheduler分发给各个WorkerNode上的Executor去执<br>行。<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/12.png" alt="RDD在Spark中的运行过程"></p>
<h1 id="Spark-SQL设计"><a href="#Spark-SQL设计" class="headerlink" title="Spark SQL设计"></a>Spark SQL设计</h1><p>Spark SQL在Hive兼容层面仅依赖HiveQL解析、Hive元数据，也就是说，从HQL被解析成抽象语法树（AST）起，就全部由Spark SQL接管了。Spark SQL执行计划生成和优化都由Catalyst（函数式关系查询优化框架）负责</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/13.png" alt="Spark SQL架构"></p>
<p>•Spark SQL增加了SchemaRDD（即带有Schema信息的RDD），使用户可以在Spark SQL中执行SQL语句，数据既可以来自RDD，也可以是Hive、HDFS、Cassandra等外部数据源，还可以是JSON格式的数据</p>
<p>•Spark SQL目前支持Scala、Java、Python三种语言，支持SQL-92规范</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Spark/14.png" alt="Spark SQL支持的数据格式和编程语言"></p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（二）——HBase相关知识（一）</title>
    <url>/2018/04/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Hbase简介"><a href="#Hbase简介" class="headerlink" title="Hbase简介"></a>Hbase简介</h1><p>HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，是谷歌BigTable的开源实现，主要用来存储非结构化和半结构化的松散数据。HBase的目标是处理非常庞大的表，可以通过水平扩展的方式，利用廉价计算机集群处理由超过10亿行数据和数百万列元素组成的数据表。</p>
<p>底层的分布式文件系统用来存储完全非结构化的数据。</p>
<p>Hbase是架构在底层的分布式文件系统HDFS基础之上的同时MR可以对Hbase的数据进行处理。同时Hive和Pig等都可以访问Hbase中的数据。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/1.png" alt="Hbase和Big Table的底层技术对应关系"></p>
<p>从上图可以看出，BigTable和HBase的底层技术的对比。</p>
<h2 id="为什么要设计HBase这个数据产品呢？"><a href="#为什么要设计HBase这个数据产品呢？" class="headerlink" title="为什么要设计HBase这个数据产品呢？"></a>为什么要设计HBase这个数据产品呢？</h2><p>•Hadoop可以很好地解决大规模数据的离线批量处理问题，但是，受限于HadoopMapReduce编程框架的高延迟数据处理机制，使得Hadoop无法满足大规模数据实时处理应用的需求</p>
<p>•HDFS面向批量访问模式，不是随机访问模式</p>
<p>•传统的通用关系型数据库无法应对在数据规模剧增时导致的系统扩展性和性能问题（分库分表也不能很好解决）</p>
<p>•传统关系数据库在数据结构变化时一般需要停机维护；空列浪费存储空间</p>
<p>•因此，业界出现了一类面向半结构化数据存储和处理的高可扩展、低写入/查询延迟的系统，例如，键值数据库、文档数据库和列族数据库（如BigTable和HBase等）</p>
<p>•HBase已经成功应用于互联网服务领域和传统行业的众多在线式数据分析处理系统中</p>
<h2 id="HBase与传统关系数据库的对比分析"><a href="#HBase与传统关系数据库的对比分析" class="headerlink" title="HBase与传统关系数据库的对比分析"></a>HBase与传统关系数据库的对比分析</h2><p>• HBase与传统的关系数据库的区别主要体现在以下几个方面：</p>
<p>• （1）数据类型：关系数据库采用关系模型，具有丰富的数据类型（整型，字符型等等）和存储方式，HBase则采用了更加简单的数据模型，它把数据存储为未经解释的字符串（也就是Bytes数组）</p>
<p>• （2）数据操作：关系数据库中包含了丰富的操作（增删改查），其中会涉及复杂的多表连接。HBase操作则不存在复杂的表与表之间的关系，只有简单的插入、查询、删除、清空等，因为HBase在设计上就避免了复杂的表和表之间的关系</p>
<p>• （3）存储模式：关系数据库是基于行模式存储的。HBase是基于列存储的，每个列族都由几个文件保存，不同列族的文件是分离的</p>
<p>• （4）数据索引：关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能。HBase只有一个索引——行键，通过巧妙的设计，HBase中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来</p>
<p>• （5）数据维护：在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在。而在HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留，只有在过了设置的参数期限之后，在系统后台清理的时候才会清理掉</p>
<p>• （6）可伸缩性：关系数据库很难实现横向扩展，纵向扩展（如添加内存，改进CPU等等）的空间也比较有限。相反，HBase和BigTable这些分布式数据库就是为了实现灵活的水平扩展而开发的，能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩</p>
<h2 id="HBase的访问接口"><a href="#HBase的访问接口" class="headerlink" title="HBase的访问接口"></a>HBase的访问接口</h2><p>以后在使用Hbase的时候，可以通过哪些方式访问HBase数据库？<br>见下图：<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/2.png" alt="HBase访问接口"></p>
<h2 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h2><p>• HBase是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳</p>
<p>• 每个值是一个未经解释的字符串，没有数据类型</p>
<p>• 用户在表中存储数据，每一行都有一个可排序的行键和任意多的列</p>
<p>• 表在水平方向由一个或者多个列族组成，一个列族中可以包含任意多个列，同一个列族里面的数据存储在一起</p>
<p>• 列族支持动态扩展，可以很轻松地添加一个列族或列，无需预先定义列的数量以及类型，所有列均以字符串形式存储，用户需要自行进行数据类型转换</p>
<p>• HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留（这是和HDFS只允许追加不允许修改的特性相关的）</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/3.png" alt="HBase访问接口"></p>
<p>• 表：HBase采用表来组织数据，表由行和列组成，列划分为若干个列族</p>
<p>• 行：每个HBase表都由若干行组成，每个行由行键（row key）来标识。</p>
<p>• 列族：一个HBase表被分组成许多“列族”（Column Family）的集合，它是基本的访问控制单元（支持动态拓展）</p>
<p>• 列限定符：列族里的数据通过列限定符（或列）来定位</p>
<p>• 单元格：在HBase表中，通过行、列族和列限定符确定一个“单元格”（cell），单元格中存储的数据没有数据类型，总被视为字节数组byte[]</p>
<p>• 时间戳：每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引</p>
<h3 id="HBase的数据坐标"><a href="#HBase的数据坐标" class="headerlink" title="HBase的数据坐标"></a>HBase的数据坐标</h3><p>HBase中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此，可以视为一个“四维坐标”，即[行键, 列族, 列限定符, 时间戳]</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/4.png" alt="HBase数据坐标"></p>
<h3 id="概念视图"><a href="#概念视图" class="headerlink" title="概念视图"></a>概念视图</h3><p>HBase在概念上和实际的底层存储是有区分的，在概念上HBase只是一个表，如下面只给了一个行键：</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/5.png" alt="概念视图"><br>如这一个行键给了两个列族，第一个列族contents中冒号前面的contents是列族的名称，冒号后面的html是列的名称，引号中的内容就是这一列的数据。一个时间戳并不一定会在所有列族插入数据，从图中就可以看出。所以这就导致了HBase的稀疏表的特性。这只是在概念上的视图。</p>
<h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p>实际上在实际存储中，并不是按上述的方式去存的。在底层存储时，是按列族为单位进行存储的。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/6.png" alt="HBase数据的物理视图"></p>
<p>上图是在实际存储时，存储在底层的实际的表。并没有像概念视图中存储了很多的空数据。所以概念视图和物理视图上是有区分的。</p>
<h3 id="面向列的存储"><a href="#面向列的存储" class="headerlink" title="面向列的存储"></a>面向列的存储</h3><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/8.png" alt="行式数据库和列式数据库示意图"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/7.png" alt="行式存储结构和列式存储结构"></p>
<p>传统的数据库，以行为单位进行存储，一行包括ID,姓名，年龄，性别，IP，操作等。<br>但是按列存储，里面的姓名、年龄等进行单独存储。</p>
<p>它们各自的优缺点：<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Hbase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/9.png" alt="行式存储结构和列式存储结构"></p>
<p>另外，使用列式存储，数据可以达到很高的数据压缩率。而行式存储，很难压缩。</p>
<p>本笔记参考自厦门大学林子雨老师的公开课：<a href="https://www.icourse163.org/course/XMU-1002335004">https://www.icourse163.org/course/XMU-1002335004</a></p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（六）——MapReduce</title>
    <url>/2018/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/</url>
    <content><![CDATA[<h1 id="MapReduce体系结构"><a href="#MapReduce体系结构" class="headerlink" title="MapReduce体系结构"></a>MapReduce体系结构</h1><p>MapReduce主要有以下4个部分组成：</p>
<p>1 ）Client</p>
<p>•用户编写的MapReduce程序通过Client提交到JobTracker端</p>
<p>•用户可通过Client提供的一些接口查看作业运行状态</p>
<p>2 ）JobTracker</p>
<p>•JobTracker负责资源监控和作业调度</p>
<p>•JobTracker 监控所有TaskTracker与Job的健康状况，一旦发现失败，就将相应的任务转移到其他节点</p>
<p>•JobTracker 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（TaskScheduler），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源</p>
<p>3 ）TaskTracker</p>
<p>•TaskTracker 会周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）</p>
<p>•TaskTracker 使用“slot”等量划分本节点上的资源量（CPU、内存等）。一个Task 获取到一个slot 后才有机会运行，而Hadoop调度器的作用就是将各个TaskTracker上的空闲slot分配给Task使用。slot 分为Map slot 和Reduce slot 两种，分别供MapTask 和Reduce Task使用</p>
<p>4 ）Task</p>
<p>Task 分为Map Task 和Reduce Task 两种，均由TaskTracker 启动</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/1.png" alt="MapReduce体系结构"></p>
<h1 id="MapReduce工作流程概述"><a href="#MapReduce工作流程概述" class="headerlink" title="MapReduce工作流程概述"></a>MapReduce工作流程概述</h1><p>MapReduce把一个大的数据集拆分成多个小数据块在多台机器上并行处理，也就是说，一个大的MapReduce作业，首先会被拆分成许多个Map任务在多台机器上并行执行，每个Map任务通常运行在数据存储的节点上，这样，计算和数据就可以放在一起运行，不需要额外的数据传输开销。当Map任务结束后，会生成以&lt;Key,value&gt;形式表示的许多中间结果。然后，这些中间结果会被分发到多个Reduce任务在多台机器上并行执行，具有相同Key的&lt;Key,value&gt;会被发送到同一个Reduce任务那里，Reduce任务会对中间结果进行会中计算得到最后的结果，并输出到分布式文件系统中。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/2.png" alt="MapReduce工作流程"></p>
<p>•不同的Map任务之间不会进行通信</p>
<p>•不同的Reduce任务之间也不会发生任何信息交换</p>
<p>•用户不能显式地从一台机器向另一台机器发送消息</p>
<p>•所有的数据交换都是通过MapReduce框架自身去实现的</p>
<h1 id="MapReduce各个执行阶段"><a href="#MapReduce各个执行阶段" class="headerlink" title="MapReduce各个执行阶段"></a>MapReduce各个执行阶段</h1><p>MapReduce的算法执行过程：</p>
<p>1）MapReduce框架使用InputFormat模块做Map前的预处理，比如验证输入的格式是否符合输入定义，然后，将输入文件切分为逻辑上的多个InputSplit，这是MapReduce对文件进行处理和运算的输入单位，只是一个逻辑概念，每个InputSplit并没有对文件进行实际切割，只是记录了要处理的数据的位置和长度。</p>
<p>2）因为InuptSplit是逻辑切分而非物理切分，所以还需要通过RecordReader（RR）根据InputSplit中的信息来处理InputSplit中的具体记录，加载数据并转换为适合Map任务读取的键值对，输入给Map任务。</p>
<p>3）Map任务会根据用户自定义的映射规则，输出一系列的&lt;Key,value&gt;作为中间结果。</p>
<p>4）为了让Reduce可以并行处理Map的结果，需要对Map的输出进行一定的分区（Portition）、排序（Sort）、合并（Combine）、归并（Merge）等操作，得到&lt;Key,value-list&gt;形式的中间结果，在交给对应的Reduce进行处理，这个过程称为Shuffle。从无序的&lt;Key,value&gt;到有序的&lt;Key,value-list&gt;，这个过程用Shuffle（洗牌）来称呼是非常形象的。</p>
<p>5）Reduce以一系列&lt;Key,value-list&gt;中间结果作为输入，执行用户定义的逻辑，输出结果给OutputFormat模块。</p>
<p>6）OutputFormat模块会验证输出目录是否已经存在以及输出结果类型是否符合配置文件中的配置类型，如果都满足，就输出Reduce的结果到分布式文件系统。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/3.png" alt="MapReduce各个执行阶段"></p>
<p>HDFS 以固定大小的block 为基本单位存储数据，而对于MapReduce 而言，其处理单位是split。split 是一个逻辑概念，它只包含一些元数据信息，比如数据起始位置、数据长度、数据所在节点等。它的划分方法完全由用户自己决定。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/4.png" alt="MapReduce各个执行阶段"></p>
<p>Map 任务的数量</p>
<p>•Hadoop为每个split创建一个Map任务，split 的多少决定了Map任务的数目。大多数情况下，理想的分片大小是一个HDFS块</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/5.png" alt="Map"></p>
<p>Reduce 任务的数量</p>
<p>•最优的Reduce任务个数取决于集群中可用的reduce任务槽(slot)的数目</p>
<p>•通常设置比reduce任务槽数目稍微小一些的Reduce任务个数（这样可以预留一些系统资源处理可能发生的错误</p>
<h1 id="Shuffle过程原理"><a href="#Shuffle过程原理" class="headerlink" title="Shuffle过程原理"></a>Shuffle过程原理</h1><p>1.Shuffle 过程简介<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/6.png" alt="Shuffle 过程简介"></p>
<p>2.Map 端的Shuffle 过程<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/7.png" alt="Map 端的Shuffle 过程"></p>
<p>Map的输出结果首先被写入缓存，当缓存满时，就启动溢写操作，把缓存中的数据写入磁盘文件，并清空缓存。当启动溢写操作时，首先需要把缓存中的数据进行分区，然后对每个分区的数据进行排序（Sort）和合并（Combine），之后再写入磁盘文件。每次溢写操作会生成一个新的磁盘文件，随着Map任务的执行，磁盘中就会生成多个溢写文件。在Map任务全部结束之前，这些溢写文件会被归并（Merge）成一个大的磁盘文件，然后通知相应的Reduce任务来领取属于自己处理的数据。</p>
<p>•每个Map任务分配一个缓存</p>
<p>•MapReduce默认100MB缓存</p>
<p>•设置溢写比例0.8</p>
<p>•分区默认采用哈希函数</p>
<p>•排序是默认的操作</p>
<p>•排序后可以合并（Combine）</p>
<p>•合并不能改变最终结果</p>
<p>•在Map任务全部结束之前进行归并</p>
<p>•归并得到一个大的文件，放在本地磁盘</p>
<p>•文件归并时，如果溢写文件数量大于预定值（默<br>认是3）则可以再次启动Combiner，少于3不需要</p>
<p>•JobTracker会一直监测Map任务的执行，并通知<br>Reduce任务来领取数据</p>
<p>合并（Combine）和归并（Merge）的区别：<br>两个键值对&lt;“a”,1&gt;和&lt;“a”,1&gt;，如果合并，会得到&lt;“a”,2&gt;，如果归并，会得到&lt;“a”,&lt;1,1&gt;&gt;</p>
<p>3.Reduce 端的Shuffle 过程</p>
<p>Reduce任务从Map端的不同Map及其领回属于自己处理的那部分数据，然后对数据进行归并（Merge）后交给Reduce处理。</p>
<p>•Reduce任务通过RPC向JobTracker询问Map任务是否已经完成，若完成，则领取数据</p>
<p>•Reduce领取数据先放入缓存，来自不同Map机器，先归并，再合并，写入磁盘</p>
<p>•多个溢写文件归并成一个或多个大文件，文件中的键值对是排序的</p>
<p>•当数据很少时，不需要溢写到磁盘，直接在缓存中归并，然后输出给Reduce</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/8.png" alt="Reduce端的Shuffle过程"></p>
<h1 id="MapReduce应用程序执行过程"><a href="#MapReduce应用程序执行过程" class="headerlink" title="MapReduce应用程序执行过程"></a>MapReduce应用程序执行过程</h1><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94MapReduce/9.png" alt="MapReduce应用程序执行过程"></p>
<p>参考资料：林子雨老师的MOOC课程：<br><a href="https://www.icourse163.org/learn/XMU-1002335004#/learn/content?type=detail&amp;id=1003836797&amp;cid=1004616527&amp;replay=true">https://www.icourse163.org/learn/XMU-1002335004#/learn/content?type=detail&amp;id=1003836797&amp;cid=1004616527&amp;replay=true</a></p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（四）——HBase相关知识（三）</title>
    <url>/2018/04/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="HBase应用方案"><a href="#HBase应用方案" class="headerlink" title="HBase应用方案"></a>HBase应用方案</h1><h2 id="HBase实际应用中的性能优化方法"><a href="#HBase实际应用中的性能优化方法" class="headerlink" title="HBase实际应用中的性能优化方法"></a>HBase实际应用中的性能优化方法</h2><p><code>行键（Row Key ）</code></p>
<p>行键是按照 字典序存储，因此，设计行键时，要充分利用这个排序特点，将经常一起读取的数据存储到一块，将最近可能会被访问的数据放在一块。</p>
<p>举个例子：如果最近写入HBase表中的数据是最可能被访问的，可以考虑将时间戳<br>作为行键的一部分，由于是字典序排序，所以可以使用Long.MAX_VALUE -<br>timestamp作为行键，这样能保证新写入的数据在读取时可以被快速命中。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/1.png" alt="行键"></p>
<p><code>InMemory</code><br>创建表的时候，可以通过HColumnDescriptor.setInMemory(true)将表放到Region服务器的缓存中，保证在读取的时候被cache命中。</p>
<p><code>Max Version</code><br>创建表的时候，可以通过HColumnDescriptor.setMaxVersions(int maxVersions)设置表中数据的最大版本，如果只需要保存最新版本的数据，那么可以设置setMaxVersions(1)。</p>
<p><code>Time To Live</code><br>创建表的时候，可以通过HColumnDescriptor.setTimeToLive(int timeToLive)设置表中数据的存储生命期，过期数据将自动被删除，例如如果只需要存储最近两天的数据，那么可以设置setTimeToLive(2 * 24 * 60 * 60)。</p>
<h2 id="HBase性能监视"><a href="#HBase性能监视" class="headerlink" title="HBase性能监视"></a>HBase性能监视</h2><p><code>Master-status(自带)</code></p>
<p>•HBase Master默认基于Web的UI服务端口为60010，HBase region服务器默认基于Web的UI服务端口为60030.如果master运行在名为master.foo.com的主机中，mater的主页地址就是<a href="http://master.foo.com:60010，用户可以通过Web浏览器输入这个地址查看该页面">http://master.foo.com:60010，用户可以通过Web浏览器输入这个地址查看该页面</a></p>
<p>•可以查看HBase集群的当前状态</p>
<p><code>Ganglia</code></p>
<p>Ganglia是UC Berkeley发起的一个开源集群监视项目，用于监控系统性能</p>
<p><code>OpenTSDB</code></p>
<p>OpenTSDB可以从大规模的集群（包括集群中的网络设备、操作系统、应用程序）中获取相应的metrics并进行存储、索引以及服务，从而使得这些数据更容易让人理解，如web化，图形化等</p>
<p><code>Ambari</code></p>
<p>Ambari 的作用就是创建、管理、监视 Hadoop 的集群</p>
<h2 id="在HBase之上构建SQL引擎"><a href="#在HBase之上构建SQL引擎" class="headerlink" title="在HBase之上构建SQL引擎"></a>在HBase之上构建SQL引擎</h2><p>NoSQL区别于关系型数据库的一点就是NoSQL不使用SQL作为查询语言，至于为何在NoSQL数据存储HBase上提供SQL接口，有如下原因：</p>
<ol>
<li><p>易使用。使用诸如SQL这样易于理解的语言，使人们能够更加轻松地使用HBase。</p>
</li>
<li><p>减少编码。使用诸如SQL这样更高层次的语言来编写，减少了编写的代码量。<br>方案：</p>
</li>
</ol>
<p>1.Hive整合HBase<br>2.Phoenix</p>
<p>1.Hive 整合HBase</p>
<p>Hive与HBase的整合功能从Hive0.6.0版本已经开始出现，利用两者对外的API接口互相通信，通信主要依靠hive_hbase-handler.jar工具包(Hive Storage Handlers)。由于HBase有一次比较大的版本变动，所以并不是每个版本的Hive都能和现有的HBase版本进行整合，所以在使用过程中特别注意的就是两者版本的一致性。</p>
<p>2.Phoenix</p>
<p>Phoenix由Salesforce.com开源，是构建在Apache HBase之上的一个SQL中间层，可以让开发者在HBase上执行SQL查询。</p>
<h2 id="构建HBase二级索引"><a href="#构建HBase二级索引" class="headerlink" title="构建HBase二级索引"></a>构建HBase二级索引</h2><p>二级索引，又叫辅助索引</p>
<p>HBase只有一个针对行健的索引访问HBase表中的行，只有三种方式：</p>
<p>•通过单个行健访问</p>
<p>•通过一个行健的区间来访问</p>
<p>•全表扫描</p>
<p>使用其他产品为HBase行健提供索引功能：</p>
<p>•Hindex二级索引</p>
<p>•HBase+Redis</p>
<p>•HBase+solr</p>
<p>原理：采用HBase0.92版本之后引入的Coprocessor特性</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/2.png" alt="二级索引"></p>
<p><code>Coprocessor构建二级索引</code></p>
<p>•Coprocessor提供了两个实现：endpoint和observer，endpoint相当于关系型数据库的<br>存储过程，而observer则相当于触发器</p>
<p>•observer允许我们在记录put前后做一些处理，因此，而我们可以在插入数据时同步写<br>入索引表</p>
<p>•Coprocessor构建二级索引•缺点：每插入一条数据需要向索引表插入数据，即耗时是双倍的，对HBase的集群的压力也是双倍的</p>
<p>优点：<br>非侵入性：引擎构建在HBase之上，既没有对HBase进行任何改动，也不需要上层应用做任何妥协</p>
<p>Hindex二级索引</p>
<p>Hindex 是华为公司开发的纯 Java 编写的HBase二级索引，兼容 Apache HBase 0.94.8。当前的特性如下：</p>
<p>•多个表索引</p>
<p>•多个列索引</p>
<p>•基于部分列值的索引</p>
<p><code>HBase+Redis</code></p>
<p>•Redis+HBase方案</p>
<p>•Coprocessor构建二级索引</p>
<p>•Redis做客户端缓存</p>
<p>•将索引实时更新到Redis等KV系统中，定时从KV更新索引到HBase的索引表中</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/3.png" alt="HBase+Redis"></p>
<p><code>Solr+HBase</code></p>
<p>Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行<br>了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询<br>性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索<br>引擎。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94HBase%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/4.png" alt="Solr+HBase"></p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（五）——云数据库架构</title>
    <url>/2018/04/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>不同的云数据库产品采用的系统架构差异很大，这里以阿里巴巴集团核心系统数据库团队开发的UMP(Unified MySQL Platform)系统为例进行介绍。</p>
<h1 id="UMP系统概述"><a href="#UMP系统概述" class="headerlink" title="UMP系统概述"></a>UMP系统概述</h1><p>•UMP系统是低成本和高性能的MySQL云数据库方案</p>
<p>总的来说，UMP系统架构设计遵循了以下原则：</p>
<p>•保持单一的系统对外入口，并且为系统内部维护单一的资源池（CPU、内存、带宽、磁盘等放在一个统一的资源池，供上部组件调用）</p>
<p>•消除单点故障，保证服务的高可用性（设置多个管家（Controller））</p>
<p>•保证系统具有良好的可伸缩，能够动态地增加、删减计算与存储节点</p>
<p>•保证分配给用户的资源也是弹性可伸缩的，资源之间相互隔离，确保<br>应用和数据安全（多租户之间隔离，当一个用户使用过多资源时，对其进行限制，以免影响其他用户的使用）</p>
<h1 id="UMP系统架构"><a href="#UMP系统架构" class="headerlink" title="UMP系统架构"></a>UMP系统架构</h1><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/1.png" alt="UMP系统架构"></p>
<h2 id="Mnesia"><a href="#Mnesia" class="headerlink" title="Mnesia"></a>Mnesia</h2><p>•Mnesia是一个分布式数据库管理系统</p>
<p>•Mnesia支持事务，支持透明的数据分片，利用两阶段锁实现分布式事务，可以线性扩展到至少50个节点</p>
<p>•Mnesia的数据库模式(schema)可在运行时动态重配置，表能被迁移或复制到多个节点来改进容错性</p>
<p>•Mnesia的这些特性，使其在开发云数据库时被用来提供分布式数据库服务</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/2.png" alt="RabbitMQ"></p>
<p>•RabbitMQ是一个工业级的消息队列产品（功能类似于IBM公司的消息<br>队列产品IBM Websphere MQ），作为消息传输中间件来使用，可以实现可靠的消息传送</p>
<p>•UMP集群中各个节点之间的通信，不需要建立专门的连接，都是通过<br>读写队列消息来实现的</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper是高效和可靠的协同工作系统，提供分布式锁之类的基本服务（比如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等），用于构建分布式应用，减轻分布式应用程序所承担的协调任务</p>
<p>在UMP系统中，Zookeeper主要发挥三个作用：</p>
<p>•作为全局的配置服务器。UMP系统把运行的应用系统的配置信息完全交给Zookeeper来管理，把配置信息保存在Zookeeper的某个目录节点中，然后将所有需要修改的服务器对这个目录节点设置监听，也就是监控配置信息的状态，一旦配置信息发生变化，每台服务器就会收到Zookeeper的通知，然后从Zookeeper获取新的配置信息。</p>
<p>•提供分布式锁（选出一个集群的“总管”）。UMP急群众部署了多个Controller服务器，为了保证系统的正确运行，对于有些操作，在某一时刻，只能由一个服务器去执行，而不能同时执行。礼物，一个MySQL实例发生故障以后，需要进行主备切换，有另一个正常的服务器来代替当前发生故障的服务器，如果这个时候所有的Controller服务器都去跟踪处理并且发起主备切换流程，那么，整个系统就会进入混乱状态。因此，在同一时间，必须从集群的多个Controller服务器中选举出一个“总管”，由这个“总管”负责发起各种系统任务。Zookeeper的分布式锁功能能够帮助选出一个“总管”，让这个“总管”来管理集群。</p>
<p>•监控所有MySQL实例。急群众运行MySQL实例的服务器发生故障时，必须被及时监听到，然后使用其他正常服务器来替代故障服务器。UMP系统借助Zookeeper实现对所有MySQL实例的监控。每个MySQL实例在启动时都会在Zookeeper上创建一个临时类型的目录节点，当某个MySQL实例挂掉时，这个临时类型的目录节点也随之被删除，后台监听进程可以捕获到这种变化，从而知道这个MySQL实例不再可用。</p>
<h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>•LVS(Linux Virtual Server)即Linux虚拟服务器，是一个虚拟的服务器集群系统</p>
<p>•UMP系统借助于LVS来实现集群内部的负载均衡</p>
<p>•LVS集群采用IP负载均衡技术和基于内容请求分发技术</p>
<p>•调度器是LVS集群系统的唯一入口点，调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器</p>
<p>•整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序</p>
<h2 id="Controller服务器"><a href="#Controller服务器" class="headerlink" title="Controller服务器"></a>Controller服务器</h2><p>•Controller服务器向UMP集群提供各种管理服务，实现集群成员管理<br>、元数据存储、MySQL实例管理、故障恢复、备份、迁移、扩容等功<br>能</p>
<p>•Controller服务器上运行了一组Mnesia分布式数据库服务，其中存储了各种系统元数据，主要包括集群成员、用户的配置和状态信息，以及用户名到后端MySQL实例地址的映射关系（或称为“路由表”）等</p>
<p>•当其它服务器组件需要获取用户数据时，可以向Controller服务器发送请求获取数据</p>
<p>•为了避免单点故障，保证系统的高可用性，UMP系统中部署了多台<br>Controller服务器，然后，由Zookeeper的分布式锁功能来帮助选出一个“总管”，负责各种系统任务的调度和监控</p>
<h2 id="Web-控制台"><a href="#Web-控制台" class="headerlink" title="Web 控制台"></a>Web 控制台</h2><p>Web控制台向用户提供系统管理界面</p>
<h2 id="Proxy-服务器"><a href="#Proxy-服务器" class="headerlink" title="Proxy 服务器"></a>Proxy 服务器</h2><p>Proxy服务器向用户提供访问MySQL数据库的服务，它完全实现了<br>MySQL协议，用户可以使用已有的MySQL客户端连接到Proxy服务器，<br>Proxy服务器通过用户名获取到用户的认证信息、资源配额的限制(例如QPS、IOPS（I/O Per Second）、最大连接数等)，以及后台MySQL实例的地址，然后，用户的SQL查询请求会被转发到相应的MySQL实例上。</p>
<p>除了数据路由的基本功能外，Proxy服务器中还实现了很多重要的功能，主要包括屏蔽MySQL实例故障、读写分离、分库分表、资源隔离、记录用户访问日志等</p>
<h2 id="Agent-服务器"><a href="#Agent-服务器" class="headerlink" title="Agent 服务器"></a>Agent 服务器</h2><p>Agent服务器部署在运行MySQL进程的机器上，用来管理每台物理机上的MySQL实例，执行主从切换、创建、删除、备份、迁移等操作，同时，还负责收集和分析MySQL进程的统计信息、慢查询日志（Slow Query Log）和bin-log</p>
<h2 id="日志分析服务器"><a href="#日志分析服务器" class="headerlink" title="日志分析服务器"></a>日志分析服务器</h2><p>日志分析服务器存储和分析Proxy服务器传入的用户访问日志，并支持实时查询一段时间内的慢日志和统计报表</p>
<h2 id="信息统计服务器"><a href="#信息统计服务器" class="headerlink" title="信息统计服务器"></a>信息统计服务器</h2><p>信息统计服务器定期将采集到的用户的连接数、QPS数值以及MySQL实例的进程状态用RRDtool进行统计，可以在 Web界面上可视化展示统计结果，也可以把统计结果作为今后实现弹性的资源分配和自动化的MySQL实例迁移的依据</p>
<h2 id="愚公系统"><a href="#愚公系统" class="headerlink" title="愚公系统"></a>愚公系统</h2><p>愚公系统是一个全量复制结合bin-log分析进行增量复制的工具，可以实现在不停机的情况下动态扩容、缩容和迁移</p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>实现优先队列</title>
    <url>/2018/08/12/%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>优先队列的一个最普遍的应用就是计算机在进行任务调度时，<font color=red>动态</font>选择优先级最高的任务执行。即完成了一个操作后，后面的操作并不一定按照之前的优先级顺序执行，有可能会有其他优先级更高的任务插入，或者出现更加复杂的情况。在其他领域，只要涉及动态选择优先级顺序的情况，都需要用到优先队列。</p>
<p>当然优先队列不只有利于解决动态问题，解决一些静态问题也有优势。比如取出N各元素中的前M个元素。如果使用排序，其时间复杂度为O(NlogN),但是如果使用优先队列的话，其时间复杂度为O(NlogM).</p>
<p>优先队列有两个主要操作:<code>入队</code>和<code>出队</code>(取出优先级最高的元素).</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>插入元素(入队)</th>
<th>删除最大元素(出队)</th>
</tr>
</thead>
<tbody><tr>
<td>普通数组</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>顺序数组</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>堆</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody></table>
<p>使用堆实现优先队列时，对于总共N个请求：<br>使用普通数组或者顺序数组，最差的情况:O(n^2)，使用堆:O(nlogn)</p>
<p>优先队列一般都是基于堆的，所以先写堆的实现。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>详情可以看 <a href="https://homxuwang.github.io/2019/04/07/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/">堆和堆排序</a> 中<code>堆的算法</code>部分. </p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值(所以分为最大堆和最小堆)</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<p>另外要注意：节点值的大小和节点所处的层次是没有关系的</p>
<p>本文以最大堆为例，进行书写。</p>
<h2 id="堆的表示方法——动态数组"><a href="#堆的表示方法——动态数组" class="headerlink" title="堆的表示方法——动态数组"></a>堆的表示方法——动态数组</h2><p>堆的一种底层表示方法是使用动态数组实现，关于动态数组的实现见：<a href="https://homxuwang.github.io/2018/07/17/%E6%95%B0%E7%BB%84/">https://homxuwang.github.io/2018/07/17/%E6%95%B0%E7%BB%84/</a></p>
<p><img src="%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/1.png"></p>
<p>堆的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;index 0 doesn&#x27;t have parent;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (index-<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个完全二叉树的数组表示中，一个索引所表示的元素的左孩子的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个完全二叉树的数组表示中，一个索引所表示的元素的右孩子的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向堆中添加一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        data.addLast(e); <span class="comment">//先向末尾添加元素</span></span><br><span class="line">        <span class="comment">//调用siftUp函数，进行上浮操作,以维护堆的性质</span></span><br><span class="line">        siftUp(data.getSize() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要上浮的元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果k满足索引大于零,且其父亲节点的值小于它的值，则进行上浮操作</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            swap(k,parent(k));</span><br><span class="line">            k = parent(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个交换的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= data.getSize() || j &lt; <span class="number">0</span> || j&gt;= data.getSize())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Index is illegal.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        E temp = data.get(i);</span><br><span class="line">        data.set(i,data.get(j));</span><br><span class="line">        data.set(j,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看堆中的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">findMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.getSize() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Can not findMac in a empty heap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出堆中的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        E ret = findMax();</span><br><span class="line"></span><br><span class="line">        swap(<span class="number">0</span>,data.getSize() - <span class="number">1</span>);</span><br><span class="line">        data.removeLast();</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (leftChild(k) &lt; data.getSize())&#123;<span class="comment">//如果k没有左右孩子，则循环终止</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = leftChild(k);<span class="comment">//j为k的左孩子的索引</span></span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt; data.getSize() &amp;&amp; data.get( j + <span class="number">1</span> ).compareTo(data.get(j)) &gt; <span class="number">0</span>)&#123;<span class="comment">//如果k有右孩子,并且右孩子的节点的值大于左孩子的节点的值</span></span><br><span class="line">                j = rightChild(k);</span><br><span class="line">                <span class="comment">//此时，data[j]是leftChild和rightChild中的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(data.get(k).compareTo(data.get(j)) &gt;= <span class="number">0</span>) <span class="comment">// 如果k的值大于其左右孩子的值，则满足了最大堆的另一个性质，可以退出循环体</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//否则交换k和j位置,并且k赋值为j，继续进行下一个循环</span></span><br><span class="line">            swap(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在数组中，一个父亲节点其所有节点的索引(假设索引以0开始)为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Index_leftChild  = index_Father * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">Index_rightChild = index_Father * <span class="number">2</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果知道一个孩子节点的索引(假设索引以0开始)求其父亲节点的索引:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index_Father = ( index_Child - <span class="number">1</span> ) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面两个求法可以用数学归纳法进行证明。</p>
</li>
<li><p><code>Sift Up</code>操作很简单，即新添加的元素先放到数组的末尾位置，这时候满足了完全二叉树的性质。但是它不一定满足总是不大于或者不小于其父亲节点的值。所以这时候的操作是，这个值要与它的父亲节点、爷爷节点……对比，直到放在合适的位置。因为方法中总结了找到一个节点的父亲节点的方法:<code>faterIndex = (index-1) / 2</code>。以一个最大堆为例，让新加入的节点和父亲节点对比，如果它大于其父亲节点，则交换，继续对比其父亲节点，直到它小于等于其父亲节点为止。</p>
</li>
<li><p><code>Sift Down</code>操作，即取出最大堆的堆顶的元素（取出操作只能取出这个最大的元素，而不能取出别的元素）。因为最大的元素取出后，其左右的树结构就是两个单独的子树，那么要给这两个子树找一个新的父节点，操作如下：</p>
</li>
</ul>
<ol>
<li>将堆中的最后一个元素放在堆顶</li>
<li>删除掉最后一个元素（这时候满足完全二叉树的性质）</li>
<li>将堆顶元素与左右孩子中<code>大于它</code>且<code>较大</code>的数进行交换</li>
<li>交换后的新位置继续与孩子节点中<code>大于它</code>且<code>较大</code>的数进行交换</li>
<li>继续操作直到它大于其左后孩子或者它没有左右孩子</li>
</ol>
<p>优点：add操作和extractMax操作的时间复杂度都是O(logn)</p>
<ul>
<li>其中<code>swap</code>交换函数我写在了堆这个类中，可以在Array类中定义交换函数，在堆类中直接调用即可。</li>
</ul>
<h2 id="Heapify-和-replace操作"><a href="#Heapify-和-replace操作" class="headerlink" title="Heapify 和 replace操作"></a>Heapify 和 replace操作</h2><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>replace：取出最大元素后放入新元素</p>
<ul>
<li><p>step1: extractMax -&gt; step2: add (2O(logn))</p>
</li>
<li><p>setp1: 替换堆顶元素 -&gt; step2: Sift Down (O(logn))</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出堆中的最大元素，并替换成e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    E ret = findMax();</span><br><span class="line">    data.set(<span class="number">0</span>,e);</span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Heapify"><a href="#Heapify" class="headerlink" title="Heapify"></a>Heapify</h3><p>将任意数组整理成堆的形状</p>
</li>
<li><p>扫描数组，放如堆的新的对象中再返回 (O(nlogn))</p>
</li>
<li><p>可以先把数组看成一棵完全二叉树,从最后一个非叶子节点开始进行<code>Sift Down</code>操作。(找到最后一个非叶子节点的方法：拿到最后一个节点的索引，然后计算他的父亲节点的索引即可) step1: 找到最后一个非叶子节点，进行<code>Sift Down</code>操作 step2: 倒数第二个非叶子节点进行<code>Sift Down</code>操作 … 以此类推 直到索引为0的非叶子节点完成<code>Sift Down</code>操作  O(n)</p>
</li>
<li><p>Heapify一般可以在构造函数中进行(用一个数组初始化堆)),所以Array类也要支持一个用数组初始化动态数组的构造函数</p>
</li>
</ul>
<p>Array类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(E[] arr)</span>  </span>&#123;</span><br><span class="line">  data = (E[])<span class="keyword">new</span> Object[arr.length];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i ++)&#123;</span><br><span class="line">    data[i] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  size = arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MaxHeap的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">  data = <span class="keyword">new</span> Array&lt;&gt;(arr);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = parent(arr.length - <span class="number">1</span>) ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">  siftDown(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>优先队列就是一个队列，要满足队列的所有属性方法，所以要实现队列接口，关于队列的实现见：<a href="https://homxuwang.github.io/2018/07/17/%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">https://homxuwang.github.io/2018/07/17/%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</a></p>
<p>优先队列的底层是使用堆来实现，同样还是以最大堆为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        maxHeap.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.findMax();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java.util中的PriorityQueue默认是用的最小堆，具体方法名也有一些区别</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础学习笔记（十）——图计算</title>
    <url>/2018/05/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="图结构数据"><a href="#图结构数据" class="headerlink" title="图结构数据"></a>图结构数据</h1><p>•许多大数据都是以大规模图或网络的形式呈现<br>•许多非图结构的大数据，也常常会被转换为图模型后进行分析<br>•图数据结构很好地表达了数据之间的关联性<br>•关联性计算是大数据计算的核心——通过获得数据的关联性，可以从噪音很多的海量数据中抽取有用的信息</p>
<h1 id="传统图计算解决方案的不足之处"><a href="#传统图计算解决方案的不足之处" class="headerlink" title="传统图计算解决方案的不足之处"></a>传统图计算解决方案的不足之处</h1><p>很多传统的图计算算法都存在以下几个典型问题：<br>（1）常常表现出比较差的内存访问局部性<br>（2）针对单个顶点的处理工作过少<br>（3）计算过程中伴随着并行度的改变</p>
<p>针对大型图（比如社交网络和网络图）的计算问题，可能的解决方案及其不足之处具体如下：<br>• （1 ）为特定的图应用定制相应的分布式实现<br>• （2 ）基于现有的分布式计算平台进行图计算<br>• （3 ）使用单机的图算法库：比如BGL、LEAD、NetworkX、JDSL、Standford GraphBase和FGL等<br>• （4 ）使用已有的并行图计算系统：比如，ParallelBGL和CGM Graph，实现了很多并行图算法</p>
<h1 id="图计算通用软件"><a href="#图计算通用软件" class="headerlink" title="图计算通用软件"></a>图计算通用软件</h1><p>• 针对大型图的计算，目前通用的图计算软件主要包括两种：<br>– 第一种主要是 基于遍历算法 的、 实时的图数据库，如Neo4j、OrientDB、DEX和 Infinite Graph<br>– 第二种则是 以图顶点为中心的、基于消息传递批处理的并行引擎，如GoldenOrb、Giraph、Pregel和Hama，这些图处理软件主要是基于BSP模型实现的并行图处理系统</p>
<p>一次BSP(Bulk Synchronous Parallel Computing Model，又称“大同步”模型)计算过程包括一系列全局超步（所谓的超步就是计算中的一次迭代），每个超<br>步主要包括三个组件：<br>• 局部计算：每个参与的处理器都有自身的计算任务<br>• 通讯：处理器群相互交换数据<br>• 栅栏同步(Barrier Synchronization)：当一个处理器遇到“路障”（或栅栏），会等到其他所有处理器完成它们的计算步骤</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/1.png"></p>
<h1 id="Pregel"><a href="#Pregel" class="headerlink" title="Pregel"></a>Pregel</h1><p>•谷歌公司在2003年到2004年公布了GFS、MapReduce和BigTable<br>•谷歌在后Hadoop时代的新“三驾马车”<br>•Caffeine<br>•Dremel<br>•Pregel<br>•Pregel是一种基于BSP模型实现的并行图处理系统<br>•为了解决大型图的分布式计算问题，Pregel搭建了一套可扩展的、有容错机制的平台，该平台提供了一套非常灵活的API，可以描述各种各样的图计算<br>•Pregel作为分布式图计算的计算框架，主要用于图遍历、最短路径、PageRank计算等等</p>
<h1 id="Pregel图计算模型"><a href="#Pregel图计算模型" class="headerlink" title="Pregel图计算模型"></a>Pregel图计算模型</h1><h2 id="有向图和顶点"><a href="#有向图和顶点" class="headerlink" title="有向图和顶点"></a>有向图和顶点</h2><p>•Pregel计算模型以有向图作为输入<br>•有向图的每个顶点都有一个String类型的顶点ID<br>•每个顶点都有一个可修改的用户自定义值与之关联<br>•每条有向边都和其源顶点关联，并记录了其目标顶点ID<br>•边上有一个可修改的用户自定义值与之关联</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/2.png"></p>
<p>•在每个超步S中，图中的所有顶点都会并行执行相同的用户自定义函数<br>•每个顶点可以接收前一个超步(S-1)中发送给它的消息，修改其自身及其出射边的状态，并发送消息给其他顶点，甚至是修改整个图的拓扑结构<br>•在这种计算模式中，“边”并不是核心对象，在边上面不会运行相应的计算，只有顶点才会执行用户自定义函数进行相应计算</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/3.png"></p>
<h2 id="顶点之间的消息传递"><a href="#顶点之间的消息传递" class="headerlink" title="顶点之间的消息传递"></a>顶点之间的消息传递</h2><p>采用消息传递模型主要基于以下两个原因：<br>（1）消息传递具有足够的表达能力，没有必要使用远程读取或共享内存的方式<br>（2）有助于提升系统整体性能<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/4.png"></p>
<h2 id="Pregel的计算过程"><a href="#Pregel的计算过程" class="headerlink" title="Pregel的计算过程"></a>Pregel的计算过程</h2><p>•Pregel的计算过程是由一系列被称为“超步”的迭代组成的<br>•在每个超步中，每个顶点上面都会并行执行用户自定义的函数，该函数描述了一个顶点V在一个超步S中需要执行的操作<br>•该函数可以读取前一个超步(S-1)中其他顶点发送给顶点V的消息，执行相应计算后，修改顶点V及其出射边的状态，然后沿着顶点V的出射边发送消息给其他顶点，而且，一个消息可能经过多条边的传递后被发送到任意已知ID的目标顶点上去<br>•这些消息将会在下一个超步(S+1)中被目标顶点接收，然后象上述过程一样开始下一个超步(S+1)的迭代过程<br><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/5.png"><br>•在Pregel计算过程中，一个算法什么时候可以结束，是由所有顶点的状态决定的<br>•在第0个超步，所有顶点处于活跃状态<br>•当一个顶点不需要继续执行进一步的计算时，就会把自己的状态设置为“停机”，进入非活跃状态<br>•当一个处于非活跃状态的顶点收到来自其他顶点的消息时，Pregel计算框架必须根据条件判断来决定是否将其显式唤醒进入活跃状态<br>•当图中所有的顶点都已经标识其自身达到“非活跃（inactive）”状态，并且没有消息在传送的时候，算法就可以停止运行</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/7.png"></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/8.png"></p>
<h1 id="Pregel的C-API"><a href="#Pregel的C-API" class="headerlink" title="Pregel的C++ API"></a>Pregel的C++ API</h1><p>Pregel已经预先定义好一个基类——Vertex类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename VertexValue, typename EdgeValue, typename MessageValue&gt;</span><br><span class="line">class Vertex &#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual void Compute(MessageIterator* msgs) = 0;</span><br><span class="line">    const string&amp; vertex_id() const;</span><br><span class="line">    int64 superstep() const;</span><br><span class="line">    const VertexValue&amp; GetValue();</span><br><span class="line">    VertexValue* MutableValue();</span><br><span class="line">    OutEdgeIterator GetOutEdgeIterator(); </span><br><span class="line">    void SendMessageTo(const string&amp; dest_vertex,  const MessageValue&amp; message);</span><br><span class="line">    void VoteToHalt();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>•在Vetex类中，定义了三个值类型参数，分别表示顶点、边和消息。每一个顶点都有一个给定类型的值与之对应<br>•编写Pregel程序时，需要继承Vertex类，并且覆写Vertex类的虚函数Compute()</p>
<h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>• 顶点之间的通讯是借助于消息传递机制来实现的，每条消息都包含了消息值和需要到达的目标顶点ID。用户可以通过Vertex类的模板参数来设定消息值的数据类型<br>• 在一个超步S中，一个顶点可以发送任意数量的消息，这些消息将在下一个超步（S+1）中被其他顶点接收<br>• 一个顶点V通过与之关联的出射边向外发送消息，并且，消息要到达的目标顶点并不一定是与顶点V相邻的顶点，一个消息可以连续经过多条连通的边到达某个与顶点V不相邻的顶点U，U可以从接收的消息中获取到与其不相邻的顶点V的ID</p>
<h2 id="Combiner"><a href="#Combiner" class="headerlink" title="Combiner"></a>Combiner</h2><p>• Pregel计算框架在消息发出去之前，Combiner可以将发往同一个顶点的多个整型值进行求和得到一个值，只需向外发送这个“求和结果”，从而实现了由多个消息合并成一个消息，大大减少了传输和缓存的开销<br>• 在默认情况下，Pregel计算框架并不会开启Combiner功能<br>• 当用户打算开启Combiner功能时，可以继承Combiner类并覆写虚函数Combine()<br>• 此外，通常只对那些满足交换律和结合律的操作才可以去开启Combiner功能</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/9.png"></p>
<h2 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h2><p>• Aggregator提供了一种全局通信、监控和数据查看的机制<br>• 在一个超步S中，每一个顶点都可以向一个Aggregator提供一个数据，Pregel计算框架会对这些值进行聚合操作产生一个值，在下一个超步（S+1）中，图中的所有顶点都可以看见这个值<br>• Aggregator的聚合功能，允许在整型和字符串类型上执行最大值、最小值、求和操作，比如，可以定义一个“Sum”Aggregator来统计每个顶点的出射边数量，最后相加可以得到整个图的边的数量<br>• Aggregator还可以实现全局协同的功能，比如，可以设计“and”Aggregator来决定在某个超步中Compute()函数是否执行某些逻辑分支，只有当“and” Aggregator显示所有顶点都满足了某条件时，才去执行这些逻辑分支</p>
<h2 id="拓扑改变"><a href="#拓扑改变" class="headerlink" title="拓扑改变"></a>拓扑改变</h2><p>• Pregel计算框架允许用户在自定义函数Compute()中定义操作，修改图的拓扑结构，比如在图中增加（或删除）边或顶点<br>• 对于全局拓扑改变，Pregel采用了惰性协调机制<br>• 对于本地的局部拓扑改变，是不会引发冲突的，顶点或边的本地增减能够立即生效，很大程度上简化了分布式编程</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>• 在Pregel计算框架中，图的保存格式多种多样，包括文本文件、关系数据库或键值数据库等<br>• 在Pregel中，“从输入文件生成得到图结构”和“执行图计算”这两个过程是分离的，从而不会限制输入文件的格式<br>• 对于输出，Pregel也采用了灵活的方式，可以以多种方式进行输出</p>
<h1 id="Pregel的体系结构"><a href="#Pregel的体系结构" class="headerlink" title="Pregel的体系结构"></a>Pregel的体系结构</h1><h2 id="Pregel的执行过程"><a href="#Pregel的执行过程" class="headerlink" title="Pregel的执行过程"></a>Pregel的执行过程</h2><p>•在Pregel计算框架中，一个大型图会被划分成许多个分区，每个分区都包含了一部分顶点以及以其为起点的边<br>•一个顶点应该被分配到哪个分区上，是由一个函数决定的，系统默认函数为hash(ID) mod N，其中，N为所有分区总数，ID是这个顶点的标识符；当然，用户也可以自己定义这个函数<br>•这样，无论在哪台机器上，都可以简单根据顶点ID判断出该顶点属于哪个分区，即使该顶点可能已经不存在了</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/10.png"></p>
<p>在理想的情况下（不发生任何错误），一个Pregel用户程序的执行过<br>程如下：<br>（1）选择集群中的多台机器执行图计算任务，有一台机器会被选为Master，其他机器作为Worker<br>（2）Master把一个图分成多个分区，并把分区分配到多个Worker。一个Worker会领到一个或多个分区，每个Worker知道所有其他Worker所分配到的分区情况</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/11.png"></p>
<p>（3）Master会把用户输入划分成多个部分。然后，Master会为每个Worker分配用户输入的一部分。如果一个Worker从输入内容中加载到的顶点，刚好是自己所分配到的分区中的顶点，就会立即更新相应的数据结构。否则，该Worker会根据加载到的顶点的ID，把它发送到其所属的分区所在的Worker上。当所有的输入都被加载后，图中的所有顶点都会被标记为“活跃”状态。</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/12.png"></p>
<p>（4）Master向每个Worker发送指令，Worker收到指令后，开始运行一个超步。当一个超步中的所有工作都完成以后，Worker会通知Master，并把自己在下一个超步还处于“活跃”状态的顶点的数量报告给Master。上述步骤会被不断重复，直到所有顶点都不再活跃并且系统中不会有任何消息在传输，这时，执行过程才会结束。<br>（5）计算过程结束后，Master会给所有的Worker发送指令，通知每个Worker对自己的计算结果进行持久化存储</p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/13.png"></p>
<h2 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h2><p>• Pregel采用检查点机制来实现容错。在每个超步的开始，Master会通知所有的Worker把自己管辖的分区的状态写入到持久化存储设备<br>• Master会周期性地向每个Worker发送ping消息，Worker收到ping消息后会给Master发送反馈消息<br>• 每个Worker上都保存了一个或多个分区的状态信息，当一个Worker发生故障时，它所负责维护的分区的当前状态信息就会丢失。Master监测到一个Worker发生故障“失效”后，会把失效Worker所分配到的分区，重新分配到其他处于正常工作状态的Worker集合上，然后，所有这些分区会从最近的某超步S开始时写出的检查点中，重新加载状态信息</p>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>在一个Worker中，它所管辖的分区的状态信息是保存在内存中的。<br>分区中的顶点的状态信息包括：<br>•顶点的当前值<br>•以该顶点为起点的出射边列表，每条出射边包含了目标顶点ID和边的值<br>•消息队列，包含了所有接收到的、发送给该顶点的消息<br>•标志位，用来标记顶点是否处于活跃状态<br>在每个超步中，Worker会对自己所管辖的分区中的每个顶点进行遍历，并调用顶点上的Compute()函数，在调用时，会把以下三个参数传递进去：<br>•该顶点的当前值<br>•一个接收到的消息的迭代器<br>•一个出射边的迭代器</p>
<p>•在Pregel中，为了获得更好的性能，“标志位”和输入消息队列是分开保存的<br>•对于每个顶点而言，Pregel只保存一份顶点值和边值，但是，会保存两份“标志位”和输入消息队列，分别用于当前超步和下一个超步<br>•如果一个顶点V在超步S接收到消息，那么，它表示V将会在下一个超步S+1中（而不是当前超步S中）处于“活跃”状态</p>
<p>•当一个Worker上的一个顶点V需要发送消息到其他顶点U时，该Worker会首先判断目标顶点U是否位于自己机器上<br>•如果目标顶点U在自己的机器上，就直接把消息放入到与目标顶点U对应的输入消息队列中<br>•如果发现目标顶点U在远程机器上，这个消息就会被暂时缓存到本地，当缓存中的消息数目达到一个事先设定的阈值时，这些缓存消息会被批量异步发送出去，传输到目标顶点所在的Worker上</p>
<h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>•Master主要负责协调各个Worker执行任务，每个Worker会借助于名称服务系统定位到Master的位置，并向Master发送自己的注册信息，Master会为每个Worker分配一个唯一的ID<br>•Master维护着关于当前处于“有效”状态的所有Worker的各种信息，包括每个Worker的ID和地址信息，以及每个Worker被分配到的分区信息<br>•Master中保存这些信息的数据结构的大小，只与分区的数量有关，而与顶点和边的数量无关</p>
<p>•一个大规模图计算任务会被Master分解到多个Worker去执行，在每个超步开始时，Master都会向所有处于“有效”状态的Worker发送相同的指令，然后等待这些Worker的回应<br>•如果在指定时间内收不到某个Worker的反馈，Master就认为这个Worker失效<br>•如果参与任务执行的多个Worker中的任意一个发生了故障失效，Master就会进入恢复模式<br>•在每个超步中，图计算的各种工作，比如输入、输出、计算、保存和从检查点中恢复，都会在“路障（barrier）”之前结束</p>
<p>•Master在内部运行了一个HTTP服务器来显示图计算过程的各种信息<br>•用户可以通过网页随时监控图计算执行过程各个细节<br>    •图的大小<br>    •关于出度分布的柱状图<br>    •处于活跃状态的顶点数量<br>    •在当前超步的时间信息和消息流量<br>    •所有用户自定义Aggregator的值</p>
<h2 id="Aggregator-1"><a href="#Aggregator-1" class="headerlink" title="Aggregator"></a>Aggregator</h2><p>• 每个用户自定义的Aggregator都会采用聚合函数对一个值集合进行聚合计算得到一个全局值<br>• 每个Worker都保存了一个Aggregator的实例集，其中的每个实例都是由类型名称和实例名称来标识的<br>• 在执行图计算过程的某个超步S中，每个Worker会利用一个Aggregator对当前本地分区中包含的所有顶点的值进行归约，得到一个本地的局部归约值<br>• 在超步S结束时，所有Worker会将所有包含局部归约值的Aggregator的值进行最后的汇总，得到全局值，然后提交给Master<br>• 在下一个超步S+1开始时，Master就会将Aggregator的全局值发送给每个Worker</p>
<h1 id="Pregel的应用实例——单源最短路径"><a href="#Pregel的应用实例——单源最短路径" class="headerlink" title="Pregel的应用实例——单源最短路径"></a>Pregel的应用实例——单源最短路径</h1><p>Dijkstra算法是解决单源最短路径问题的贪婪算法</p>
<p>Pregel非常适合用来解决单源最短路径问题，实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ShortestPathVertex</span><br><span class="line">  : public Vertex&lt;int, int, int&gt; &#123;</span><br><span class="line">    void Compute(MessageIterator* msgs) &#123;</span><br><span class="line">    int mindist = IsSource(vertex_id()) ? 0 : INF;</span><br><span class="line">    for (; !msgs-&gt;Done(); msgs-&gt;Next())</span><br><span class="line">    mindist = min(mindist, msgs-&gt;Value());</span><br><span class="line">    if (mindist &lt; GetValue()) &#123;</span><br><span class="line">    *MutableValue() = mindist;</span><br><span class="line">    OutEdgeIterator iter = GetOutEdgeIterator();</span><br><span class="line">    for (; !iter.Done(); iter.Next())</span><br><span class="line">    SendMessageTo(iter.Target(),</span><br><span class="line">    mindist + iter.GetValue());</span><br><span class="line">    &#125;</span><br><span class="line">    VoteToHalt();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/14.png"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/15.png"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/16.png"></p>
<p><img src="%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%A1%E7%AE%97/17.png"><br>超步1：<br>•顶点0：没有收到消息，依然非活跃<br>•顶点1：收到消息100（唯一消息），被显式唤醒，执行计算，mindist变为100，小于顶点值INF，顶点值修改为100，没有出射边，不需要发送消息，最后变为非活跃<br>•顶点2：收到消息30，被显式唤醒，执行计算，mindist变为30，小于顶点值ZNF，顶点值修改为30，有两条出射边，向顶点3发送消息90（即：30+60），向顶点1发送消息90（即：30+60），最后变为非活跃<br>•顶点3：没有收到消息，依然非活跃<br>•顶点4：收到消息10，被显式唤醒，执行计算，mindist变为10，小于顶点值INF，顶点值修改为10，向顶点3发送消息60（即：10+50），最后变为非活跃剩余超步省略……<br>当所有顶点非活跃，并且没有消息传递，就结束</p>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>实现映射</title>
    <url>/2018/08/01/%E5%AE%9E%E7%8E%B0%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>映射也就是Map,这里是指一对一的映射。也成为<code>字典</code>。</p>
<ul>
<li>映射迎来存储键值数据对(Key,Value)</li>
<li>根据Key寻找对应的Value</li>
<li>用链表或者二分搜索树实现比较简单</li>
</ul>
<p>BST的结构:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node left;</span><br><span class="line">  Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表的结构:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即本来存储一个数据的节点现在存储两个(Key,Value).</p>
<p>定义Map接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K key,V value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;            <span class="comment">//删除key对应的键值对,并返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>;  <span class="comment">//是否存已在key</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;               <span class="comment">//获得key对应的value值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key,V newValue)</span></span>; <span class="comment">//更新值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于链表实现Map"><a href="#基于链表实现Map" class="headerlink" title="基于链表实现Map"></a>基于链表实现Map</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//定义节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value,Node node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(key,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key.toString() + <span class="string">&quot;:&quot;</span> + value.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> Node();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Node node = getNode(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            dummyHead.next = <span class="keyword">new</span> Node(key,value,dummyHead.next);</span><br><span class="line">            size ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果已经存在,则进行值的覆盖</span></span><br><span class="line">            node.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(prev.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.next.key.equals(key))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node delNode;</span><br><span class="line">        <span class="keyword">if</span>(prev.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            delNode = prev.next;</span><br><span class="line">            prev.next = delNode.next;</span><br><span class="line">            delNode.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> delNode.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Node result = getNode(key);</span><br><span class="line">        <span class="keyword">return</span> result == <span class="keyword">null</span> ? <span class="keyword">null</span> : result.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">        Node result = getNode(key);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="keyword">null</span>)</span><br><span class="line">            result.value = newValue;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">&quot;doesn&#x27;t exists&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(K k)</span></span>&#123;</span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.key.equals(k))</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于二分搜索树实现Map"><a href="#基于二分搜索树实现Map" class="headerlink" title="基于二分搜索树实现Map"></a>基于二分搜索树实现Map</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//向二分搜索树中添加新元素(key,value)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        root = add(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//借助辅助函数remove(Node node,K key)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Node node = getNode(root,key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = remove(root,key);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root,key) != <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Node node = getNode(root,key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">        Node node = getNode(root,key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">&quot;doesn&#x27;t exist!&quot;</span>);</span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向以node为根的二分搜索树中插入元素,采用递归算法</span></span><br><span class="line">    <span class="comment">//返回插入新节点后二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,K key,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = add(node.left,key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = add(node.right,key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//key.compareTo(node.key)==0</span></span><br><span class="line">            node.value = value;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回以node为根节点的二分搜索树中,key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node,K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除掉以node为根的二分搜索树中键为key的节点</span></span><br><span class="line">    <span class="comment">//返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node,K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = remove(node.left,key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.right = remove(node.right,key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//key.compareTo(node.key) == 0</span></span><br><span class="line">            <span class="comment">//待删除左子树为空</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//待删除右子树为空</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//待删除左右子树均不为空</span></span><br><span class="line">            <span class="comment">//先找到比待删除节点大的最小节点,即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">//用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node successor = minmum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line"></span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minmum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minmum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line">    <span class="comment">//返回删除节点后的最新的二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实明显可以感受到BSTMap的存储速度要快于LinkedListMap</p>
<h1 id="基于链表的Map和基于二分搜索树的Map的时间复杂度对比"><a href="#基于链表的Map和基于二分搜索树的Map的时间复杂度对比" class="headerlink" title="基于链表的Map和基于二分搜索树的Map的时间复杂度对比"></a>基于链表的Map和基于二分搜索树的Map的时间复杂度对比</h1><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">LinkedListMap</th>
<th align="center">BSTMap(平均)</th>
<th align="center">BSTMap最差)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增add</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">删remove</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">改set</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">查get</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">查contains</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实现栈和队列</title>
    <url>/2018/07/17/%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈在计算机中有很广泛的应用，比如括号的匹配用到了栈，系统栈，撤销操作。</p>
<p>栈也是一种线性结构。相比数组，栈对应的操作是数组的子集。只能从一端添加元素，从同一端取出元素，即栈顶。是一种后进先出的数据结构(Last In First Out (LIFO))</p>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>栈的实际底层实现有多种方式，如动态数组，链表等。</p>
<p>这里只实现栈的几个基本操作：入栈，出栈，查看栈顶元素，查看栈元素数量，查看栈是否为空。</p>
<p>定义Stack接口，基于动态数组实现栈，动态数组的实现见</p>
<p><a href="https://homxuwang.github.io/2018/07/17/%E6%95%B0%E7%BB%84/">https://homxuwang.github.io/2018/07/17/%E6%95%B0%E7%BB%84/</a></p>
<p>首先在程序中创建上面链接中的<code>Array</code>类<br>然后创建<code>Stack</code>接口<br><code>Interface Stack&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;      <span class="comment">//获取元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;     <span class="comment">//进栈</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;            <span class="comment">//出栈</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;           <span class="comment">//查看栈顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayStack</code>基于动态数组实现的栈类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 定义容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得栈的容量,这个方法与栈的接口无关,只有在使用动态数组的时候才有这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getCapacity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        array.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">&quot;Stack:&quot;</span>);</span><br><span class="line">        res.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.getSize(); i++)&#123;</span><br><span class="line">            res.append(array.get(i));</span><br><span class="line">            <span class="keyword">if</span>(i != array.getSize() - <span class="number">1</span>)&#123;</span><br><span class="line">                res.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">&quot;] top&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Main函数中进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayStack&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/1.png" alt="栈测试"></p>
<h2 id="栈的复杂度分析"><a href="#栈的复杂度分析" class="headerlink" title="栈的复杂度分析"></a>栈的复杂度分析</h2><p>ArrayStack<E></p>
<p>void push(e)    O(1)   均摊<br>E pop()         O(1)   均摊<br>E peek()        O(1)<br>int getSize()   O(1)<br>boolean isEmpty()  O(1)</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列也是一种线性结构。先进先出(First In First Out(FIFO))</p>
<h2 id="一般队列的实现"><a href="#一般队列的实现" class="headerlink" title="一般队列的实现"></a>一般队列的实现</h2><p>定义Queue接口，基于动态数组实现队里，动态数组的实现见</p>
<p><a href="https://homxuwang.github.io/2018/07/17/%E6%95%B0%E7%BB%84/">https://homxuwang.github.io/2018/07/17/%E6%95%B0%E7%BB%84/</a></p>
<p>基于<code>Array</code>类创建<code>Queue</code>接口</p>
<p><code>Interface Queue&lt;E&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;      <span class="comment">//获取元素个数</span></span><br><span class="line">  <span class="keyword">boolean</span> isEmpty;    <span class="comment">//判断队列是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;  <span class="comment">//入队</span></span><br><span class="line">  <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;        <span class="comment">//出队</span></span><br><span class="line">  <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;       <span class="comment">//查看队首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层采用动态数组<code>Array</code>类来实现队列,创建队列类<code>ArrayQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getCapacity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        array.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">&quot;Queue:&quot;</span>);</span><br><span class="line">        res.append(<span class="string">&quot;front[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.getSize() ; i ++)&#123;</span><br><span class="line">            res.append(array.get(i));</span><br><span class="line">            <span class="keyword">if</span>(i != array.getSize() - <span class="number">1</span>)</span><br><span class="line">                res.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">&quot;]end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ArrayQueue&lt;Integer&gt;  queue = <span class="keyword">new</span> ArrayQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        queue.enqueue(i);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            queue.dequeue();</span><br><span class="line">            System.out.println(queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.png" alt="队列测试"></p>
<h2 id="一般队列的复杂度分析"><a href="#一般队列的复杂度分析" class="headerlink" title="一般队列的复杂度分析"></a>一般队列的复杂度分析</h2><p>void enqueue(E)       O(1) 均摊<br>E dequeue()           O(n)<br>E getFront()          O(1)<br>int getSize()         O(1)<br>boolean isEmpty()     O(1)</p>
<p>可以看到一般队列的出队过程因为要往前挪动一个元素，导致其时间复杂度是O(n)</p>
<h2 id="循环队列的实现"><a href="#循环队列的实现" class="headerlink" title="循环队列的实现"></a>循环队列的实现</h2><p>在一般队列的基础上，引入<code>front</code>指向队列头,<code>tail</code>指向队列尾。<code>front == tail</code> 队列为空。在出队后，不用挪动元素，而是让<code>front</code>的指向后移，同时，添加元素时<code>tail</code>向后挪，指向第一个未添加元素的地方。在队列满的情况下，索引+1后对数组长度求余得到<code>tail</code>的位置。但是若<code>tail</code>指向的事最后一个未添加元素的位置时，再向其中添加元素，此时<code>tail</code>后挪后就导致<code>tail == front</code>而当<code>front == tail</code>时表示队列为空。所以用<code>(tail + 1) % 数组容量 == front</code>(tail + 1 % 数组容量 是因为如图，如果front == 0 ,tail == 7时也是满的) 表示队列已满，这时候进行扩容。即浪费一个空间。</p>
<p><img src="%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/3.png" alt="环形队列满"></p>
<p>循环队列底层不再使用上文将到的动态数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> E[] data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> front, tail; <span class="comment">//front表示队首所指的索引，tail指向队列最后一个元素的下一个位置所在的索引，也就是入队新的元素所存放的位置对应的索引</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//队列中有多少元素(也可以用tail和front进行控制)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    data = (E[])<span class="keyword">new</span> Object[capacity + <span class="number">1</span>]; <span class="comment">//因为上文提到要预留一个空间，所以这里+1</span></span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//无参构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.length - <span class="number">1</span>; <span class="comment">//真正能够存储的数据大小是length - 1，因为预留了一个空间</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> front == tail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((tail + <span class="number">1</span>) % data.length == front)&#123; <span class="comment">//如果队列满了,则调用resize()函数</span></span><br><span class="line">      resize(getCapacity() * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[tail] = e;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % data.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Canno dequeuq from an empty queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    E temp = data[front];</span><br><span class="line">    data[front] = <span class="keyword">null</span>;</span><br><span class="line">    front = (front + <span class="number">1</span>) % data.length;</span><br><span class="line">    size --;</span><br><span class="line">    <span class="keyword">if</span>(size == getCapacity() / <span class="number">4</span> &amp;&amp; getCapacity() / <span class="number">2</span> != <span class="number">0</span>)&#123; <span class="comment">//如果队列元素个数小于容量的1/4则进行缩容</span></span><br><span class="line">      resize(getCapacity() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> data[front];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">    E[] newData = (E[])<span class="keyword">new</span> Object[newCapacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">      newData[i] = data[(front + i) % data.length];</span><br><span class="line">    &#125;</span><br><span class="line">    data = newData;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = size;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *便于打印输出</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      res.append(String.format(<span class="string">&quot;Queue: Size = %d , capacity = %d \n&quot;</span>,size,getCapacity()));</span><br><span class="line">      res.append(<span class="string">&quot;front[&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = front ; i != tail ; i = (i + <span class="number">1</span> ) % data.length)&#123;</span><br><span class="line">          res.append(data[i]);</span><br><span class="line">          <span class="keyword">if</span>((i + <span class="number">1</span>) % data.length != tail)</span><br><span class="line">              res.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      res.append(<span class="string">&quot;] tail&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  LoopQueue&lt;Integer&gt;  queue = <span class="keyword">new</span> LoopQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">      queue.enqueue(i);</span><br><span class="line">      System.out.println(queue);</span><br><span class="line">      <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">          queue.dequeue();</span><br><span class="line">          System.out.println(queue);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码结果：<br><img src="%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/4.png" alt="循环队列结果"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实现线段树</title>
    <url>/2018/08/13/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>当更关心某个区间上的问题时，使用线段树（区间树）会更方便。</p>
<ul>
<li>线段树是一种二叉搜索树</li>
<li>线段树每个节点存放一个区间内相应的信息</li>
<li>一般用静态数组表示</li>
<li>线段树不一定是一棵完全二叉树</li>
<li>线段树是平衡二叉树（最大深度和最小深度的差最大为1）</li>
</ul>
<p><img src="%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91/1.png" alt="线段树"></p>
<p>例如，如果线段树想表示区间的和，那么每个节点存放的不是对应的数组，而是这个区间的和。</p>
<p>线段树依然可以使用数组表示。<br>那么对于一个区间有n个元素，数组的大小该如何确定？<br>对于一个满二叉树，如果有h层（从0层到h-1层），那么h层就有<code>2^h-1</code>个节点，差不多是<code>2^h</code>，最后一层(h-1)层，有<code>2^(h-1)</code>个节点，最后一层的节点的数目大约是前面的几点数目之和。</p>
<p>所以，如果用数组开辟空间，那么如果<code>n=2^k</code>(即恰好为2的整数次幂),需要2n的空间（这是满二叉树的情况），但是如果<code>n=2^k+1</code>（即n&gt;2^k,也就是最坏的情况），则需要4n的空间。</p>
<p><img src="%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91/2.png" alt="线段树所需要的数组大小"></p>
<p>结论：因为线段树不考虑添加元素，也就是区间的大小是固定的，所以使用4n的静态空间就可以满足所有情况。（这里有空间浪费）</p>
<h1 id="创建线段树"><a href="#创建线段树" class="headerlink" title="创建线段树"></a>创建线段树</h1><p>线段树的根节点的信息，是两个孩子节点的信息的综合。比如求和，根节点的值就是左右孩子节点的值之和，依次类推，那么可以采用递归的方法进行求值。</p>
<p>另外，在进行线段树的创建时，因为不知道要采取什么样的方法去创建（比如求和，求积，求最大值，求最小值等），所以可以定义一个<code>Merger</code>接口，要求在创建线段树时，其构造函数不但要传入一个初始的数组，也要传入一个merger，即相应的要采取的操作。</p>
<p><code>Merger</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//融合器，即线段树进行什么操作(求和或者求乘积等操作)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merger</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">merge</span><span class="params">(E a,E b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;<span class="comment">//数组arr的副本</span></span><br><span class="line">    <span class="keyword">private</span> E[] tree; <span class="comment">// 将数据以树的形式表示出来,看成一个满二叉树</span></span><br><span class="line">    <span class="keyword">private</span> Merger&lt;E&gt; merger; <span class="comment">//传入一个merger，定义用户要进行的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr,Merger&lt;E&gt; merger)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            data[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree = (E[]) <span class="keyword">new</span> Object[<span class="number">4</span> * arr.length];</span><br><span class="line">        buildSegmentTree(<span class="number">0</span>,<span class="number">0</span>,data.length - <span class="number">1</span>    );<span class="comment">//创建SegmentTree</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Index is illegal.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回以完全二叉树的数组表示中，一个索引表示的元素的左孩子所在节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回以完全二叉树的数组表示中，一个索引表示的元素的右孩子所在节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *在treeIndex的位置创建表示区间[l,r]的线段树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeIndex 要创建的线段树根节点对应的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 对于此节点对应的左端点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 对于此节点对应的右端点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex,<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            tree[treeIndex] = data[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//l &lt; r</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右子树的index，即在数组中的索引</span></span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右子树相应的区间的中间位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//为了防止(l + r) / 2 溢出</span></span><br><span class="line"></span><br><span class="line">        buildSegmentTree(leftTreeIndex,l,mid);</span><br><span class="line">        buildSegmentTree(rightTreeIndex,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用merger接口类对象，进行相应的操作</span></span><br><span class="line">        tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; tree.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[i] != <span class="keyword">null</span>)</span><br><span class="line">                res.append(tree[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i != tree.length - <span class="number">1</span>)</span><br><span class="line">                res.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Main函数中进行测试，并打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] nums = &#123;-<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">2</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        SegmentTree&lt;Integer&gt; segTree = <span class="keyword">new</span> SegmentTree&lt;&gt;(nums, <span class="keyword">new</span> Merger&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">merge</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(segTree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91/3.png" alt="测试结果"></p>
<p>生成如下的线段树：<br><img src="%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91/4.png" alt="生成的线段树"></p>
<h1 id="线段树的查询操作"><a href="#线段树的查询操作" class="headerlink" title="线段树的查询操作"></a>线段树的查询操作</h1><p>用户可以输入要查询的某个区间，返回这个区间内的对应的值。</p>
<p>相应的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 返回要查询的区间[queryStart,queryEnd]的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> queryStart,<span class="keyword">int</span> queryEnd)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(queryStart &lt; <span class="number">0</span> || queryStart &gt;= data.length || queryEnd &lt; <span class="number">0</span> || queryEnd &gt;= data.length || queryStart &gt; queryEnd)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Index&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> query(<span class="number">0</span>,<span class="number">0</span>,data.length-<span class="number">1</span>,queryStart,queryEnd);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义私有函数，在以treeIndex为根的线段树中[l,r]的范围里，搜索区间[queryStart,queryEnd]的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> treeIndex 要查询的树的根节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> l 树对应的数组的左范围</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> r 树对应的数组的右范围</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> queryStart 要查询的区间的左端</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> queryEnd 要查询的区间的右端</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> queryStart,<span class="keyword">int</span> queryEnd)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l == queryStart &amp;&amp; r == queryEnd)</span><br><span class="line">         <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> leftIndex = leftChild(treeIndex);</span><br><span class="line">     <span class="keyword">int</span> rightIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(queryStart &gt;= mid+<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> query(rightIndex,mid+<span class="number">1</span>,r,queryStart,queryEnd);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(queryEnd &lt;= mid)</span><br><span class="line">         <span class="keyword">return</span> query(leftIndex,l,mid,queryStart,queryEnd);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//否则，跨左右区间，分别求左右区间的值，然后merg，返回</span></span><br><span class="line">     E leftResult = query(leftIndex,l,mid,queryStart,mid);</span><br><span class="line">     E rightResult = query(rightIndex,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,queryEnd);</span><br><span class="line">     <span class="keyword">return</span> merger.merge(leftResult,rightResult);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树的更新操作"><a href="#线段树的更新操作" class="headerlink" title="线段树的更新操作"></a>线段树的更新操作</h1><p>线段树的更新，是针对某个index位置的数据进行更新，使用线段树进行更新操作，其时间有优势，时间复杂度为O(logn)</p>
<p>更新操作的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将index位置的值更新为e</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index 待更新的位置索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e 更新后的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= data.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal index.&quot;</span>);</span><br><span class="line">    set(<span class="number">0</span>,<span class="number">0</span>,data.length - <span class="number">1</span>,index,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在以treeIndex为根的线段树中，更新index的值为e</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex,<span class="keyword">int</span> l , <span class="keyword">int</span> r,<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[treeIndex] = e;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l +(r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= mid+<span class="number">1</span>)</span><br><span class="line">        set(rightTreeIndex,mid+<span class="number">1</span>,r,index,e);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//index &lt;= mid</span></span><br><span class="line">        set(leftTreeIndex,l,mid,index,e);</span><br><span class="line"></span><br><span class="line">    tree[treeIndex] = merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实现集合</title>
    <url>/2018/08/01/%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>因为集合是不存放重复元素的，所以使用二分搜索树来实现集合很合适。<br>集合的几个简单方法:</p>
<ul>
<li>void add(E) //添加元素，但不能添加重复元素</li>
<li>void remove(E) //删除元素E</li>
<li>boolean contains(E) //是否包含元素E</li>
<li>int getSize()  //获得集合的size</li>
<li>boolean isEmpty() //判断集合是否为空</li>
</ul>
<h1 id="基于二分搜索树的实现"><a href="#基于二分搜索树的实现" class="headerlink" title="基于二分搜索树的实现"></a>基于二分搜索树的实现</h1><p>首先使用二分搜索树做底层实现集合类。二分搜索树的实现代码：<a href="https://homxuwang.github.io/2018/07/18/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">https://homxuwang.github.io/2018/07/18/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</a></p>
<p>创建集合接口类<code>Set</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containes</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建实现集合的类<code>BSTSet</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BST&lt;E&gt; bst;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bst = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        bst.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        bst.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containes</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.contains(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实<code>BSTSet</code>集合类只是简单的调用了其基础类<code>BST</code>类的方法。就可以实现集合类的各个功能。</p>
<h1 id="基于链表的实现"><a href="#基于链表的实现" class="headerlink" title="基于链表的实现"></a>基于链表的实现</h1><h2 id="链表结构的实现"><a href="#链表结构的实现" class="headerlink" title="链表结构的实现"></a>链表结构的实现</h2><p>首先链表的实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> next</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e,Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(e,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> Node();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回链表中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表头添加新的元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line"><span class="comment">//        Node node = new Node(e);</span></span><br><span class="line"><span class="comment">//        node.next = head;</span></span><br><span class="line"><span class="comment">//        head = node;</span></span><br><span class="line">        <span class="comment">//和上面三行相等</span></span><br><span class="line">        add(<span class="number">0</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表末尾添加新的元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        add(size,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在中间位置插入新的元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;illegal index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index ; i++)&#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(e);</span><br><span class="line">        node.next = prev.next;</span><br><span class="line">        prev.next = node;</span><br><span class="line"></span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得链表中index位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Get failed.Illegal index.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; index ; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur.e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得链表的第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得链表的最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改链表index位置的元素为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Set failed.Illegal index.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index ; i++ )&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.e = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查链表中是否有元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.e.equals(e))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表中删除index(0-based)位置的元素, 返回删除的元素</span></span><br><span class="line">    <span class="comment">// 在链表中不是一个常用的操作，练习用：）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Remove failed. Index is illegal.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index  ; i ++)</span><br><span class="line">            prev = prev.next;</span><br><span class="line"></span><br><span class="line">        Node retNode = prev.next;</span><br><span class="line">        prev.next = retNode.next;</span><br><span class="line">        retNode.next = <span class="keyword">null</span>;</span><br><span class="line">        size --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retNode.e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表中删除第一个元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表中删除最后一个元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表中删除元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(prev.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.next.e.equals(e))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prev.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node delNode = prev.next;</span><br><span class="line">            prev.next = delNode.next;</span><br><span class="line">            delNode.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(cur.e + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于链表的集合的实现"><a href="#基于链表的集合的实现" class="headerlink" title="基于链表的集合的实现"></a>基于链表的集合的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.contains(e))  <span class="comment">//判断是否已存在元素e</span></span><br><span class="line">            list.addFirst(e);   <span class="comment">//在链表头添加元素比较省时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        list.removeElement(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containes</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.contains(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h1><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">LinkedListSet</th>
<th align="center">BSTSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增add</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">删remove</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
</tr>
<tr>
<td align="center">查contains</td>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
</tr>
</tbody></table>
<p>BSTSet的时间复杂度O(logn)的情况是指平均情况，在极端情况下,有可能就是一个链表，这时候的时间复杂度就是O(n). </p>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><p>用代码比较两种数据结构的时间,测试类<code>FileOperation</code>,找一个英文电子书进行统计分析,统计其词汇总数和词汇量.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOperation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取文件名称为filename中的内容，并且将其中包含的所有词语放进words中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">readFiles</span><span class="params">(String filename,ArrayList&lt;String&gt; words)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(filename == <span class="keyword">null</span> || words == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filename is null or words is null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件读取</span></span><br><span class="line">        Scanner scanner;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(fis),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                scanner.useLocale(Locale.ENGLISH);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cannot open &quot;</span>+ filename);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///简单分词</span></span><br><span class="line">        <span class="keyword">if</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String contents = scanner.useDelimiter(<span class="string">&quot;\\A&quot;</span>).next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> start = firstCharacterIndex(contents,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; contents.length();)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == contents.length() || !Character.isLetter(contents.charAt(i)))&#123;</span><br><span class="line">                    String word = contents.substring(start,i).toLowerCase();</span><br><span class="line">                    words.add(word);</span><br><span class="line">                    start = firstCharacterIndex(contents,i);</span><br><span class="line">                    i = start +<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstCharacterIndex</span><span class="params">(String s,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isLetter(s.charAt(i)))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Main</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Harry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt;  words1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        FileOperation.readFiles(<span class="string">&quot;C:\\Users\\homxu\\Desktop\\Harry Potter and the Sorcerer&#x27;_one .mobi&quot;</span>,words1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total words:&quot;</span>+words1.size());</span><br><span class="line"></span><br><span class="line">        BSTSet&lt;String&gt; set1 = <span class="keyword">new</span> BSTSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:words1)</span><br><span class="line">            set1.add(word);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dif Words:&quot;</span> + set1.getSize());</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; words2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        FileOperation.readFiles(<span class="string">&quot;C:\\Users\\homxu\\Desktop\\Harry Potter and the Sorcerer&#x27;_one .mobi&quot;</span>,words2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total words:&quot;</span>+words2.size());</span><br><span class="line">        LinkedListSet&lt;String&gt; set2 = <span class="keyword">new</span> LinkedListSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:words2)&#123;</span><br><span class="line">            set2.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dif Words:&quot;</span> + set2.getSize());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的电脑上的运行结果，使用两种底层的数据结构实现的集合类结果是一样的。但是运行过程中明显感觉到BSTSet的速度要比LinkedListSet的速度快<br><img src="%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/1.png"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实现动态数组</title>
    <url>/2018/07/17/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>因为数组开辟时是静态的。在这里底层使用静态数组二次封装一个属于自己的动态数组类<code>Array</code></p>
<h1 id="Array类"><a href="#Array类" class="headerlink" title="Array类"></a>Array类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> E[] data; <span class="comment">//开辟一个数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//指向第一个没有元素的索引，也代表数组中有多少个有效的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 有参构造函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> capacity 数组的容量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">      data = (E[])<span class="keyword">new</span> Object[capacity];</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认构造函数,默认容量给10</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数组中的元素个数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>元素个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数组的容量</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>数组的大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回数组是否为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入新元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 在index插入</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 新元素的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//index不能为负,index如果大于size说明数组不是紧密排列的,则不合法</span></span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;add() failed. Require index &gt;= 0 &amp;&amp; index &lt;= size&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(size == data.length)&#123; <span class="comment">//如果此时元素个数等于数组长度，则进行动态扩容</span></span><br><span class="line">          resize(<span class="number">2</span> * data.length);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将元素往后挪动</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = size-<span class="number">1</span> ; i &gt;= index ; i-- )&#123;</span><br><span class="line">          data[i+<span class="number">1</span>] = data[i];</span><br><span class="line">      &#125;</span><br><span class="line">      data[index] = e;</span><br><span class="line">      size ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向所有元素后添加一个新元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">     add(size,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在数组头部插入一个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 元素位置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      add(<span class="number">0</span>,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取index位置的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 要获取的元素的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 元素值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Get failed,Index is illegal&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> data[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取最后一个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 最后一个元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取第一个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 第一个元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改Index索引位置的元素为e</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 要修改的元素的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 要修改的元素的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Set failed,Index is illegal&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      data[index] = e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *查找数组中是否含有元素e</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 要查找的元素的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(data[i].equals(e))</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找数组中元素e所在的索引,如果不存在则返回-1</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 要查找的元素的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回索引或者-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(data[i].equals(e))</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从数组中删除第一个元素elem</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> elem</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(E elem)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> index = find(elem);</span><br><span class="line">      <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">          remove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除Index位置的元素,返回index位置的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index 要删除的索引位置的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回删除的元素的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Remove failed.Index is illegal&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      E temp = data[index];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span>  ; i &lt; size ; i++)&#123;</span><br><span class="line">          data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">      &#125;</span><br><span class="line">      size --;</span><br><span class="line">      data[size] = <span class="keyword">null</span>; <span class="comment">// loitering objects. 释放size位置的内容(非必须，因为访问不到)</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>)&#123; <span class="comment">//如果删除元素过多，少于四分之一则数组缩小容量</span></span><br><span class="line">          resize(data.length / <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除第一个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除数组中最后一个元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> remove(size-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 覆盖父类的方法,定义本类在打印输出时打印的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 打印输出数组字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      res.append(String.format(<span class="string">&quot;Array: size = %d,capacity = %d\n&quot;</span>,size,data.length));</span><br><span class="line">      res.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++)&#123;</span><br><span class="line">          res.append(data[i]);</span><br><span class="line">          <span class="keyword">if</span>(i != size - <span class="number">1</span>)</span><br><span class="line">              res.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      res.append(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 扩容数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newCapacity 新的数组的大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">      E[] newData =(E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; size ; i++) &#123;</span><br><span class="line">          newData[i] = data[i];</span><br><span class="line">      &#125;</span><br><span class="line">      data = newData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>1.实现动态数组的关键函数是类中的<code>resize()</code>函数，动态数组的底层实现有多种方式，比如本文讲到的使用静态数组进行扩容缩容，或者使用链表。<br>动态数组的实现原理其实非常简单，假设数组的已经满了，那么如果继续添加元素，则会报出异常。<br>实现动态数组的思路是，如果这时候数组满了，那么开辟一个新的数组，这个新数组的容量比原数组大(比如是原数组的1.5倍或者2倍,本文采用2倍)，然后将原数组的数据拷贝到新开辟的大数组中(这里需要循环),原来的数组<code>data</code>实际上是一个引用，在拷贝之后将<code>data</code>指向新的数组<code>newData</code>,这时候<code>data</code>这个成员变量和<code>newData</code>指向的是同一个空间，因为<code>newData</code>是封装在函数中，在函数执行结束后就失效了,而<code>data</code>是在整个类中的，它的生命周期是和类一样的。而原来的数组，因为没有东西指向它，java的垃圾回收机制会自动回收。这样扩容过程就结束了。</p>
<p>2.在<code>remove()</code>函数中，有一个缩容的操作，即当前的元素个数小到一定程度的时候，调用resize()函数，缩小数组的容量为当前数组容量的一半。这里是小于四分之一，<code>并且缩小一半后的容量不能为0</code>(所以在条件中判断data.length / 2 != 0)，这时再执行缩小操作。缩容的界限之所以选取1/4是因为如果removeLast()后刚好是数组的一半了，这时候进行缩容，然后又进行添加的时候，这时候又要进行扩容，这样如果有频繁的增删操作，在resize()函数中就会耗费大量的时间，所以采取Lazy解决方案。在删除元素后元素是1/2时，不着急进行缩容操作，而是等到元素为容量的1/4之一时再进行缩容，只缩容1/2，还留出1/4的空间。这样就防止了复杂度的震荡。</p>
<h1 id="简单的复杂度分析"><a href="#简单的复杂度分析" class="headerlink" title="简单的复杂度分析"></a>简单的复杂度分析</h1><p>·添加操作</p>
<p> addLast(e)    O(1)</p>
<p> addFirst(e)   O(n)</p>
<p> add(index,e)  O(n/2) = O(n) //这里是简单的计算，严格计算需要使用概率论的知识，使用期望</p>
<p> resize()      O(n)</p>
<p> 所以添加操作的整体时间复杂度是O(n)</p>
<p>·删除操作</p>
<p> removeLast(e)    O(1)</p>
<p> removeFirst(e)   O(n)</p>
<p> remove(index,e)  O(n/2) = O(n)</p>
<p> resize()         O(n)</p>
<p> 整体时间复杂度是O(n)</p>
<p>·修改操作</p>
<p> set(index,e)     O(1)</p>
<p>·查找操作</p>
<p> get(index)       O(1)</p>
<p> contains(e)      O(n)</p>
<p> find(e)          O(n)</p>
<p> 总结: ·增 O(n)  ·删 O(n)  ·改 已知索引O(1);未知索引O(n) ·查 已知索引O(1);未知索引O(n)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2019/01/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集-Union-Find-的概念"><a href="#并查集-Union-Find-的概念" class="headerlink" title="并查集(Union Find)的概念"></a>并查集(Union Find)的概念</h1><p>并查集是由孩子指向父亲的树结构。可以高效的回答连接问题，判断网络中节点间的连接问题。<br>并查集对于一组数据主要支持两个动作:</p>
<ul>
<li>union(p,q)</li>
<li>isConnected(p,q)</li>
</ul>
<h1 id="并查集的简单实现"><a href="#并查集的简单实现" class="headerlink" title="并查集的简单实现"></a>并查集的简单实现</h1><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;    <span class="comment">//并查集一共有多少个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnectted</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>; <span class="comment">//id为p何id为q的元素是否相连</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>; <span class="comment">//连接id为p和id为q的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里不考虑并查集的增删操作。</p>
<h2 id="基本数据表示"><a href="#基本数据表示" class="headerlink" title="基本数据表示"></a>基本数据表示</h2><p>假设0<del>9是十个不同的数据，它可以代表实际生活中的任何物体，但是在这里只把它抽象为十个数据。对于每一个元素，并查集存储的是这个元素所属的集合的id.比如图中0</del>4属于集合0,5~9属于集合1.</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" alt="基本数据表示"></p>
<p>将上面的数组称为id,通过这个数组,就能很轻松的回答连接问题，即只要对应的id值相同，那么他们就是一类，也即它们是连接的。那么回答isConnected(p,q) 就是求 find(p) == find(q)</p>
<h1 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h1><p>基于上面的内容，可知<code>find</code>操作的时间复杂度是O(1)的。实现QuickFind的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">QuickFind方法</span></span><br><span class="line"><span class="comment">unionElements(p,q)的时间复杂度为0(n)</span></span><br><span class="line"><span class="comment">isConnectted(p,q)的时间复杂度为0(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> <span class="keyword">implements</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化时，每个元素对应的id都是不同的，将每个id的值设置为i对应的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找元素p对应的集合编号</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= id.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is outof bound&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看元素p和元素q是否属于一个集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnectted</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在QuickFind方法下，虽然查找的时间复杂度很低，但是union操作却很耗费时间。比如在上图中，<code>4</code>和<code>5</code>属于不同的集合，如果union(4,5),那么对应的<code>0~4</code>和<code>5~9</code>都应该属于一个集合，这时候他们的id都为0或1,所以要对整个数组进行遍历，将id值对比并且改变为0或1.<br>所以QuickFind下的Union操作的时间复杂度为O(n).</p>
<p>实现Union操作的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p ,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pID = find(p);</span><br><span class="line">        <span class="keyword">int</span> qID = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pID == qID)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(id[i] == pID)&#123;</span><br><span class="line">                id[i] = qID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="QuickUnion"><a href="#QuickUnion" class="headerlink" title="QuickUnion"></a>QuickUnion</h1><p>QuickUnion的思路是把每一个元素看成树中的一个节点，并查集中的树结构是孩子指向父亲的树结构。</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png"></p>
<p>如果有更复杂的情况，一棵树中的元素要和另一元素进行合并，就让一棵树的根节点指向另一颗树的根节点即可。如下图:</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/3.png"></p>
<p>在QuickUnion下的数据表示:<br><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/4.png" alt="QuickUnion下的数据表示"></p>
<p>在QuickUnion下，parent[i]表示这个节点指向的父节点是谁。初始化时，parent[i]都是i.在这种情况下，假设要Union<code>4</code>和<code>3</code>,就将parent[4] = 3即可.</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/5.png" alt="初始化时每个元素指向自己"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
</tbody></table>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/6.png" alt="Union(3,4)"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center"><font color='red'>3</font></td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
</tbody></table>
<p>如果继续union(3,8)</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/7.png" alt="Union(3,8)"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center"><font color='red'>8</font></td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
</tbody></table>
<p>继续union(9,4),查询4的根节点:4-&gt;3-&gt;8-&gt;8,则4的根节点是8.则让9指向8.当然这里有可能使8指向9,如果数据过多，成为链表就体现不出树的优势了。<br><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/8.png" alt="Union(9,4)"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">8</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center"><font color='red'>8</font></td>
</tr>
</tbody></table>
<p>所以Union操作无非就是找到当前要合并的两个元素的根节点，然后让其中一个指向另一个即可。所以Union操作的时间复杂度是O(h),h为树的高度。QucikUnion下的find操作就要比QuickFind下的find操作慢一些，因为这牵扯到查找元素的根,消耗的时间是要比QuickFind多的,查询所需要的时间复杂度为O(h)</p>
<p>实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UnionFind2</span></span><br><span class="line"><span class="comment">QuickUnion方法</span></span><br><span class="line"><span class="comment">parent数组表示当前元素指向的父元素是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind2</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind2</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">            parent[i] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程,查找元素p所对应的元素编号,即父节点,直到最后找到根节点</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt; <span class="number">0</span> || p &gt;= parent.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看元素p和元素q是否属于一个集合</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnectted</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于size的优化"><a href="#基于size的优化" class="headerlink" title="基于size的优化"></a>基于size的优化</h1><p>在进行测试时，当数据的size很大，进行的合并或者查找操作较小时，UnionFind2有很大的时间优势，而当size很大，进行合并或者查找的操作也很大时，UnionFind2的时间会增长。<br>其中一个原因是，在使用UnionFind1进行合并操作时，其实就是对一片连续的空间进行循环操作，这种操作在java的jvm中有很好的优化，所以运行速度很快。而UnionFind2中的find操作，是一个不断索引的过程，不是顺次访问一片连续的空间，在不同的地址间进行跳转，所以会慢。另一个原因是，UnionFind2中的各个操作都是O(h)级别的，当合并或者查找操作数较多，在Union操作时，过多的元素被放在了一个集合中，所以得到的这棵树就很大，对应的它的深度就有可能很高，所以后续的isConnected的时候所消耗的时间也会很高。</p>
<p>所以可以在Union时，针对树的特点进行优化。</p>
<p>可以考虑这种情况，在不断执行union操作时，union(0,1),union(0,2)….union(0,9),在最坏的情况下，树的高度就是元素的个数，也就是树退化为了一个链表。这是因为合并的时候没有对树的高度进行判断，其中一个方法就是对当前的树考虑它有多少个子树。</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/9.png"></p>
<p>在上图中，如果要进行union(4,9)操作，那么为了减小树的高度，应该让9-&gt;8,得到结果如下图:</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/10.png" alt="union(4,9)"></p>
<p>即将元素个数少的树的根节点指向元素个数多的树的根节点，这样就是基于size的优化.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UnionFind3</span></span><br><span class="line"><span class="comment">对UnionFind2的union进行优化,基于size的优化</span></span><br><span class="line"><span class="comment">QuickUnion方法</span></span><br><span class="line"><span class="comment">parent数组表示当前元素指向的父元素是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind3</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz; <span class="comment">//sz[i]表示以i为根的集合中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind3</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">            parent[i] = i ;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程,查找元素p所对应的元素编号,即父节点,直到最后找到根节点</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt; <span class="number">0</span> || p &gt;= parent.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看元素p和元素q是否属于一个集合</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnectted</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">        <span class="comment">//将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">        <span class="keyword">if</span>(sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot]; <span class="comment">//qRoot为根的集合树变大了，元素数多了sz[pRoot]个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始时,<code>sz[i] = 1</code>表示每个集合中的元素只有一个,<code>unionElements</code>方法中，在改变根节点的同时，维护sz的大小.</p>
<h1 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a>基于rank的优化</h1><p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/11.png"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
</tbody></table>
<p>对于上面的并查集，进行union(4,2),如果是基于size的优化方法，则是节点8指向节点7，如下图:</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/12.png" alt="union(4,2)"><br>但是树的深度增加了大于2的高度，树的高度高的节点指向了树的高度低的节点。</p>
<p>所以一个更好的优化union方法，应该是让深度低的树的根节点指向深度高的树的根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UnionFind4</span></span><br><span class="line"><span class="comment">对UnionFind3的union进行优化,基于rank的优化</span></span><br><span class="line"><span class="comment">QuickUnion方法</span></span><br><span class="line"><span class="comment">parent数组表示当前元素指向的父元素是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind4</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank; <span class="comment">//rank[i]表示以i为根的集合中树的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind4</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)&#123;</span><br><span class="line">            parent[i] = i ;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找过程,查找元素p所对应的元素编号,即父节点,直到最后找到根节点</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt; <span class="number">0</span> || p &gt;= parent.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看元素p和元素q是否属于一个集合</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnectted</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">//O(h)复杂度,h为树的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据两个元素所在树的rank不同判断合并方向</span></span><br><span class="line">        <span class="comment">//将rank低的集合合并到rank高多的集合上</span></span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改的方法只有<code>unionElements</code>方法，合并过程是在rank的基础上进行合并。当<code>rank[pRoot] &lt; rank[qRoot]</code>时，即使parent[pRoot]指向了qRoot,那么本身qRoot的深度就要比pRoot的大，多了这个子树它的深度依然不会改变。同理<code>rank[qRoot] &lt; rank[pRoot]</code>时也一样。只有在两棵树的深度一样时，它们两个指向任意一个都可以，最后让树高度+1即可。</p>
<h1 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h1><p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/13.png"></p>
<p>如上图，这三种树结构所表达的并查集的含义相同，但是它们的效率是不同的。在之前的union方法中，不断的让根节点指向另一个树的根节点，会导致让树的高度越来越高。路径压缩则可以让一棵比较高的树压缩为一棵比较矮的树。只要能让树的高度降低，那么对并查集的性能都会有所提升。</p>
<p>路径压缩发生在find操作中。</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/14.png"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>在查找4的根节点时，只关心4的根节点是多少，而不去考虑中间的父节点是谁，所以4在向上遍历的时候，同时执行<code>parent[p] = parent[parent[p]]</code></p>
<p>从4向上遍历，执行一次操作后,将4的parent指向3的parent2:</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/15.png" alt="执行一次操作后"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center"><font color='red'>2</font></td>
</tr>
</tbody></table>
<p>接着向上遍历,将2的parent指向1的parent0:</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/16.png" alt="执行两次操作后"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>这时，由深度为5降低为深度为3.</p>
<p>实现代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UnionFind5</span></span><br><span class="line"><span class="comment">对UnionFind4的find进行优化,路径压缩</span></span><br><span class="line"><span class="comment">QuickUnion方法</span></span><br><span class="line"><span class="comment">parent数组表示当前元素指向的父元素是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind5</span> <span class="keyword">implements</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//其他代码相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&lt; <span class="number">0</span> || p &gt;= parent.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != parent[p])&#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//..其他代码相同</span></span><br></pre></td></tr></table></figure>

<p>在这个过程中没有去管理rank的值，之所以取名为rank而不是h(树的高度)或者其他,是因为rank实际上表示的是一个排名或者序,在进行完路径压缩后,排名和序并没有变化，依然是rank值比较低的节点在下面，rank值比较高的值在上面，只是有可能出现同一层的元素它们的rank值不同，但这并没有什么影响。只是它不再反应节点所代表的高度值。不做rank的维护，既没有必要也会浪费性能。</p>
<h1 id="压缩为高度为2的树"><a href="#压缩为高度为2的树" class="headerlink" title="压缩为高度为2的树"></a>压缩为高度为2的树</h1><p>最理想化的路径压缩是将每个集合压缩为高度为2的树.</p>
<p><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86/17.png" alt="压缩为高度为2的树"></p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>实现这种压缩需要使用递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他部分代码同上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt; <span class="number">0</span> || p &gt;= parent.length)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前节点不是根节点，则find它的父亲节点所对应的根节点，其实也就是p节点的根节点，然后返回parent[p],也就是整棵树的根节点</span></span><br><span class="line">    <span class="comment">//这是从宏观语义角度进行分析</span></span><br><span class="line">    <span class="keyword">if</span> (p != parent[p])</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式是在查询一个节点的根节点时，将这个节点和这个节点的父亲节点直接指向根节点。  </p>
<h1 id="并查集的时间复杂度"><a href="#并查集的时间复杂度" class="headerlink" title="并查集的时间复杂度"></a>并查集的时间复杂度</h1><p>非严格意义上:o(h)</p>
<p>严格意义上: o(log*n)  (iterated logarithm)</p>
<blockquote>
<p>log*n = 0 (n&lt;=1)<br>log*n = 1 + log*(logn) (n&gt;1)</p>
</blockquote>
<p>o(log*n)的时间复杂度比log(n)还要快，近乎于o(1)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>对[锁]的相关名词解释</title>
    <url>/2019/06/17/%E5%AF%B9%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h1><p><strong>基本概念</strong>：<br><code>公平锁(Fair)</code>：是指按照线程申请的顺序获取锁。加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。<br><code>非公平锁(Nonfair)</code>:是指不是按照线程申请的顺序获取锁，有可能后申请的线程反而先获取到锁，假如先来的线程一直获取不到锁，会造成锁饥饿现象。即加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。</p>
<p>非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列。</p>
<p>在Java的ReentrantLock中可以通过构造方法指定是否为公平锁，默认的lock()方法为非公平锁，非公平锁的优点在于吞吐量大。</p>
<p>synchronized关键字无法指定为公平锁，一直都是非公平锁。</p>
<p>看公平锁和非公平锁的实例:</p>
<p>公平锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairOrNonfair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FairOrNonfair</span><span class="params">(<span class="keyword">boolean</span> isFair)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(isFair);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadName=&quot;</span></span><br><span class="line">                    +Thread.currentThread().getName() + <span class="string">&quot;获得锁定&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> FairOrNonfair fairOrNonfair = <span class="keyword">new</span> FairOrNonfair(<span class="keyword">true</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我进来了&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                fairOrNonfair.serviceMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">            exec.execute(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我进来了pool-1-thread-2</span><br><span class="line">我进来了pool-1-thread-5</span><br><span class="line">我进来了pool-1-thread-4</span><br><span class="line">我进来了pool-1-thread-3</span><br><span class="line">我进来了pool-1-thread-1</span><br><span class="line">ThreadName=pool-1-thread-2获得锁定</span><br><span class="line">ThreadName=pool-1-thread-5获得锁定</span><br><span class="line">ThreadName=pool-1-thread-4获得锁定</span><br><span class="line">ThreadName=pool-1-thread-3获得锁定</span><br><span class="line">ThreadName=pool-1-thread-1获得锁定</span><br></pre></td></tr></table></figure>
<p>非公平锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairOrNonfair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FairOrNonfair</span><span class="params">(<span class="keyword">boolean</span> isFair)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(isFair);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadName=&quot;</span></span><br><span class="line">                    +Thread.currentThread().getName() + <span class="string">&quot;获得锁定&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> FairOrNonfair fairOrNonfair = <span class="keyword">new</span> FairOrNonfair(<span class="keyword">false</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我进来了&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                fairOrNonfair.serviceMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">            exec.execute(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我进来了pool-1-thread-2</span><br><span class="line">我进来了pool-1-thread-5</span><br><span class="line">我进来了pool-1-thread-4</span><br><span class="line">我进来了pool-1-thread-3</span><br><span class="line">我进来了pool-1-thread-1</span><br><span class="line">ThreadName=pool-1-thread-2获得锁定</span><br><span class="line">ThreadName=pool-1-thread-4获得锁定</span><br><span class="line">ThreadName=pool-1-thread-5获得锁定</span><br><span class="line">ThreadName=pool-1-thread-3获得锁定</span><br><span class="line">ThreadName=pool-1-thread-1获得锁定</span><br></pre></td></tr></table></figure>

<p>从结果可以看出 打印是有序的，排队在前面的线程直接获取锁。这就是公平锁。</p>
<p>而将非公平锁的结果也很显而易见，线程5先进来，但是线程4却先得到了锁。</p>
<p>看一下部分源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义成final型的成员变量，在构造方法中进行初始化 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="comment">//无参数默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据参数初始化为公平锁或者非公平锁 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程在非公平锁模式下的吞吐量比公平锁模式下高，原因如下：<br>非公平锁模式下，当线程释放锁之后，快速的通过Fast通道再次获取锁，就算当前sync队列中有排队等待的线程也会被忽略。这种模式，可以保证进入和退出锁的吞吐量，但是sync队列中过早排队的线程会一直处于阻塞状态，造成“饥饿”场景。而公平性锁，就是在调用中顾及当前sync队列中的等待节点（废弃了Fast通道），也就是任意请求都需要按照sync队列中既有的顺序进行，先到先得。这样很好的确保了公平性，吞吐量就没有非公平的锁高了。</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。也就是说可重入锁指的是在一个线程中可以多次获取同一把锁。比如一个线程在执行一个带锁的方法，但是在该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁。</p>
<p>另一个释义：广义上的可重入锁指的是可重复可递归调用的锁(因此也叫递归锁)，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。——<a href="https://blog.csdn.net/rickiyeat/article/details/78314451">来源</a></p>
<p>ReentrantLock和sychronized都是可重入锁。</p>
<p>下面看两个例子：<br>例1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReentrantLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        set();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyReentrantLock myLock = <span class="keyword">new</span> MyReentrantLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(myLock).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myLock).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myLock).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">12</span><br><span class="line">14</span><br><span class="line">14</span><br><span class="line">13</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<p>例2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.windows.ThemeReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReentrantLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        set();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyReentrantLock2 mrl2 = <span class="keyword">new</span> MyReentrantLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(mrl2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mrl2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mrl2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">14</span><br></pre></td></tr></table></figure>

<p>从其打印结果可见，结果都是正确的，即同一个线程id被连续输出了两次。</p>
<h1 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h1><p>独享锁，是指锁一次只能被一个线程持有。</p>
<p>共享锁，是指锁一次可以被多个线程持有。从字面来看也即是允许多个线程共同访问资源。</p>
<p>ReentrantLock和synchronized都是独享锁，ReadWriteLock的读锁是共享锁，写锁是独享锁。</p>
<p>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>抽象队列同步器(AbstractQueuedSynchronizer，简称AQS)是用来构建锁或者其他同步组件的基础框架，它使用一个整型的volatile变量(命名为state)来维护同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile modified=\&quot;2019-06-24T13:47:23.490Z\&quot; host=\&quot;www.draw.io\&quot; agent=\&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36\&quot; etag=\&quot;fjj5M5kb-boEBnH1tqUW\&quot; version=\&quot;10.8.0\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;gehmCrj4xDMhfWEZgMNG\&quot; name=\&quot;第 1 页\&quot;&gt;tVbbjpswEP0aP0YCkhD7ERLSSm2lVlHV7iMBB1AcnBrn1q/vDDYQFiJltd2XZHzm4pkzIw9kujxcP6n4mH+TKRfEc9Irma6I59GZA78I3Aww8z0DZKpIDeR2wKb4yy1o/bJTkfKqZ6ilFLo49sFEliVPdA+LlZKXvtlOiv6txzjjA2CTxGKI/ipSnduyvEWHf+ZFljc3uz4zmkPcGNtKqjxO5eUOmkZkulRSaiMdrksukLuGF+O3fqBtE1O81M84qI142X/5uTt9z8vf6eTlVrnziT8zYc6xONmKiecLCBjqeAskeM5WqpSrWuf/OWG2oduJYHBpeWn1DqQy7xlV+mYpbUDrFoCysXeMbW4JHVGZZCaJFCI+VtzYtKe7C/3M/ptathIG8DWoBkiKUyOKrOxlmgDDXI1EjxgJQsIoieYESKEeiRYohG1EaAcGfdc1X2WyBzk+HOFQbqujoWIAQRLMIXRJIp8EKxLMawRSpE95MywkrMMELmGRRdgaEQrC4okw0ZUnJy3Vk/mGjIR+HX9NmFtfHSF4l/hjGhEctvD9TZ1jzWGAvQQiqPMhTQ1+bMY4Qs5XHfm9dviEAWMOCnSFRGFeMH7TWhUROhuNCORGtoswFcxp6KZ4B12g/FSBH0S3ddsOAv0Pls9SxLqAh2e0ZhYgZxElwbou3ky6j6P3xPh6zjIY6eHg/EZGERx7rRA3L3KDe71n1dP8iniuDwIAF8RKK7nnSykkPt+lLMEy3BVCvILkmaudqHcTatvgAEPQh+vGbZcYLH8uD1wryNqxDsyuPbv3XWrP3bbwZguL5fcbtAFju7mzNnS33ECw+605dnu01t19jEyjfw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>

<p>concurrent包的实现结构如上图所示，AQS、非阻塞数据结构和原子变量类等基础类都是基于volatile变量的读/写和CAS实现，而像Lock、同步器、阻塞队列、Executor和并发容器等高层类又是基于基础类实现</p>
<h1 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h1><p>与独享锁/共享锁的概念差不多，是独享锁/共享锁的具体实现。</p>
<p>互斥锁：在访问共享资源之前对其进行加锁操作，在访问完成之后进行解锁操作。加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。<br>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被变成就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源。</p>
<p>读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。</p>
<p>ReentrantLock和synchronized都是互斥锁</p>
<p>ReadWriteLock是读写锁</p>
<p>读写锁特点：<br>1）多个读者可以同时进行读。<br>2）写者必须互斥（只允许一个写者写，也不能读者写者同时进行）<br>3）写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</p>
<p>同时读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态。</p>
<p>互斥锁特点：<br>一次只能一个线程拥有互斥锁，其他线程只有等待。即某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<p>显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！</p>
<h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h1><p>悲观锁，是指认为对于同一个数据的并发操作必然会发生修改，即使不会发生修改也这么认为，所以一定要加锁。<br>乐观锁，是指认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试。<br>悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景。</p>
<p>详见 <a href="https://homxuwang.github.io/2019/06/11/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/">https://homxuwang.github.io/2019/06/11/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/</a></p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁，是指尝试获取锁的线程不会阻塞，而是循环的方式不断尝试，这样的好处是减少线程的上下文切换带来的开锁，提高性能，缺点是循环会消耗CPU，也有可能导致死锁。</p>
<p>基本作用是用于线程（进程）之间的同步。与普通锁不同的是，一个线程A在获得普通锁后，如果再有线程B试图获取锁，那么这个线程B将会挂起（阻塞）；试想下，如果两个线程资源竞争不是特别激烈，而处理器阻塞一个线程引起的线程上下文的切换的代价高于等待资源的代价的时候（锁的已保持者保持锁时间比较短），那么线程B可以不放弃CPU时间片，而是在“原地”忙等，直到锁的持有者释放了该锁，这就是自旋锁的原理，可见自旋锁是一种非阻塞锁。</p>
<p>关于两个缺点：</p>
<ul>
<li>过多消耗CPU：如果锁的当前持有长时间不释放该锁，那么等待着将长时间占据cpu时间片，导致CPU资源浪费，因此可以设置一定的时间，当锁持有者超过这个时间不释放锁时，等待者会放弃CPU时间片段阻塞。</li>
<li>死锁问题：如果有一个线程连续两次试图获得自旋锁(比如在递归程序中)，第一次这个线程获得了该锁，当第二次试图加锁时，检测到锁已被占用(即被自己占用了)，那么这时候线程会等待自己释放该锁，而不能继续执行，这样就发生了死锁问题。所以在递归程序中使用自旋锁应该遵循以下原则：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。</li>
</ul>
<p>实现原理：如果自旋锁被另外一个线程对象持有，那么当前获取锁的线程将陷入while循环等待，直到那个持有自旋锁的线程对象释放它所持有的自旋锁，那么那些想要获取该自旋锁的线程对象 将会有一个获得该自旋锁。等待的时候，并不释放cpu时间片，相比synchronized  wait()操作，减小了释放，重新获取的消耗。 该自旋锁适用于，当前线程竞争不强烈的时候使用。</p>
<h1 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h1><p>分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。</p>
<p>说的简单一点就是：容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>比如：在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设使用合理的散列算法使关键字能够均匀的分部，那么这大约能使对锁的请求减少到越来的1/16。也正是这项技术使得ConcurrentHashMap支持多达16个并发的写入线程。</p>
<p>当然，任何技术必有其劣势，与独占锁相比，维护多个锁来实现独占访问将更加困难而且开销更加大。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/5cdac52ce51d456e55623bfc">https://juejin.im/post/5cdac52ce51d456e55623bfc</a></p>
<p><a href="https://blog.csdn.net/IsResultXaL/article/details/53334750">https://blog.csdn.net/IsResultXaL/article/details/53334750</a></p>
<p><a href="https://blog.csdn.net/jiang13479/article/details/80679794">https://blog.csdn.net/jiang13479/article/details/80679794</a></p>
<p><a href="http://ifeve.com/java_lock_see4/">http://ifeve.com/java_lock_see4/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/54551800">https://zhuanlan.zhihu.com/p/54551800</a></p>
<p><a href="https://blog.csdn.net/tanga842428/article/details/52765037">https://blog.csdn.net/tanga842428/article/details/52765037</a></p>
<p><a href="https://www.jianshu.com/p/87ac733fda80">https://www.jianshu.com/p/87ac733fda80</a></p>
<p><a href="https://blog.csdn.net/sunp823/article/details/49886051">https://blog.csdn.net/sunp823/article/details/49886051</a></p>
<p><a href="https://blog.csdn.net/liushengbaoblog/article/details/39227863">https://blog.csdn.net/liushengbaoblog/article/details/39227863</a></p>
<p><a href="https://blog.csdn.net/u010853261/article/details/54314486">https://blog.csdn.net/u010853261/article/details/54314486</a></p>
<script type="text/javascript" src="https://www.draw.io/js/viewer.min.js"></script>]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2018/06/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最近在学习数据结构和算法，这里总结一下学习的排序算法。</p>
<h1 id="选择排序-SelectionSort"><a href="#选择排序-SelectionSort" class="headerlink" title="选择排序 - SelectionSort"></a>选择排序 - SelectionSort</h1><p><strong>基本思路</strong>:<br>假设有一个数组（如图所示），进行从小到大的排序。首先在整个数组范围里，找出要放在第一个位置的数，也就是最小的数：1，然后将1和现在的第一名的位置8进行换位，经过交换以后，1所处的位置就是最终排序所在的位置，这样就继续在剩下的部分找此时最小的数，也就是2，然后把2和相应的第二个位置所在的元素进行交换，此时1和2两个元素也已经是最终排好序的结果。整个过程以此类推，继续在剩下的部分中找此时最小的元素，然后进行交换位置。。。。。</p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/SelectionSort.jpg" alt="选择排序"></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法类不允许产生任何实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SelectionSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">            <span class="comment">// 寻找[i, n)区间里的最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">                <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">                    minIndex = j;</span><br><span class="line"></span><br><span class="line">            swap( arr , i , minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        SelectionSort.sort(arr);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i ++ )&#123;</span><br><span class="line">            System.out.print(arr[i]);</span><br><span class="line">            System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法类不允许产生任何实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SelectionSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">            <span class="comment">// 寻找[i, n)区间里的最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">                <span class="comment">// 使用compareTo方法比较两个Comparable对象的大小</span></span><br><span class="line">                <span class="keyword">if</span>( arr[j].compareTo( arr[minIndex] ) &lt; <span class="number">0</span> )</span><br><span class="line">                    minIndex = j;</span><br><span class="line"></span><br><span class="line">            swap( arr , i , minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序-InsertionSort"><a href="#插入排序-InsertionSort" class="headerlink" title="插入排序 - InsertionSort"></a>插入排序 - InsertionSort</h1><p><strong>基本思路</strong>：<br>开始只考虑8这个元素的时候，它就已经排好序了。<br>接着看6这个元素,接下来的步骤是把6与它前面的数组进行比较，放在合适的位置，当6与8比较时，6&lt;8，所以6在8前面位置。<br>接着看2这个元素，2与它前面的数组进行比较，2&lt;8，所以2和8交换一次位置，2继续和6比较，2&lt;6，所以2和6交换位置，此时2在最前面的位置。<br>接着看3这个元素，3比8小，所以交换一次位置，3又比6小，所以交换一次位置，3比2大所以不进行交换操作，3插入在2和6中间，这时前面的4个元素排序完成。<br>以此类推。</p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/InsertionSort_.png" alt="插入排序"></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InsertionSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写法1</span></span><br><span class="line"><span class="comment">//            for( int j = i ; j &gt; 0 ; j -- )</span></span><br><span class="line"><span class="comment">//                if( arr[j].compareTo( arr[j-1] ) &lt; 0 )</span></span><br><span class="line"><span class="comment">//                    swap( arr, j , j-1 );</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    break;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写法2</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j].compareTo(arr[j-<span class="number">1</span>]) &lt; <span class="number">0</span> ; j--)</span><br><span class="line">                swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序和选择排序相比，如果满足了条件就有机会提前结束，所以它的排序效率理论上要比选择排序高<br>但是实际上它的运行时间比选择排序要慢，这是因为其swap操作较多，浪费了时间，所以针对这个地方进行改进</p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/InsertionSort-2_.png" alt="插入排序"></p>
<p><strong>改进代码思路</strong>:<br>首先,对位置0处的元素不作处理。</p>
<p>接着，看<code>位置1</code>处的<code>元素6</code>，首先对<code>元素6</code>做一个副本保存起来，然后看<code>元素6</code>是否应该在当前位置，即让他与前面的元素进行对比，如果小于前面的元素，则当前元素位置的值赋值为前一个元素的值，前一个元素位置的值赋值为刚才保存起来的副本（即当前元素的值）。（其实这也是相当于一个交换操作，在满足前一个元素大于当前元素值的情况下，进行交换值操作）</p>
<p>接着，看<code>位置2</code>处的<code>元素2</code>，首先对<code>元素2</code>做一个副本保存起来，然后<code>元素2</code>与前一个<code>元素8</code>比较，2&lt;8，则将<code>元素2</code>处的值赋值为8；接着再比较<code>位置1</code>处的<code>元素8</code>与<code>位置1</code>处的<code>元素6</code>的大小，将<code>位置1</code>处的值赋值为<code>元素6</code>，接着将<code>元素2</code>放在第一个位置。这样就少进行了交换的操作。</p>
<p>接着，看<code>元素3</code>，首先对<code>元素3</code>做一个副本保存起来，然后看<code>元素3</code>该不该放在当前位置，发现3&lt;8，所以这个位置赋值为8；然后看3是不是该放在刚才<code>元素8</code>的位置，发现<code>元素3</code>比<code>元素6</code>小，所以<code>元素6</code>放在刚才<code>元素8</code>的位置；然后看<code>元素3</code>是不是该放在刚才<code>元素6</code>的位置，发现<code>元素3</code>比<code>元素2</code>大，所以<code>元素3</code>应该放在这个位置。</p>
<p>这样很多交换操作就通过赋值进行取代了，所以性能更好。</p>
<p><strong>改进代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的算法类不允许产生任何实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InsertionSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写法1</span></span><br><span class="line"><span class="comment">//            for( int j = i ; j &gt; 0 ; j -- )</span></span><br><span class="line"><span class="comment">//                if( arr[j].compareTo( arr[j-1] ) &lt; 0 )</span></span><br><span class="line"><span class="comment">//                    swap( arr, j , j-1 );</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    break;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写法2</span></span><br><span class="line"><span class="comment">//            for( int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j-1]) &lt; 0 ; j--)</span></span><br><span class="line"><span class="comment">//                swap(arr, j, j-1);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写法3</span></span><br><span class="line">            Comparable e = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">for</span>( ; j &gt; <span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>].compareTo(e) &gt; <span class="number">0</span> ; j--)</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j] = e;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序-MergeSort"><a href="#归并排序-MergeSort" class="headerlink" title="归并排序 - MergeSort"></a>归并排序 - MergeSort</h1><h2 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h2><p><strong>基本思路</strong>：<br>所谓归并排序，有两大步，一步是<code>归</code>，一步是<code>并</code>。</p>
<p>当对一个数组进行排序的时候,先把这个数组分成一半，然后分别把左边的数组和右边的数组排序,之后再归并起来。在对左边数组和右边的数组进行排序的时候，再次分别把左边的数组和右边的数组分成一半，然后对每一个部分进行排序。一样的，对这每一个部分进行排序的时候，再次把他们分成一半，直到它们只含有一个元素的时候，已经是有序了。（蓝色部分）</p>
<p>这时候就对上面最终分割完成的各个部分进行归并。在归并到上一个层级之后，继续进行归并,逐层上升，进行归并，直到归并到最后一层的时候，整个数组就有序了。（红色部分）</p>
<p>可以看到，对图中的8各元素进行归并的时候，分成3级，第三级就可以把数组分成单个元素了，这样每次二分，就是<code>log2 8 = 3</code>，如果是N个元素，则有<code>log2 N</code>的层级。每一层要处理的元素个数是一样的，则整个归并过程是<code>N*log(N)</code>的时间复杂度。</p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/MergeSort_.png" alt="归并排序"></p>
<p>那么问题是假设左半部分和右半部分已经排好了序，怎么把他们合并成一个有序的数组。<br>这个过程需要为数组开辟一个相同大小的临时空间进行辅助,如下图。<br>在合并成一个数组的过程中，需要3个索引：k是最终在归并过程中要跟踪的位置，i和j分别表示两个排好序的数组，当前要考虑的元素项。<br>首先看1和2两个元素，谁应该放在k位置，进行对比后，较小的元素1放在k位置。这时候k++，j++。<br>紧接着，元素2和元素4进行对比，较小的元素2放在当前的k位置，这时候k++,i++。<br>继续元素3和元素4进行对比，较小的元素3放在当前的k位置，这时候k++,i++。<br>继续元素6和元素4进行对比，较小的元素4放在当前的k位置，这时候k++,j++。<br>。。。。<br>算法过程中，需要维护k,i,j满足算法的定义。并且需要跟踪i,j的越界情况。<br>这里定义l(left),r(right),和m(middle)分别为整个数组的最左边的元素，数组最右边的元素和中间位置的元素(这里指定为第一个数组的最后一个元素)。这里再做一个说明，这里的定义整个算法的数组是前闭后闭的数组。 </p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B_.png" alt="归并排序"></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的算法类不允许产生任何实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MergeSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparable[] aux = Arrays.copyOfRange(arr, l, r+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> k = l ; k &lt;= r; k ++ )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( i &gt; mid )&#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[j-l]; j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( j &gt; r )&#123;   <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[i-l]; i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( aux[i-l].compareTo(aux[j-l]) &lt; <span class="number">0</span> )&#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[i-l]; i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[j-l]; j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用归并排序,对arr[l...r]的范围进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        sort(arr, l, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        sort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h2><p><strong>基本思路</strong>：<br>自底向上的归并排序的基本原理是，给定一个数组，从左向右将数组依次划分为小段，如两个元素一个小段，然后进行归并排序。当这一轮归并排序完成之后，再四个元素一个小段进行归并排序，最后八个元素一个小段进行归并排序。以上面的数组为例，这时候就排序完成了。<br>这种方法并不需要递归，只需要迭代就可以完成排序操作。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortBU</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的算法类不允许产生任何实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MergeSortBU</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparable[] aux = Arrays.copyOfRange(arr, l, r+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> k = l ; k &lt;= r; k ++ )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( i &gt; mid )&#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[j-l]; j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( j &gt; r )&#123;   <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[i-l]; i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( aux[i-l].compareTo(aux[j-l]) &lt; <span class="number">0</span> )&#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[i-l]; i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[j-l]; j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge Sort Bottom Up 无优化版本</span></span><br><span class="line"><span class="comment">//        for (int sz = 1; sz &lt; n; sz *= 2)</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; n - sz; i += sz+sz)</span></span><br><span class="line"><span class="comment">//                // 对 arr[i...i+sz-1] 和 arr[i+sz...i+2*sz-1] 进行归并</span></span><br><span class="line"><span class="comment">//                merge(arr, i, i+sz-1, Math.min(i+sz+sz-1,n-1));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge Sort Bottom Up 优化</span></span><br><span class="line">        <span class="comment">// 对于小数组, 使用插入排序优化</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i += <span class="number">16</span> )</span><br><span class="line">            InsertionSort.sort(arr, i, Math.min(i+<span class="number">15</span>, n-<span class="number">1</span>) );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> sz = <span class="number">16</span>; sz &lt; n ; sz += sz )</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - sz ; i += sz+sz )</span><br><span class="line">                <span class="comment">// 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">                <span class="keyword">if</span>( arr[i+sz-<span class="number">1</span>].compareTo(arr[i+sz]) &gt; <span class="number">0</span> )</span><br><span class="line">                    merge(arr, i, i+sz-<span class="number">1</span>, Math.min(i+sz+sz-<span class="number">1</span>,n-<span class="number">1</span>) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 MergeSort BU</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">        Integer[] arr = SortTestHelper.generateRandomArray(N, <span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">        SortTestHelper.testSort(<span class="string">&quot;bobo.algo.MergeSortBU&quot;</span>, arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自底向上的归并排序方法没有用到数组的索引，所以可以很好的对链表结构进行排序</p>
<p>Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环，所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据<br> 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例</p>
<h1 id="快速排序-QuickSort"><a href="#快速排序-QuickSort" class="headerlink" title="快速排序 - QuickSort"></a>快速排序 - QuickSort</h1><p><strong>基本思路</strong>：<br>以下图的数组为例，首先选定一个元素4，把它挪到当它在排好序的时候，应该处的位置，当它处在这个位置之后，使得这个数组有了一个性质：在4之前的数都小于4，在4之后的数都大于4。接下来，对小于4的子数组和大于4的子数组分别继续进行快速排序。这样逐渐递归，完成整个排序过程。</p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/QuickSort_.png" alt="快速排序"></p>
<p>那么关键问题是怎么把4这个元素放在正确的改放的位置，这个过程称为Partition。<br>通常使用数组的第一个元素作为分界的标志点，第一个位置记作l，然后逐渐遍历右边没有被访问的元素，在遍历的过程中，逐步整理让元素一部分是<code>&gt;v</code>一部分是<code>&lt;v</code>的,将大于v和小于v的分界点的索引记为j，当前访问的元素e的索引记作i。<br>下面讨论i位置的e该如何处理，如图。如果<code>e&gt;v</code>则将它放在这个位置不变，i++继续讨论下一个元素。否则如果<code>e&lt;v</code>则将i位置的e与j+1位置的元素交换，j++,i++，继续考察下一个元素。<br>依次继续进行操作，直至遍历完数组的所有元素。<br>这时候要将v放在数组中合适的位置，即将索引l位置的v与索引j位置的元素进行交换。<br>最终完成此次操作。</p>
<p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Partition_.png" alt="Partition"><br><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的算法类不允许产生任何实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">QuickSort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line">    <span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparable v = arr[l];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = l; <span class="comment">// arr[l+1...j] &lt; v ; arr[j+1...i) &gt; v</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = l + <span class="number">1</span> ; i &lt;= r ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[i].compareTo(v) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                j ++;</span><br><span class="line">                swap(arr, j, i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">        sort(arr, l, p-<span class="number">1</span> );</span><br><span class="line">        sort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        sort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Quick Sort也是一个O(nlogn)复杂度的算法<br>可以在1秒之内轻松处理100万数量级的数据</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>见<a href="https://homxuwang.github.io/2019/04/07/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"><strong>堆和堆排序</strong></a></p>
<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><table>
<thead>
<tr>
<th></th>
<th>平均时间复杂度</th>
<th>原地排序</th>
<th>额外空间</th>
<th>稳定排序</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序<br>Selection Sort</td>
<td>O(n^2)</td>
<td>√</td>
<td>O(1)</td>
<td>×</td>
</tr>
<tr>
<td>插入排序<br>Insertion Sort</td>
<td>O(n^2)</td>
<td>√</td>
<td>O(1)</td>
<td>√</td>
</tr>
<tr>
<td>归并排序<br>Merge Sort</td>
<td>O(nlogn)</td>
<td>×</td>
<td>O(n)</td>
<td>√</td>
</tr>
<tr>
<td>快速排序<br>Quick Sort</td>
<td>O(nlogn)</td>
<td>√</td>
<td>O(logn)</td>
<td>×</td>
</tr>
<tr>
<td>堆排序<br>Heap Sort</td>
<td>O(nlogn)</td>
<td>√</td>
<td>O(1)</td>
<td>×</td>
</tr>
</tbody></table>
<p>排序算法的稳定性:稳定排序是指对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生改变。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>整合Struts2+Spring+Hibernate</title>
    <url>/2018/11/16/%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/</url>
    <content><![CDATA[<p>项目所需依赖包：<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/1.png" alt="依赖包"><br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/2.png" alt="依赖包"></p>
<h1 id="单独配置Spring"><a href="#单独配置Spring" class="headerlink" title="单独配置Spring"></a>单独配置Spring</h1><h2 id="创建配置文件-导入xml约束"><a href="#创建配置文件-导入xml约束" class="headerlink" title="创建配置文件 导入xml约束"></a>创建配置文件 导入xml约束</h2><p>约束包括<code>beans</code>|<code>context</code>|<code>aop</code>|<code>tx</code><br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/3.png" alt="命名空间"><br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/4.png" alt="命名空间"></p>
<p>创建<code>UserAction</code>,并在Spring配置文件中配置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.action.UserAction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置tomcat的web-xml"><a href="#配置tomcat的web-xml" class="headerlink" title="配置tomcat的web.xml"></a>配置tomcat的web.xml</h2><p>在<code>web.xml</code>中配置让spring随web启动而创建的监听器,并配置spring配置文件配置参数:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 让spring随web启动而创建的监听器 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置spring配置文件参数 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时可以启动服务看看有没有报错，如果没有报错，这一步就配置成功了。</p>
<h1 id="单独配置Struts2"><a href="#单独配置Struts2" class="headerlink" title="单独配置Struts2"></a>单独配置Struts2</h1><h2 id="配置struts2主配置文件"><a href="#配置struts2主配置文件" class="headerlink" title="配置struts2主配置文件"></a>配置struts2主配置文件</h2><p>首先创建<code>struts.xml</code>，添加约束,并配置<code>UserAction</code>(约束可以在struts2-core-2.3.35.jar包下的struts-2.3.dtd中查找到)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">struts</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;ssh&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;UserAction_*&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.action.UserAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&#123;1&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jsp文件自己定义一个放在<code>WebContent</code>目录下即可.</p>
<h2 id="配置struts2核心过滤器到web-xml"><a href="#配置struts2核心过滤器到web-xml" class="headerlink" title="配置struts2核心过滤器到web.xml"></a>配置struts2核心过滤器到web.xml</h2><p>在<code>web.xml</code>中配置struts2核心过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- struts2核心过滤器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>url-pattern</code>为<code>/*</code>表示所有路径都要经过核心过滤器<br>如果启动服务器没有错误就说明配置成功</p>
<h1 id="Spring和Struts2整合"><a href="#Spring和Struts2整合" class="headerlink" title="Spring和Struts2整合"></a>Spring和Struts2整合</h1><p>整合的目的是让struts的Action不再自己创建，而是由spring创建(依赖包是struts2-spring-plugin-2.3.35.jar)。</p>
<h2 id="配置常量"><a href="#配置常量" class="headerlink" title="配置常量"></a>配置常量</h2><p>在<code>struts2-core-2.3.35.jar</code>-&gt;<code>org.apache.struts2</code>-&gt;<code>default.properties</code>中查找常量。</p>
<p><code>struts.objectFactory = spring</code>是将action的创建交给spring容器<br><code>struts.objectFactory.spring.autoWire = name</code>spring负责装配Action<br>一般只需配置<code>struts.objectFactory</code>第二个自动开启</p>
<p>在<code>&lt;struts&gt;&lt;/struts&gt;</code>标签中配置<code>&lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot;&gt;</code></p>
<h2 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h2><p>创建各个类进行测试：<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/6.png" alt="测试类部分"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userService = userService;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.println(userService);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Long user_id;</span><br><span class="line">	<span class="keyword">private</span> String user_code;</span><br><span class="line">	<span class="keyword">private</span> String user_name;</span><br><span class="line">	<span class="keyword">private</span> String user_password;</span><br><span class="line">	<span class="keyword">private</span> Character user_state;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">getUser_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> user_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser_id</span><span class="params">(Long user_id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.user_id = user_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUser_code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> user_code;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser_code</span><span class="params">(String user_code)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.user_code = user_code;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUser_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> user_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser_name</span><span class="params">(String user_name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.user_name = user_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUser_password</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> user_password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser_password</span><span class="params">(String user_password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.user_password = user_password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Character <span class="title">getUser_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> user_state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser_state</span><span class="params">(Character user_state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.user_state = user_state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;User [user_id=&quot;</span> + user_id + <span class="string">&quot;, user_code=&quot;</span> + user_code + <span class="string">&quot;, user_name=&quot;</span> + user_name + <span class="string">&quot;, user_password=&quot;</span></span><br><span class="line">				+ user_password + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"><span class="keyword">import</span> my.study.web.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUserByCodePassword</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;getUserByCodePassword&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="function">User <span class="title">getUserByCodePassword</span><span class="params">(User u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在spring配置文件中配置service:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- action配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.action.UserAction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servie配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>整合方案1:class属性上仍然配置action的完整类名，这样struts2仍然创建action,由spring负责组装Action中的依赖属性<br><code>UserAction</code>中的<code>login()</code>方法就是为了检测是否是由spring装配属性。<br>访问<code>http://localhost:8080/SSH/UserAction_login</code>看到打印结果:<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/7.png" alt="测试结果"><br>当然这种方法并不推荐，最好由spring完整管理action的生命周期。spring中功能才应用到Action上.</p>
</li>
<li><p>整合方案2:spring负责创建action以及组装.首先配置<code>applicationContext.xml</code>中的<code>action</code>，然后配置<code>struts.xml</code><br>这种方式下在<code>class</code>属性处填写spring中action对象的<code>BeanName</code>.完全由spring管理action生命周期，这样spring需要手动组装依赖属性。即需要在<code>applicationContext.xml</code>中action的<code>&lt;bean&gt;&lt;/bean&gt;</code>中使用<code>&lt;property&gt;&lt;/property&gt;</code>进行手动注入：<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/8.png" alt="手动注入"><br>同时，要注意，Action对象作用范围一定是多例的，这样才符合Struts2的架构。所以将<code>scope</code>属性配置为<code>prototype</code></p>
</li>
</ul>
<p>访问<code>http://localhost:8080/SSH/UserAction_login</code>依然可以打印出<code>my.study.web.impl.UserServiceImpl</code><br>至此，struts与spring就整合结束了。</p>
<h1 id="单独配置Hibernate"><a href="#单独配置Hibernate" class="headerlink" title="单独配置Hibernate"></a>单独配置Hibernate</h1><h2 id="导入实体类和orm元数据"><a href="#导入实体类和orm元数据" class="headerlink" title="导入实体类和orm元数据"></a>导入实体类和orm元数据</h2><p><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/9.png" alt="手动注入"><br><code>User.hbm.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> </span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;my.study.web.domain&quot;</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;sys_user&quot;</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;user_id&quot;</span>  &gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user_code&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user_name&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user_password&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user_state&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Customer.hbm.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> </span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;my.study.web.domain&quot;</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;LinkMan&quot;</span> <span class="attr">table</span>=<span class="string">&quot;cst_linkman&quot;</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;lkm_id&quot;</span>  &gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_gender&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_name&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_phone&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_email&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_qq&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_mobile&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_memo&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lkm_position&quot;</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 多对一 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			name属性:引用属性名</span></span><br><span class="line"><span class="comment">			column属性: 外键列名</span></span><br><span class="line"><span class="comment">			class属性: 与我关联的对象完整类名</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		 	级联操作:	cascade</span></span><br><span class="line"><span class="comment">		 		save-update: 级联保存更新</span></span><br><span class="line"><span class="comment">		 		delete:级联删除</span></span><br><span class="line"><span class="comment">		 		all:save-update+delete</span></span><br><span class="line"><span class="comment">		 	级联操作: 简化操作.目的就是为了少些两行代码.</span></span><br><span class="line"><span class="comment">		  --&gt;</span></span><br><span class="line">		  <span class="comment">&lt;!-- 多的一方: 不能放弃维护关系的.外键字段就在多的一方.  --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">column</span>=<span class="string">&quot;lkm_cust_id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Customer&quot;</span>  &gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Customer.hbm.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> </span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 配置表与实体对象的关系 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;my.study.web.domain&quot;</span> &gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		class元素: 配置实体与表的对应关系的</span></span><br><span class="line"><span class="comment">			name: 完整类名</span></span><br><span class="line"><span class="comment">			table:数据库表名</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Customer&quot;</span> <span class="attr">table</span>=<span class="string">&quot;cst_customer&quot;</span> &gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- id元素:配置主键映射的属性</span></span><br><span class="line"><span class="comment">				name: 填写主键对应属性名</span></span><br><span class="line"><span class="comment">				column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名</span></span><br><span class="line"><span class="comment">				type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">						每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">				not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">				length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;cust_id&quot;</span>  &gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- generator:主键生成策略(明天讲) --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- property元素:除id之外的普通属性映射</span></span><br><span class="line"><span class="comment">				name: 填写属性名</span></span><br><span class="line"><span class="comment">				column(可选): 填写列名</span></span><br><span class="line"><span class="comment">				type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">						每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">				not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">				length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cust_name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cust_name&quot;</span> &gt;</span></span><br><span class="line">			<span class="comment">&lt;!--  &lt;column name=&quot;cust_name&quot; sql-type=&quot;varchar&quot; &gt;&lt;/column&gt; --&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cust_source&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cust_source&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cust_industry&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cust_industry&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cust_level&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cust_level&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cust_linkman&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cust_linkman&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cust_phone&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cust_phone&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cust_mobile&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cust_mobile&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>LinkMan.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Long lkm_id;</span><br><span class="line">	<span class="keyword">private</span> Character lkm_gender;</span><br><span class="line">	<span class="keyword">private</span> String lkm_name;</span><br><span class="line">	<span class="keyword">private</span> String lkm_phone;</span><br><span class="line">	<span class="keyword">private</span> String lkm_email;</span><br><span class="line">	<span class="keyword">private</span> String lkm_qq;</span><br><span class="line">	<span class="keyword">private</span> String lkm_mobile;</span><br><span class="line">	<span class="keyword">private</span> String lkm_memo;</span><br><span class="line">	<span class="keyword">private</span> String lkm_position;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span> Customer customer ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Long cust_id;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">getCust_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_id</span><span class="params">(Long cust_id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_id = cust_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> customer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.customer = customer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">getLkm_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_id</span><span class="params">(Long lkm_id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_id = lkm_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Character <span class="title">getLkm_gender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_gender;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_gender</span><span class="params">(Character lkm_gender)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_gender = lkm_gender;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLkm_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_name</span><span class="params">(String lkm_name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_name = lkm_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLkm_phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_phone;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_phone</span><span class="params">(String lkm_phone)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_phone = lkm_phone;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLkm_email</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_email;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_email</span><span class="params">(String lkm_email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_email = lkm_email;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLkm_qq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_qq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_qq</span><span class="params">(String lkm_qq)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_qq = lkm_qq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLkm_mobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_mobile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_mobile</span><span class="params">(String lkm_mobile)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_mobile = lkm_mobile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLkm_memo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_memo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_memo</span><span class="params">(String lkm_memo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_memo = lkm_memo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLkm_position</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lkm_position;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkm_position</span><span class="params">(String lkm_position)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lkm_position = lkm_position;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Customer.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Long cust_id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String cust_name;</span><br><span class="line">	<span class="keyword">private</span> String cust_source;</span><br><span class="line">	<span class="keyword">private</span> String cust_industry;</span><br><span class="line">	<span class="keyword">private</span> String cust_level;</span><br><span class="line">	<span class="keyword">private</span> String cust_linkman;</span><br><span class="line">	<span class="keyword">private</span> String cust_phone;</span><br><span class="line">	<span class="keyword">private</span> String cust_mobile;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">getCust_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_id</span><span class="params">(Long cust_id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_id = cust_id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCust_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_name</span><span class="params">(String cust_name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_name = cust_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCust_source</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_source;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_source</span><span class="params">(String cust_source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_source = cust_source;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCust_industry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_industry;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_industry</span><span class="params">(String cust_industry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_industry = cust_industry;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCust_level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_level;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_level</span><span class="params">(String cust_level)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_level = cust_level;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCust_linkman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_linkman;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_linkman</span><span class="params">(String cust_linkman)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_linkman = cust_linkman;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCust_phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_phone;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_phone</span><span class="params">(String cust_phone)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_phone = cust_phone;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCust_mobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cust_mobile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_mobile</span><span class="params">(String cust_mobile)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cust_mobile = cust_mobile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Customer [cust_id=&quot;</span> + cust_id + <span class="string">&quot;, cust_name=&quot;</span> + cust_name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在hibernate的配置文件中，不用配置隔离级别，在spring中进行配置。也不需配置session与当前线程绑定的配置，因为spring有管理session的机制。<br><code>hibernate.cfg.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span>jdbc:mysql:///customer1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库方言			</span></span><br><span class="line"><span class="comment">			注意: MYSQL在选择方言时,请选择最短的方言.</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- #hibernate.show_sql true</span></span><br><span class="line"><span class="comment">		#hibernate.format_sql true</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		## auto schema export  自动导出表结构. 自动建表</span></span><br><span class="line"><span class="comment">		#hibernate.hbm2ddl.auto create		自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">		#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">		#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).</span></span><br><span class="line"><span class="comment">		#hibernate.hbm2ddl.auto validate	校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.</span></span><br><span class="line"><span class="comment">		 --&gt;</span>		</span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 引入orm元数据</span></span><br><span class="line"><span class="comment">			路径书写: 填写src下的路径</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;my/study/web/domain/Customer.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;my/study/web/domain/LinkMan.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;my/study/web/domain/User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建类进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">		</span><br><span class="line">		SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line">		</span><br><span class="line">		Session session = sf.openSession();</span><br><span class="line">		</span><br><span class="line">		Transaction tx = session.beginTransaction();</span><br><span class="line">		</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		</span><br><span class="line">		u.setUser_code(<span class="string">&quot;hey&quot;</span>);</span><br><span class="line">		u.setUser_name(<span class="string">&quot;哈喽&quot;</span>);</span><br><span class="line">		u.setUser_password(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		session.save(u);		</span><br><span class="line">		tx.commit();		</span><br><span class="line">		session.close();</span><br><span class="line">		</span><br><span class="line">		sf.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/11.png" alt="测试结果"><br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/10.png" alt="测试结果"></p>
<p>单独配置Hibernate就成功了</p>
<h1 id="hibernate和spring整合"><a href="#hibernate和spring整合" class="headerlink" title="hibernate和spring整合"></a>hibernate和spring整合</h1><p>整合原理：将<code>SessionFactory</code>对象交给spring容器管理</p>
<h2 id="在spring中配置sessionFactory"><a href="#在spring中配置sessionFactory" class="headerlink" title="在spring中配置sessionFactory"></a>在spring中配置sessionFactory</h2><p>也就是要在配置文件中配置sessionFactory,然后<code>sessionFactory</code>加载配置有两种方案:</p>
<ul>
<li>1.仍然使用外部的hibernate.cfg.xml配置信息</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 将sessionFactory配置到spring容器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:hibernate.cfg.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意选择和自己的hibernate版本一样的(我的是hibernate5)</p>
<p>书写代码进行测试，直接使用spring注入的sessionFactory:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Resource(name=&quot;sessionFactory&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> SessionFactory sf;</span><br><span class="line">	</span><br><span class="line">  	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;			</span><br><span class="line">		Session session = sf.openSession();</span><br><span class="line">		</span><br><span class="line">		Transaction tx = session.beginTransaction();</span><br><span class="line">		</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		</span><br><span class="line">		u.setUser_code(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		u.setUser_name(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">		u.setUser_password(<span class="string">&quot;8765&quot;</span>);		</span><br><span class="line">		session.save(u);		</span><br><span class="line">		tx.commit();</span><br><span class="line">		</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 sessionFactory的关闭可以交给spring来管理,所以close()方法可以不用写<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/12.png" alt="测试结果"></p>
<ul>
<li>2.在spring配置中放置hibernate配置信息<br>第二种配置方法就是在spring中配置hibernate配置信息，包括必选配置，可选配置和引入orm元数据。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置hibernate基本信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 必选配置 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span>jdbc:mysql:///customer1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 可选配置 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>				</span><br><span class="line">		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 引入orm元数据，指定orm元数据所在的包路径，spring会读取包中的所有配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappingDirectoryLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:my/study/web/domain&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
将方法1中的配置换成上面的配置，进行测试:<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/13.png" alt="测试结果"><br>这样就完成了spring和hibernate的整合</li>
</ul>
<p>重点总结，整合原理就是将<code>SessionFactory</code>对象交给spring容器管理</p>
<h1 id="spring整合c3p0连接池"><a href="#spring整合c3p0连接池" class="headerlink" title="spring整合c3p0连接池"></a>spring整合c3p0连接池</h1><p>c3p0的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 读取db.properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置c3p0连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;JdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.JdbcUrl&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DriverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.DriverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.User&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.Password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将c3p0注入到sessionFactory中,hibernate会通过连接池获得连接:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置hibernate基本信息 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 将连接池注入到sessionFactory中 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 可选配置 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>				</span><br><span class="line">			<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 引入orm元数据，指定orm元数据所在的包路径，spring会读取包中的所有配置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappingDirectoryLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:my/study/web/domain&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="spring整合hibernate环境操作数据库"><a href="#spring整合hibernate环境操作数据库" class="headerlink" title="spring整合hibernate环境操作数据库"></a>spring整合hibernate环境操作数据库</h1><p>先创建测试类。<br>创建<code>UserDao</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;	</span><br><span class="line">	<span class="comment">//根据登陆名称查询user对象</span></span><br><span class="line">	<span class="function">User <span class="title">getByUserCode</span><span class="params">(String usercode)</span></span>;</span><br><span class="line">	<span class="comment">//保存用户</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建<code>UserDaoImpl</code>实现类，在整合环境中操作数据库，spring提供了一个hibernate模板对象<code>HibernateTemplate</code>.可以让实现类继承<code>HibernateDaoSupport</code>,从而简少Dao的依赖关系,不用再去配置<code>HibernateTemplate</code>.这样在使用模板时，直接使用<code>getHibernateTemplate()</code>方法就可以了.<br>要明确其中的依赖关系：<code>HibernateTemplate</code>通过<code>HibernateDaoSupport</code>创建出来，需要依赖<code>SessionFactory</code>,这个模板中封装的操作都是session中的操作.所以要先为dao注入<code>SessionFactory</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.HibernateException;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Query;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.hibernate5.HibernateCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.hibernate5.support.HibernateDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"><span class="comment">//HibernateDaoSupport 要为dao注入sessionFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">HibernateDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getByUserCode</span><span class="params">(<span class="keyword">final</span> String usercode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//HQL</span></span><br><span class="line">		<span class="keyword">return</span> getHibernateTemplate().execute(<span class="keyword">new</span> HibernateCallback&lt;User&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> User <span class="title">doInHibernate</span><span class="params">(Session session)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">					String hql = <span class="string">&quot;from User where user_code = ? &quot;</span>;</span><br><span class="line">					Query query = session.createQuery(hql);</span><br><span class="line">					query.setParameter(<span class="number">0</span>, usercode);</span><br><span class="line">					User user = (User) query.uniqueResult();</span><br><span class="line">				<span class="keyword">return</span> user;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//Criteria</span></span><br><span class="line">		<span class="comment">/*DetachedCriteria dc = DetachedCriteria.forClass(User.class);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		dc.add(Restrictions.eq(&quot;user_code&quot;, usercode));</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		List&lt;User&gt; list = (List&lt;User&gt;) getHibernateTemplate().findByCriteria(dc);</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		if(list != null &amp;&amp; list.size()&gt;0)&#123;</span></span><br><span class="line"><span class="comment">			return list.get(0);</span></span><br><span class="line"><span class="comment">		&#125;else&#123;</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在spring中配置<code>UserDao</code>,并注入sessionFactory：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置UserDao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 注入sessionFactory --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFacroty&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>HibernateTest.java</code>中添加测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> UserDao ud;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="comment">//测试Dao Hibernate模板</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		User user = ud.getByUserCode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/14.png" alt="测试结果"></p>
<h1 id="Spring中的aop事务"><a href="#Spring中的aop事务" class="headerlink" title="Spring中的aop事务"></a>Spring中的aop事务</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>配置事务，最核心的是要配置核心事务管理器.其中包含了所有事务的打开提交关闭操作.所以要先在spring配置核心事务管理器.<br><code>ctrl</code>+<code>shift</code>+<code>h</code>,搜索一下<code>TransactionManager</code>,可以看到<code>HibernateTransactionManager</code>就是需要的:<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/15.png" alt="HibernateTransactionManager"></p>
<p>将其配置到spring配置中,并且，使用它管理事务，要通过sessionFactory进行管理，所以要配置注入sessionFactory</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置核心事务管理器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="xml配置aop事务"><a href="#xml配置aop事务" class="headerlink" title="xml配置aop事务"></a>xml配置aop事务</h2><p><code>准备目标对象</code>-&gt;<code>配置通知</code>-&gt;<code>将配置织入目标对象(配置切点和切面)</code>。在前面已经有了目标对象，所以这里只需要配置通知和织入目标对象.具体可见博客上一篇文章</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;persist*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;modify*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置将通知织入目标对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置切点 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* my.study.web.impl.*ServiceImpl.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;transactionPoincut&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;transactionPoincut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：<br>在<code>UserService</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User u)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<code>UserDao</code>接口中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存用户</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User u)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<code>UserDaoImpl</code>中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">	getHibernateTemplate().save(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>UserServiceImpl</code>中添加方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao ud;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">	ud.save(u);		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为ud添加setter方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUd</span><span class="params">(UserDao ud)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.ud = ud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此之前，要在spring中的<code>userService</code>下将<code>userDao</code>注入进去:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servie配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ud&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService us;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试aop事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	User u = <span class="keyword">new</span> User();</span><br><span class="line">	</span><br><span class="line">	u.setUser_code(<span class="string">&quot;aoptest&quot;</span>);</span><br><span class="line">	u.setUser_name(<span class="string">&quot;aop测试&quot;</span>);</span><br><span class="line">	u.setUser_password(<span class="string">&quot;aop123&quot;</span>);</span><br><span class="line">	us.saveUser(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/16.png" alt="测试结果"></p>
<h2 id="注解配置aop事务"><a href="#注解配置aop事务" class="headerlink" title="注解配置aop事务"></a>注解配置aop事务</h2><p>在spring配置文件中，首先开启注解事务:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>改写<code>UserServiceImpl</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Isolation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"><span class="keyword">import</span> my.study.web.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> UserDao ud;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUserByCodePassword</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;getUserByCodePassword&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		ud.save(u);		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUd</span><span class="params">(UserDao ud)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ud = ud;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;userService&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> UserService us;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="comment">//测试aop事务</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		</span><br><span class="line">		u.setUser_code(<span class="string">&quot;aop注解test&quot;</span>);</span><br><span class="line">		u.setUser_name(<span class="string">&quot;aop测试注解&quot;</span>);</span><br><span class="line">		u.setUser_password(<span class="string">&quot;aop123&quot;</span>);</span><br><span class="line">		us.saveUser(u);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/17.png" alt="测试结果"></p>
<h1 id="扩大session作用范围"><a href="#扩大session作用范围" class="headerlink" title="扩大session作用范围"></a>扩大session作用范围</h1><p>为了避免使用懒加载时出现no-session问题.需要扩大session的作用范围</p>
<p>在<code>web.xml</code>配置filter:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 扩大session作用域范围 </span></span><br><span class="line"><span class="comment"> 	注意:任何filter一定要在struts的filter之前调用</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>openSessionInView<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>openSessionInView<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意:任何filter一定要在struts的filter之前调用,所以要放在struts配置前面<br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/18.png" alt="测试结果"></p>
<p>配置完毕</p>
<h1 id="实现用户登陆功能"><a href="#实现用户登陆功能" class="headerlink" title="实现用户登陆功能"></a>实现用户登陆功能</h1><h2 id="Web层"><a href="#Web层" class="headerlink" title="Web层"></a>Web层</h2><p>改写<code>UserAction</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.study.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> my.study.web.domain.User;</span><br><span class="line"><span class="keyword">import</span> my.study.web.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userService = userService;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//1. 调用service执行登陆逻辑</span></span><br><span class="line">		User u = userService.getUserByCodePassword(user);</span><br><span class="line">		<span class="comment">//2. 将返回的user对象放到session域中</span></span><br><span class="line">		ActionContext.getContext().getSession().put(<span class="string">&quot;user&quot;</span>, u);</span><br><span class="line">		<span class="comment">//3. 重定向到项目首页</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;toHome&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改写<code>struts.xml</code>配置，改变跳转地址:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">struts</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">&quot;struts.objectFactory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;spring&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constant</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;ssh&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;UserAction_*&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.action.UserAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&#123;1&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;toHome&quot;</span>&gt;</span>/index.html<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><p>改写<code>UserServiceImpl</code>中的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUserByCodePassword</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 根据登录名称查询登陆用户</span></span><br><span class="line">		User exitU = ud.getByUserCode(u.getUser_code());</span><br><span class="line">		<span class="comment">//2. 判断用户是否存在-&gt;不存在，抛出异常，提示用户名不存在</span></span><br><span class="line">		<span class="comment">//				-&gt;存在</span></span><br><span class="line">		<span class="comment">//					-&gt;密码错误，抛出异常，提示密码错误</span></span><br><span class="line">		<span class="keyword">if</span>(exitU==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户不存在！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(!exitU.getUser_password().equals(u.getUser_password())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;密码错误！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.返回查询到的用户对象</span></span><br><span class="line">		<span class="keyword">return</span> exitU;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意如果需要抛出异常，需要在<code>struts.xml</code>中配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">&quot;struts.objectFactory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;spring&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constant</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;ssh&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">global-exception-mappings</span> &gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exception-mapping</span> <span class="attr">result</span>=<span class="string">&quot;error&quot;</span> <span class="attr">exception</span>=<span class="string">&quot;java.lang.RuntimeException&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">exception-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">global-exception-mappings</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;UserAction_*&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my.study.web.action.UserAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&#123;1&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;toHome&quot;</span>&gt;</span>/index.html<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h2><p>dao层在上面已经实现好了</p>
<h2 id="测试用的页面"><a href="#测试用的页面" class="headerlink" title="测试用的页面"></a>测试用的页面</h2><p><code>login.jsp</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;ISO-8859-1&quot;%&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/UserAction_login&quot;</span> <span class="attr">method</span>=<span class="string">post</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">label</span>&gt;</span>username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user_code&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">label</span>&gt;</span>password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">password</span> <span class="attr">name</span>=<span class="string">&quot;user_password&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">&quot;exception.message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">s:property</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="项目总览"><a href="#项目总览" class="headerlink" title="项目总览"></a>项目总览</h1><p><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/19.png" alt="项目总览"><br><img src="%E6%95%B4%E5%90%88Struts2-Spring-Hibernate/20.png" alt="项目总览"></p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>学习笔记</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径问题</title>
    <url>/2019/04/23/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="最短路径问题-Shortest-Path"><a href="#最短路径问题-Shortest-Path" class="headerlink" title="最短路径问题(Shortest Path)"></a>最短路径问题(Shortest Path)</h1><p>本文的最短路径问题对于有向图也无线图都是成立的。常见应用:路径规划、工作任务规划。</p>
<p>在<a href="https://homxuwang.github.io/2019/04/01/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">图的遍历-广度优先遍历</a>中介绍的广度优先遍历的结果就是求出了一个最短路径。这种方法求的是从一个节点开始，到其他所有节点的最短路径，这样形成的是一个节点连接其他节点的树，即最短路径树(Shortest Path Tree).这棵树也是这个图的生成树，但是不是最小生成树，最小生成树是所有的边权值总和是最小的，而最短路径树是所有的节点距离起始节点的权值是最小的，这个求得最短路径树的过程，称为单源最短路径问题(Single Source Shortest Path).单源即是一个起始点的意思。这里是求出了从一个点到其他所有可以抵达的点的最短路径，不是两点间的最短路径。</p>
<p>下图中从0-&gt;2-&gt;1的操作称为松弛操作,即想计算到一个点的最短路径，尝试通过其他点”绕一下”,然后比较是否比直接到达要短。松弛操作是最短路径求解的核心。<br><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C1.png" alt="松弛操作"></p>
<h1 id="Dijkstra-单源最短路径算法"><a href="#Dijkstra-单源最短路径算法" class="headerlink" title="Dijkstra 单源最短路径算法"></a>Dijkstra 单源最短路径算法</h1><p><code>Dijkstra</code>算法的前提:</p>
<ul>
<li>图中不能有值为负的权重边</li>
</ul>
<p>其时间复杂度为O(E log(V))</p>
<p>以下面的有向加权图为例，介绍Dijkstra单源最短路径算法.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C2.png" alt="有向加权图"></p>
<p>假设从点0开始，寻求0到其他所有点的最短路径。因为起点是0，所以0到0的最短路径是0.<br><code>step1</code>:首先对起点进行标识，然后对它所有的临边进行访问,同时更新数组.此时找到没有访问的节点中，能够以最短的方式抵达的节点(此时为节点2,它只需用权值为2的费用就可以抵达),则可以说,从源点到节点2的最短路径就是权值2.(因为2已经是所有能抵达的相邻的节点中最小的权值了)。</p>
<p><strong>图中不能有负权边保证了这一前提的成立，因为没有负权边，所以即使通过别的边进行松弛操作，那么它们的权重之和也肯定也会大于该边</strong></p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C3.png" alt="step1-1 找到所有临边进行访问"></p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C4.png" alt="step1-2 找到相邻节点中能够以最小权值抵达的节点和其权值"></p>
<p><code>step2</code>:找到了从源点到节点2的最短路径以后，下面就要进行松弛操作.即验证从源点通过节点2到其他节点的路径是否比源点直接到达其他节点的路径要短。</p>
<p>开始看节点2的所有临边。</p>
<p>第一条临边为2-&gt;1的边，从源点到节点2权值为2,从节点2到节点1权值为1,总权重为3&lt;5.所以0-&gt;1的最短路径为0-&gt;2-&gt;1 = 3.所以可以在数组中更新对应的最短路径。</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C5.png" alt="step2-1 进行松弛操作"></p>
<p>接下来看节点2的下一个相邻节点节点4.因为节点4还没被访问过，所以从源点到节点4找到了一条权重为7的路径,在数组中进行记录。</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C6.png" alt="step2-2 找到临点4并记录"></p>
<p>然后接着看2-&gt;3.从2-&gt;3的权值为3,从0-&gt;2-&gt;3的权重为5.小于从0-&gt;3的权重6.这时候完成了Dijkstra算法的一轮循环.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C7.png" alt="step2-3 找到临点3此时的最短路径,并更新"></p>
<p><code>step3</code>:接着找到此时还没有找到最短路径的节点中,现在存的最短的路径能抵达的节点是谁，此时为节点1(权值为3).则可以说0-&gt;2-&gt;1就是从0到1的最短路径.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C8.png" alt="step3-1 找到源点到节点1的最短路径"></p>
<p>然后根据节点1的临边，进行松弛操作。此时为1-&gt;4的临边,其权值为1.由于0-&gt;1的最短路径为3,1-&gt;4的路径为1,此时经过1到达4的路径总长度为4.小于7.所以可以将从源点到节点4的路径长度更新为4.之前指向4的边就可以废弃不用了，它一定不是一条最短路径。此时和1相邻的边的松弛操作就做完了。</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C9.png" alt="step3-2 经过节点1进行松弛操作"></p>
<p>下面只有节点3和节点4没有访问到，此时最短的路径是到4,它的权值是4,从1-&gt;4的最短路径就是4.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C10.png" alt="step3-3 得出到4的最短路径"></p>
<p>然后对针对节点4,对节点4的所有邻边进行松弛操作.但是4无法到其他任何节点,所以此时不需要进行操作.</p>
<p><code>step4</code>:最后只剩下节点3没有访问过，此时没有其他选择,即现在的0-&gt;2-&gt;3即为0-&gt;3的最短路径.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C11.png" alt="step4 得出到3的最短路径"></p>
<p>此时就完成了Dijkstra算法.找到了一个以节点0为根的最短路径树.</p>
<p>算法总结和实现细节:</p>
<ul>
<li>对路径的记录都是在右侧的列表操作.第一个操作是找到没有访问过的节点中的最短的路径相应的节点.第二个操作是更新列表.可以借用IndexMinHeap实现该操作.开辟节点个数的空间.每次的插入和更新操作都是O(logV)的时间复杂度.Dijkstra的整个操作对所有的边进行遍历,最终的时间复杂度为O(ElogV).</li>
</ul>
<h2 id="Dijkstra算法实现"><a href="#Dijkstra算法实现" class="headerlink" title="Dijkstra算法实现"></a>Dijkstra算法实现</h2><p>程序的目录结构<br><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C12.png" alt="实现Dijkstra算法目录结构"></p>
<p>相关参考代码:<br><a href="https://homxuwang.github.io/2019/04/07/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F">堆和堆排序</a><br><a href="https://homxuwang.github.io/2019/03/29/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/#java%E8%A1%A8%E8%BE%BE">图的表达</a><br><a href="https://homxuwang.github.io/2019/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#%E9%99%84%E5%BD%952">最小索引堆</a><br><a href="https://homxuwang.github.io/2019/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">ReadWeightedGraph.java</a>有实现代码</p>
<p>Dijkstra算法的具体实现代码见附录1</p>
<h1 id="处理负权边"><a href="#处理负权边" class="headerlink" title="处理负权边"></a>处理负权边</h1><p>如图所示，如果引入了负权边,那么在没有负权边的情况下进行松弛操作之前就能确定一个最短边,现在则是有可能“绕路”的情况要比直接到达的情况效率更高。可以看出,它计算0-&gt;1-&gt;2的操作仍然依赖了松弛操作。</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C13.png" alt="负权边的情况"></p>
<p>当然，负权边会产生一个问题,如图。下图多了一条从2-&gt;0的负权边,这样就形成了一个<code>负权环</code>.如果一个图中出现了负权环,那么寻找一点到另一点的最短路径,只要经过了负权环,那么它就会在环中不断“循环”,因为在环中每转一次,那么最短路径都会减少.所以这样就无法计算出最短路径了(或最短路径为负无穷).</p>
<p>那么可以得出一个结论：拥有负权环的图没有最短路径.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C14.png" alt="负权环的问题"></p>
<p>两个结点也可以构成负权环,如下图的节点1和2:</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C15.png" alt="两个结点的负权环"></p>
<h1 id="Bellman-Ford-单源最短路径算法"><a href="#Bellman-Ford-单源最短路径算法" class="headerlink" title="Bellman-Ford 单源最短路径算法"></a>Bellman-Ford 单源最短路径算法</h1><p><strong>该算法的前提是,图中可以有负权边,但是不能有负权环</strong></p>
<p>Bellman-Ford可以判断图中是否有负权环,不过因此它的时间复杂度为O(EV).</p>
<p>Bellman-Ford的算法思想,如果一个图没有负权环,那么从一个点(起始点)到另一个点的最短路径,最多经过所有的顶点,有V-1条边.否则,则存在一个顶点经过了两次,说明存在负权环.</p>
<p>如下图,存在两个负权边.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C16.png" alt="负权边图"></p>
<p><code>step1</code>:找到所有节点0的临边,那么<code>暂时</code>找到了从0到其相邻顶点的最短路径.从另一个角度来看待节点0的所有临边,相当于对0的相应的所有的节点进行了一次松弛操作,这次操作的结果得到了从原点开始,经过1条边到达其他节点的最短路径.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C17.png" alt="第一次松弛操作"></p>
<p><code>step2</code>:对所有的点进行第2次松弛操作(这里记住松弛操作的核心思想就是尝试从一个点出发中间经过一个点到达目的点的路径是否会更短.即找一个两条边的路径,看其权值是否会比只有一条边的路径权值更小)。结合本例，第二次松弛操作就找到了从节点0到节点2更短的路径.</p>
<p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C18.png" alt="第一次松弛操作"></p>
<p>对一个点的一次松弛操作,就是找到经过这个点的另外一条路径,多一条边,权值会更小.</p>
<p>前面提到过,如果一个图没有负权环,那么从一个点(起始点)到另一个点的最短路径,最多经过所有的顶点,有V-1条边.否则,则存在一个顶点经过了两次,说明存在负权环.</p>
<p>如果对所有的点都进行V-1次松弛操作,理论上就找到了从源点到其他所有点的最短路径.也即Bellman-Ford的主体思想就是对所有的点进行V-1次松弛操作.</p>
<p>如果还可以进行松弛操作(也就是进行第V轮松弛操作),那么说明原图中有负权环.</p>
<p>对所有点进行松弛操作,每个边都要遍历一遍,时间复杂度为O(E).这样的操作要进行V轮,所以其时间复杂度为O(EV).</p>
<h1 id="Bellman-Ford-代码实现"><a href="#Bellman-Ford-代码实现" class="headerlink" title="Bellman-Ford 代码实现"></a>Bellman-Ford 代码实现</h1><p><img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%5C19.png" alt="代码目录结构"></p>
<p>BellmanFord的实现代码和两个图的表达见附录2</p>
<h1 id="Bellman-Ford代码的优化和其他算法"><a href="#Bellman-Ford代码的优化和其他算法" class="headerlink" title="Bellman-Ford代码的优化和其他算法"></a>Bellman-Ford代码的优化和其他算法</h1><p>可以使用队列进行相应优化,比如<code>queue-based bellman-ford</code>算法.</p>
<table>
<thead>
<tr>
<th>算法</th>
<th align="center">要求</th>
<th align="center">要求</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>dijkstra</td>
<td align="center">无负权边</td>
<td align="center">有向无向图均可</td>
<td>O(ElogV)</td>
</tr>
<tr>
<td>Bellman-Ford</td>
<td align="center">无负权环</td>
<td align="center">有向图</td>
<td>O(VE)</td>
</tr>
<tr>
<td>利用拓扑排序</td>
<td align="center">有向无环图<br>DAG</td>
<td align="center">有向图</td>
<td>O(V+E)</td>
</tr>
</tbody></table>
<p>所有对最短路径算法,可以回答任何一个点到其他任何点的最短路径.可以用Floyed算法实现,处理无负权环的图O(V^3)</p>
<p>对于最长路径问题,最长路径问题不能有正权环。无权图的最长路径问题是指数级难度的。对于有权图,不能使用Dijkstra求最长路径问题,但是可以使用Bellman-Ford算法.</p>
<h1 id="附录1-Dijkstra算法实现"><a href="#附录1-Dijkstra算法实现" class="headerlink" title="附录1-Dijkstra算法实现"></a>附录1-Dijkstra算法实现</h1><p>Dijkstra算法实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法求最短路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph G;      <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;               <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">private</span> Number[] distTo;    <span class="comment">// distTo[i]存储从起始点s到i的最短路径长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;  <span class="comment">// 标记数组,在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[] from; <span class="comment">// from[i]记录最短路径中,到达i节点的边是哪一条,可以用来恢复整个最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数,使用Dijkstra算法求最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dijkstra</span><span class="params">(WeightedGraph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">if</span>(s &lt; <span class="number">0</span> || s &gt; G.V())&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;s is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Number[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++) &#123;</span><br><span class="line">            distTo[i] = <span class="number">0.0</span>;</span><br><span class="line">            marked[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用索引堆记录当前找到的到达每个顶点的最短距离</span></span><br><span class="line">        IndexMinHeap&lt;Weight&gt; ipq = <span class="keyword">new</span> IndexMinHeap&lt;Weight&gt;(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于起始点s进行初始化</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        from[s] = <span class="keyword">new</span> Edge&lt;Weight&gt;(s, s, (Weight)(Number)<span class="number">0.0</span>);</span><br><span class="line">        ipq.insert(s,(Weight)distTo[s]);</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!ipq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// distTo[v]就是s到v的距离</span></span><br><span class="line">            marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对v的所有相邻节点进行更新,即松弛操作</span></span><br><span class="line">            <span class="keyword">for</span>( Object item : G.adj(v) )&#123;</span><br><span class="line">                Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">                <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">                <span class="comment">//如果从s点到w点的最短路径还没有找到</span></span><br><span class="line">                <span class="keyword">if</span>( !marked[w] )&#123;</span><br><span class="line">                    <span class="comment">//如果w点以前没有访问过</span></span><br><span class="line">                    <span class="comment">//或者访问过,但是通过当前的v点到w点距离更短,则进行更新</span></span><br><span class="line">                    <span class="keyword">if</span>( from[w] == <span class="keyword">null</span> || distTo[v].doubleValue() + e.wt().doubleValue() &lt; distTo[w].doubleValue() )&#123;</span><br><span class="line">                        <span class="comment">//长度更新为较小的值</span></span><br><span class="line">                        distTo[w] = distTo[v].doubleValue() + e.wt().doubleValue();</span><br><span class="line">                        <span class="comment">//对from进行更新</span></span><br><span class="line">                        from[w] = e;</span><br><span class="line">                        <span class="comment">//对最小索引堆进行判断</span></span><br><span class="line">                        <span class="keyword">if</span>( ipq.contain(w) )&#123;</span><br><span class="line">                            ipq.change(w,(Weight)distTo[w]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            ipq.insert(w,(Weight)distTo[w]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function">Number <span class="title">shortestPathTo</span><span class="params">( <span class="keyword">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V() )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasPathTo(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;these two have no path!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">( <span class="keyword">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V() )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找从s到w的最短路径,将整个路径经过的边存放在vec中</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; shortestPath( <span class="keyword">int</span> w )&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V() )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasPathTo(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;these two have no path!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过from数组逆向查找到从s到w的路径,存放到栈中</span></span><br><span class="line">        Stack&lt;Edge&lt;Weight&gt;&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Edge&lt;Weight&gt; e = from[w];</span><br><span class="line">        <span class="keyword">while</span>( e.v() != <span class="keyword">this</span>.s )&#123;</span><br><span class="line">            s.push(e);</span><br><span class="line">            e = from[e.v()];</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈中依次取出元素,获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; res = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line">            e = s.pop();</span><br><span class="line">            res.add(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V() )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasPathTo(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;these two have no path!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; path = shortestPath(w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; path.size(); i ++)&#123;</span><br><span class="line">            System.out.print(path.elementAt(i).v() + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>( i == path.size() - <span class="number">1</span>)</span><br><span class="line">                System.out.println(path.elementAt(i).w());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用的图文件<code>testG1.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">0 1 5</span><br><span class="line">0 2 2</span><br><span class="line">0 3 6</span><br><span class="line">1 4 1</span><br><span class="line">2 1 1</span><br><span class="line">2 4 5</span><br><span class="line">2 3 3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure>
<p>Main函数中测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试Dijkstra最短路径算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        SparseWeightedGraph&lt;Integer&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Integer&gt;(V, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Dijkstra最短路径算法同样适用于有向图</span></span><br><span class="line">        <span class="comment">//SparseGraph&lt;int&gt; g = SparseGraph&lt;int&gt;(V, false);</span></span><br><span class="line">        ReadWeightedGraph readGraph = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Dijkstra:\n&quot;</span>);</span><br><span class="line">        Dijkstra&lt;Integer&gt; dij = <span class="keyword">new</span> Dijkstra&lt;Integer&gt;(g,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; V ; i ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(dij.hasPathTo(i)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Shortest Path to &quot;</span> + i + <span class="string">&quot; : &quot;</span> + dij.shortestPathTo(i));</span><br><span class="line">                dij.showPath(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;No Path to &quot;</span> + i );</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test Dijkstra:</span><br><span class="line"></span><br><span class="line">Shortest Path to 1 : 3.0</span><br><span class="line">0-&gt;2-&gt;1</span><br><span class="line">----------</span><br><span class="line">Shortest Path to 2 : 2.0</span><br><span class="line">0-&gt;2</span><br><span class="line">----------</span><br><span class="line">Shortest Path to 3 : 5.0</span><br><span class="line">0-&gt;2-&gt;3</span><br><span class="line">----------</span><br><span class="line">Shortest Path to 4 : 4.0</span><br><span class="line">0-&gt;2-&gt;1-&gt;4</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<h1 id="附录2-Bellman-Ford-代码实现"><a href="#附录2-Bellman-Ford-代码实现" class="headerlink" title="附录2-Bellman-Ford 代码实现"></a>附录2-Bellman-Ford 代码实现</h1><p><code>BellmanFord.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用BellmanFord算法求最短路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFord</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph G;    <span class="comment">//图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;             <span class="comment">//设置起始点</span></span><br><span class="line">    <span class="keyword">private</span> Number[] distTo;   <span class="comment">//distT[i]存放从起始点s到i的最短路径长度</span></span><br><span class="line">    Edge&lt;Weight&gt;[] from;        <span class="comment">//from[i]记录最短路径中,到达i点的边是哪一条</span></span><br><span class="line">                                 <span class="comment">//可以用来回复整个最短路径</span></span><br><span class="line">    <span class="keyword">boolean</span> hasNegativeCycle;  <span class="comment">//标记图中是否有负权环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数,使用BellanFord算法求最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BellmanFord</span><span class="params">(WeightedGraph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Number[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        <span class="comment">//初始化所有的节点s都不可达,由from数组来表示</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            from[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置distTo[s]=0 ,并且让from[s]不为NULL,表示初始s节点可达且距离为0</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        from[s] = <span class="keyword">new</span> Edge&lt;Weight&gt;(s,s,(Weight)(Number)<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Bellman-Ford过程</span></span><br><span class="line">        <span class="comment">//进行V-1次循环,每一次循环求出从起点到其余所有点,最多使用pass步可以到达的最短距离</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> pass = <span class="number">1</span> ; pass &lt; G.V() ; pass ++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次循环中对所有的边进行一遍松弛操作</span></span><br><span class="line">            <span class="comment">//遍历所有边的方式是先遍历所有的顶点,然后遍历和所有顶点相邻的所有边</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">                <span class="comment">//使用临边迭代器遍历和所有顶点相邻的所有边</span></span><br><span class="line">                <span class="keyword">for</span>( Object item : G.adj(i) )&#123;</span><br><span class="line">                    Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">                    <span class="comment">//对于每一个边首先判断e.v()可达</span></span><br><span class="line">                    <span class="comment">//之后看如果e.w()以前没有到达过,显然可以更新distTo[e.w()]</span></span><br><span class="line">                    <span class="comment">//或者e.w()以前虽然到达过,但是通过这个e可以获得一个更短的距离,即可以进行一次松弛操作,也可以更新distTo[e.w()]</span></span><br><span class="line">                    <span class="keyword">if</span>(from[e.v()] != <span class="keyword">null</span> &amp;&amp; (from[e.w()] == <span class="keyword">null</span> || distTo[e.v()].doubleValue() + e.wt().doubleValue() &lt; distTo[e.w()].doubleValue()) )&#123;</span><br><span class="line">                        distTo[e.w()] = distTo[e.v()].doubleValue() + e.wt().doubleValue();</span><br><span class="line">                        from[e.w()] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hasNegativeCycle = detectNegativeCycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断图中是否有负权环</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">detectNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Object item : G.adj(i) )&#123;</span><br><span class="line">                Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;)item;</span><br><span class="line">                <span class="keyword">if</span>( from[e.v()] != <span class="keyword">null</span> &amp;&amp; distTo[e.v()].doubleValue() + e.wt().doubleValue() &lt; distTo[e.w()].doubleValue())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回图中是否有负权环</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">negativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNegativeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function">Number <span class="title">shortestPathTo</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasNegativeCycle)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;this Graph hasNegativeCycle!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasPathTo(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(s + <span class="string">&quot;to &quot;</span>+ w +<span class="string">&quot;doesn&#x27;t have path!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> from[w] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找s点到w点的最短路径,将整个路径经过的边存放在vec中</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; shortestPath(<span class="keyword">int</span> w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasNegativeCycle)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;this Graph hasNegativeCycle!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasPathTo(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(s + <span class="string">&quot;to &quot;</span>+ w +<span class="string">&quot;doesn&#x27;t have path!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过from数组逆向查找到从s到w的路径,存放到栈中</span></span><br><span class="line">        Stack&lt;Edge&lt;Weight&gt;&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Edge&lt;Weight&gt; e = from[w];</span><br><span class="line">        <span class="keyword">while</span> (e.v() != <span class="keyword">this</span>.s)&#123;</span><br><span class="line">            s.push(e);</span><br><span class="line">            e = from[e.v()];</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈中依次取出元素,获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; res = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line">            e = s.pop();</span><br><span class="line">            res.add(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &lt; <span class="number">0</span> || w &gt;= G.V())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;w is out of bounds!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasNegativeCycle)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;this Graph hasNegativeCycle!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasPathTo(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(s + <span class="string">&quot;to &quot;</span>+ w +<span class="string">&quot;doesn&#x27;t have path!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; res = shortestPath(w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; res.size() ; i ++)&#123;</span><br><span class="line">            System.out.print(res.elementAt(i).v() + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>( i == res.size() - <span class="number">1</span> )&#123;</span><br><span class="line">                System.out.println(res.elementAt(i).w());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>testG2.txt</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">0 1 5</span><br><span class="line">0 2 2</span><br><span class="line">0 3 6</span><br><span class="line">1 2 -4</span><br><span class="line">1 4 2</span><br><span class="line">2 4 5</span><br><span class="line">2 3 3</span><br><span class="line">4 3 -3</span><br></pre></td></tr></table></figure>

<p><code>testG_negative_circle.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">0 1 5</span><br><span class="line">0 2 2</span><br><span class="line">0 3 6</span><br><span class="line">1 2 -4</span><br><span class="line">2 1 1</span><br><span class="line">1 4 2</span><br><span class="line">2 4 5</span><br><span class="line">2 3 3</span><br><span class="line">4 3 -3</span><br></pre></td></tr></table></figure>

<p>Main测试函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试我们的Bellman-Ford最短路径算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG2.txt&quot;</span>;</span><br><span class="line"><span class="comment">//        String filename = &quot;testG_negative_circle.txt&quot;;</span></span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        SparseWeightedGraph&lt;Integer&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Integer&gt;(V, <span class="keyword">true</span>);</span><br><span class="line">        ReadWeightedGraph readGraph = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Bellman-Ford:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        BellmanFord&lt;Integer&gt; bellmanFord = <span class="keyword">new</span> BellmanFord&lt;Integer&gt;(g, s);</span><br><span class="line">        <span class="keyword">if</span>( bellmanFord.negativeCycle() )</span><br><span class="line">            System.out.println(<span class="string">&quot;The graph contain negative cycle!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; V ; i ++ )&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == s)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(bellmanFord.hasPathTo(i)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Shortest Path to &quot;</span> + i + <span class="string">&quot; : &quot;</span> + bellmanFord.shortestPathTo(i));</span><br><span class="line">                    bellmanFord.showPath(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;No Path to &quot;</span> + i );</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对没有负权环图的测试结果<code>testG2.txt</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test Bellman-Ford:</span><br><span class="line"></span><br><span class="line">Shortest Path to 1 : 5.0</span><br><span class="line">0 -&gt; 1</span><br><span class="line">----------</span><br><span class="line">Shortest Path to 2 : 1.0</span><br><span class="line">0 -&gt; 1 -&gt; 2</span><br><span class="line">----------</span><br><span class="line">Shortest Path to 3 : 3.0</span><br><span class="line">0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 3</span><br><span class="line">----------</span><br><span class="line">Shortest Path to 4 : 6.0</span><br><span class="line">0 -&gt; 1 -&gt; 2 -&gt; 4</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>对有负权环图<code>testG_negative_circle.txt</code>的测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test Bellman-Ford:</span><br><span class="line"></span><br><span class="line">The graph contain negative cycle!</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Socket编程</title>
    <url>/2019/05/11/%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在<a href="https://homxuwang.github.io/2019/05/06/%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/">浅谈TCP协议</a>中提到过：<br>在本地两个进程间进行通信时，可以使用唯一标识符PID。但是如果是两台不同计算机之间的进程进行通信时,只用PID是不够的,这时就在传输层中使用协议端口号,简称端口。IP可以唯一标识主机，而TCP协议和端口号可以唯一标识一个主机中的进程。这样可以用三元组(IP地址+协议+端口号)唯一标识一个网络中的进程。</p>
<p>在唯一标识了一个网络中的进程后,便可以用socket进行编程了。</p>
<h1 id="Socket简介"><a href="#Socket简介" class="headerlink" title="Socket简介"></a>Socket简介</h1><p>Socket与TCP/IP协议没有必然的联系,Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。<br><img src="%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/1.png" alt="Socket"></p>
<p>Socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket，一个Socket由一个IP地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p>
<p>从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p>
<p>使用TCP协议通信的Socket的通信流程如下图：<br><img src="%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/2.png" alt="Socket通信流程"></p>
<ul>
<li><p>服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket</p>
</li>
<li><p>服务器为socket绑定ip地址和端口号</p>
</li>
<li><p>服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开</p>
</li>
<li><p>客户端创建socket</p>
</li>
<li><p>客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket</p>
</li>
<li><p>服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即接收方法一直到客户端返回连接信息后才返回，开始接收下一个客户端请求。</p>
</li>
<li><p>客户端连接成功，向服务器发送连接状态信息</p>
</li>
<li><p>服务器接收方法返回，连接成功</p>
</li>
<li><p>客户端向socket写入信息</p>
</li>
<li><p>服务器读取信息</p>
</li>
<li><p>客户端关闭</p>
</li>
<li><p>服务器端关闭</p>
</li>
</ul>
<h1 id="简单的Socket编程"><a href="#简单的Socket编程" class="headerlink" title="简单的Socket编程"></a>简单的Socket编程</h1><p>客户端想服务器发送一个字符串,服务器接收到字符串后打印,然后向客户端返回字符串的长度,最后,客户端输出服务器端返回的该字符串的长度,分别用TCP和UDP两种方式实现.</p>
<p>结合上一节内容,流程概括为:</p>
<ul>
<li>socket() 创建套接字</li>
<li>bind() 分配套接字地址</li>
<li>listen() 等待连接请求</li>
<li>accept() 允许连接请求</li>
<li>read()/write() 数据交换</li>
<li>close() 关闭连接</li>
</ul>
<p>在项目中创建以下结构:</p>
<p><img src="%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/4.png" alt="Socket编程"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>先以TCP为例.<code>TCPClient</code>表示TCP客户端,<code>TCPServer</code>表示TCP服务端,<code>LengthCaculator</code>是一个单独的处理线程,对数据的业务逻辑处理交给它来实现.</p>
<p><code>TCPServer</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.homxuwang.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建Socket,并将socket绑定到5202端口</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">5202</span>);</span><br><span class="line">        <span class="comment">//死循环,使得socket一直等待并处理客户端发送过来的请求</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//监听5202端口,知道客户端返回信息后才返回</span></span><br><span class="line">            Socket socket = ss.accept();</span><br><span class="line">            <span class="comment">//获取客户端的请求信息后,执行相关业务逻辑</span></span><br><span class="line">            <span class="keyword">new</span> LengthCalculator(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TCPClient</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.homxuwang.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建socket,并指定连接的是本机的端口号为5202的服务器socket</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">5202</span>);</span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//将要传递给server的字符串参数转换成byte数组,并将数组写入到输出流中</span></span><br><span class="line">        os.write(<span class="keyword">new</span> String(<span class="string">&quot;Hello Socket&quot;</span>).getBytes());</span><br><span class="line">        <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//buff 主要用来读取输入的内容,存成byte数组,ch主要用来获取读取数组的长度</span></span><br><span class="line">        ch = is.read(buff);</span><br><span class="line">        <span class="comment">//将接收流的byte数组转换成字符串,这里是从服务端发回来的字符串参数的长度</span></span><br><span class="line">        String content = <span class="keyword">new</span> String (buff,<span class="number">0</span>,ch);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">//关闭流和socket</span></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LengthCaculator</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.homxuwang.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthCalculator</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以socket为成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LengthCalculator</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取socket的输出流</span></span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//获取socket的输入流</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//buff主要用来读取输入的内容,存成byte数组,主要用来获取读取数组的长度</span></span><br><span class="line">            ch = is.read(buff);</span><br><span class="line">            <span class="comment">//将接收流的byte数组转换成字符串,这里获取的内容是客户端发送来的字符串参数</span></span><br><span class="line">            String content = <span class="keyword">new</span> String(buff,<span class="number">0</span>,ch);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">            <span class="comment">//向输出流里写入获得的字符串长度,回发给客户端</span></span><br><span class="line">            os.write(String.valueOf(content.length()).getBytes());</span><br><span class="line">            <span class="comment">//关闭输入输出流和socket</span></span><br><span class="line">            os.close();</span><br><span class="line">            is.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行测试时,先运行Server,使得其能够进行监听,然后运行Client,打印结果如下:<br><img src="%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/3.png" alt="TCPClient打印结果"></p>
<p><img src="%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/5.png" alt="TCPServer打印结果"></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><code>UDPServer.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.homxuwang.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//服务端接受客户端发送的数据报</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">52021</span>); <span class="comment">//监听的端口号</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>]; <span class="comment">//存储从客户端接受到的内容</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buff,buff.length);</span><br><span class="line">        <span class="comment">//接受客户端发送过来的内容,并将内容封装进DatagramPacket对象中</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = packet.getData(); <span class="comment">//从DatagramPacket对象中获取到真正存储的数据</span></span><br><span class="line">        <span class="comment">//将数据从二进制转换成字符串形式</span></span><br><span class="line">        String content = <span class="keyword">new</span> String(buff,<span class="number">0</span>,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">//将要发送给客户端的数据转换成二进制</span></span><br><span class="line">        <span class="keyword">byte</span>[] sendedContent = String.valueOf(content.length()).getBytes();</span><br><span class="line">        <span class="comment">//服务端给客户端发送数据报</span></span><br><span class="line">        <span class="comment">//从DatagramPacket对象中获取到数据的来源地址与端口号</span></span><br><span class="line">        DatagramPacket packetToClient = <span class="keyword">new</span> DatagramPacket(sendedContent,</span><br><span class="line">                sendedContent.length,packet.getAddress(),packet.getPort());</span><br><span class="line">        socket.send(packetToClient); <span class="comment">//发送数据给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UDPServer.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.homxuwang.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//客户端发送数据报给服务端</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">//要发给服务端的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="string">&quot;Hello Socket&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//将IP封装成InetAddress对象</span></span><br><span class="line">        InetAddress address = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">//将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf,buf.length,address,<span class="number">52021</span>);</span><br><span class="line">        <span class="comment">//发送数据给服务端</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端接受服务端发送来的数据报文</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">//创建DatagramPacket对象用来存储服务端发送来的数据</span></span><br><span class="line">        DatagramPacket receivedPacket = <span class="keyword">new</span> DatagramPacket(data,data.length);</span><br><span class="line">        <span class="comment">//将收到的数据存储到DatagramPacket对象中</span></span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        <span class="comment">//将服务端发送来的数据取出并打印</span></span><br><span class="line">        String content = <span class="keyword">new</span> String(receivedPacket.getData(),<span class="number">0</span>,receivedPacket.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行测试时,先运行Server,使得其能够进行监听,然后运行Client,打印结果如下:<br><img src="%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/6.png" alt="UDPClient打印结果"></p>
<p><img src="%E6%B5%85%E6%9E%90Socket%E7%BC%96%E7%A8%8B/7.png" alt="UDPServer打印结果"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hit-alibaba.github.io/interview/basic/network/Socket-Programming-Basic.html">https://hit-alibaba.github.io/interview/basic/network/Socket-Programming-Basic.html</a></p>
<p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/WebSocket/iOS_WebSocket.md">https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/WebSocket/iOS_WebSocket.md</a></p>
<p><a href="https://broqiang.com/posts/waht-is-socket">https://broqiang.com/posts/waht-is-socket</a></p>
<p><a href="https://blog.csdn.net/ns_code/article/details/14105457">https://blog.csdn.net/ns_code/article/details/14105457</a></p>
]]></content>
      <tags>
        <tag>java基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java代理(Proxy)</title>
    <url>/2019/05/15/%E6%B5%85%E8%B0%88Java%E4%BB%A3%E7%90%86-Proxy/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<p>利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现那个接口时才有必要使用。</p>
</blockquote>
<p>——摘自《JAVA核心技术卷I》</p>
<p>何时使用代理？</p>
<blockquote>
<p>假设有一个表示接口的Class对象(有可能只包含一个接口),它的确切类型在编译时无法知道。这确实有些难度。想要构造一个实现这些接口的类,就需要使用newInstance方法或反射找出这个类的构造器。但是，不能实例化一个接口，需要在程序处于运行状态时定义一个新类。<br>为了解决这个问题,有些程序将会生成代码；将这西代码放置在一个文件中；调用编译器；然后再加载结果类文件。很自然，这样做的速度会比较慢，并且需要将编译器与程序放在一起。而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。</p>
</blockquote>
<p>——摘自《JAVA核心技术卷I》</p>
<p><img src="%E6%B5%85%E8%B0%88Java%E4%BB%A3%E7%90%86-Proxy/1.png" alt="代理模式"></p>
<p>代理模式中主要有三个要素:</p>
<ul>
<li><code>Subject</code>(被代理的接口).声明了代理对象和真实对象的公共接口.即定义了程序要实现哪些行为.</li>
<li><code>RealSubject</code>(真正被代理的对象）.即真实对象,是代理对象所表示的真实对象,也就是最终被引用的对象.真实对象继承于接口,真正提供一些服务.</li>
<li><code>Proxy</code>(代理).可以看做代理对象,当访问真实对象时,需要通过代理去访问。</li>
</ul>
<p>也即:</p>
<ul>
<li>用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。</li>
<li>接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。</li>
<li>代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。</li>
<li>用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。</li>
<li>代理和真实对象必须继承同一个接口.</li>
<li>代理对象必须包含真实的对象.</li>
</ul>
<p>如果难于理解的话，我用事例说明好了。值得注意的是，代理可以分为静态代理和动态代理两种。先从静态代理讲起。</p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>电影开始前会播放一些广告,电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。</p>
<p>现在用代码来进行模拟。<br>根据第一节中介绍的,代理模式要有三个要素:<code>Subject</code>、<code>RealSubject</code>、<code>Proxy</code>.</p>
<p>首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后要有一个真正的实现这个 Movie 接口的类.这个类表示真正的影片。它实现了 Movie 接口，当play() 方法调用时，影片就开始播放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealMovie</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You are watching Avengers4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要一个实现接口的代理类。Cinema 就是 Proxy 代理对象，前面提到代理对象必须包含真实的对象，Cinema对象中就有一个RealMovie对象。它有一个 play() 方法。不过调用 play() 方法时，它进行了一些相关利益的处理，那就是广告。现在，我们编写测试代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealMovie movie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(RealMovie movie)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        playAdvertisement(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        movie.play();</span><br><span class="line"></span><br><span class="line">        playAdvertisement(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">playAdvertisement</span><span class="params">(<span class="keyword">boolean</span> isStart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( isStart )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The film will be on at once.This is an advertisement!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The film is over.This is an advertisement!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RealMovie realmovie = <span class="keyword">new</span> RealMovie();</span><br><span class="line"></span><br><span class="line">        Movie movie = <span class="keyword">new</span> Cinema(realmovie);</span><br><span class="line"></span><br><span class="line">        movie.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The film will be on at once.This is an advertisement!</span><br><span class="line">You are watching Avengers4</span><br><span class="line">The film is over.This is an advertisement!</span><br></pre></td></tr></table></figure>

<p>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些<strong>功能的附加与增强</strong>。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</p>
<p>上面介绍的是静态代理的一个示例，为什么叫做静态呢？因为它的类型是事先预定好的，比如上面代码中的 Cinema 这个类。下面要介绍的内容就是动态代理。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理的代理类并不需要在Java代码中定义，而是在运行时动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。通过使用动态代理，可以做一个“统一指示”，对所有代理类的方法进行统一处理，而不用逐一修改每个方法。</p>
<p>与静态代理相比，抽象角色、真实角色都没有变化。变化的只有代理类。</p>
<p>上一节代码中 Cinema 类是代理，需要手动编写代码让 Cinema 实现 Movie 接口，而在动态代理中，我们可以让程序在运行的时候自动在内存中创建一个实现 Movie 接口的代理，而不需要去定义 Cinema 这个类。这就是它被称为动态的原因。</p>
<p>还是使用上面的例子</p>
<p><code>Subject</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RealSubject</code>,我们播放的电影为《复仇者联盟4》:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Avengers4</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You are watching Avengers4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键的不同在于代理类的实现,在使用动态代理时，需要定义一个位于代理类与委托类之间的中介类，也叫动态代理类，这个类被要求实现InvocationHandler接口.:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object moive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(Object moive)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.moive = moive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is &quot;</span>+ <span class="keyword">this</span>.getClass().getSimpleName() +<span class="string">&quot;.The film will be on at once.&quot;</span>);</span><br><span class="line">        method.invoke(moive,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;The film is over.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用代理类对象的方法时，这个“调用”会转送到中介类的invoke方法中，参数method标识了具体调用的是代理类的哪个方法，args为这个方法的参数。</p>
<p>进行测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//要代理的真实对象</span></span><br><span class="line">        RealMovie realmovie = <span class="keyword">new</span> RealMovie();</span><br><span class="line">        <span class="comment">//创建中介类实例</span></span><br><span class="line">        InvocationHandler cinema = <span class="keyword">new</span> Cinema(realmovie);</span><br><span class="line">        <span class="comment">//动态产生一个代理类</span></span><br><span class="line">        Movie dynamicProxyOfMovie = (Movie) Proxy.newProxyInstance(realmovie.getClass().getClassLoader(),</span><br><span class="line">                realmovie.getClass().getInterfaces(),</span><br><span class="line">                cinema);</span><br><span class="line">        <span class="comment">//通过代理类，执行doSomething方法</span></span><br><span class="line">        dynamicProxyOfMovie.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching Avengers4</span><br><span class="line">The film is over.</span><br></pre></td></tr></table></figure>

<p>在上面动态代理的例子中,并没有像静态代理那样为 Moive 接口实现一个代理类，但最终它仍然实现了相同的功能，这其中的差别，就是之前讨论的动态代理所谓“动态”的原因。<br>一个典型的动态代理可分为以下四个步骤：</p>
<ul>
<li>创建抽象角色(Movie)</li>
<li>创建真实角色(Avengers4)</li>
<li>通过实现InvocationHandler接口创建中介类(Cinema)</li>
<li>通过场景类，动态生成代理类</li>
</ul>
<h1 id="动态代理语法"><a href="#动态代理语法" class="headerlink" title="动态代理语法"></a>动态代理语法</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>动态代理对象,使用Proxy的静态方法newProxyInstance方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<p>这个方法有三个参数:</p>
<ul>
<li>一个类加载器(class loader).</li>
<li>一个Class对象数组,每个元素都是需要实现的接口.</li>
<li>一个调用处理器.</li>
</ul>
<h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><p>InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke</code>方法中的三个参数:</p>
<ul>
<li>proxy 代理对象.即我们上面的<code>RealMovie</code></li>
<li>method 代理对象调用的方法</li>
<li>args 调用的方法中的参数</li>
</ul>
<blockquote>
<p>无论何时调用代理对象的方法,调用处理器的invoke方法都会被调用,并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。</p>
</blockquote>
<p>——摘自《JAVA核心技术卷I》</p>
<p>正是这个方法决定了怎么样处理代理传递过来的方法调用。<br>因为 Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。</p>
<p>那么实际生活中,电影院中不仅播放《复仇者联盟4》,还会播放其他电影。比如我们播放《黑客帝国(The Matrix)》</p>
<p>创建类<code>TheMatrix</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheMatrix</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You are watching The Matrix.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么电影院同样播放电影《黑客帝国》,它也在同一个电影院播放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Avengers4 avengers4 = <span class="keyword">new</span> Avengers4();</span><br><span class="line">        TheMatrix theMatrix = <span class="keyword">new</span> TheMatrix();</span><br><span class="line"></span><br><span class="line">        InvocationHandler cinemaWanDa = <span class="keyword">new</span> Cinema(avengers4);</span><br><span class="line">        InvocationHandler cinemaWanDa1 = <span class="keyword">new</span> Cinema(theMatrix);</span><br><span class="line">        Movie dynamicProxyAvengers = (Movie) Proxy.newProxyInstance(avengers4.getClass().getClassLoader(),</span><br><span class="line">                avengers4.getClass().getInterfaces(),</span><br><span class="line">                cinemaWanDa);</span><br><span class="line"></span><br><span class="line">        Movie dynamicProxyTheMatrix = (Movie) Proxy.newProxyInstance(theMatrix.getClass().getClassLoader(),</span><br><span class="line">                theMatrix.getClass().getInterfaces(),</span><br><span class="line">                cinemaWanDa1);</span><br><span class="line"></span><br><span class="line">        dynamicProxyAvengers.play();</span><br><span class="line"></span><br><span class="line">        dynamicProxyTheMatrix.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching Avengers4</span><br><span class="line">The film is over.</span><br><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching The Matrix.</span><br><span class="line">The film is over.</span><br></pre></td></tr></table></figure>

<p>假设此时正值世界杯期间，电影院开通了观看球赛的服务。<br>首先和电影一样,创建一个球赛的接口(Subject).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorldCup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">watchTheMatch</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候需要一个<code>RealSubject</code>，假设我们观看法国和西班牙的比赛:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrenchVSSpain</span> <span class="keyword">implements</span> <span class="title">WorldCup</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchTheMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You are watching French VS Spain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进行测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Avengers4 avengers4 = <span class="keyword">new</span> Avengers4();</span><br><span class="line">        TheMatrix theMatrix = <span class="keyword">new</span> TheMatrix();</span><br><span class="line">        FrenchVSSpain frenchVSSpain = <span class="keyword">new</span> FrenchVSSpain();</span><br><span class="line"></span><br><span class="line">        InvocationHandler cinemaWanDa = <span class="keyword">new</span> Cinema(avengers4);</span><br><span class="line">        InvocationHandler cinemaWanDa1 = <span class="keyword">new</span> Cinema(theMatrix);</span><br><span class="line">        InvocationHandler cinemaWanda2 = <span class="keyword">new</span> Cinema(frenchVSSpain);</span><br><span class="line"></span><br><span class="line">        Movie dynamicProxyAvengers = (Movie) Proxy.newProxyInstance(avengers4.getClass().getClassLoader(),</span><br><span class="line">                avengers4.getClass().getInterfaces(),</span><br><span class="line">                cinemaWanDa);</span><br><span class="line"></span><br><span class="line">        Movie dynamicProxyTheMatrix = (Movie) Proxy.newProxyInstance(theMatrix.getClass().getClassLoader(),</span><br><span class="line">                theMatrix.getClass().getInterfaces(),</span><br><span class="line">                cinemaWanDa1);</span><br><span class="line"></span><br><span class="line">        dynamicProxyAvengers.play();</span><br><span class="line"></span><br><span class="line">        dynamicProxyTheMatrix.play();</span><br><span class="line"></span><br><span class="line">        WorldCup dynamicProxyFVSS = (WorldCup) Proxy.newProxyInstance(frenchVSSpain.getClass().getClassLoader(),</span><br><span class="line">                frenchVSSpain.getClass().getInterfaces(),</span><br><span class="line">                cinemaWanda2);</span><br><span class="line"></span><br><span class="line">        dynamicProxyFVSS.watchTheMatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching Avengers4</span><br><span class="line">The film is over.</span><br><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching The Matrix.</span><br><span class="line">The film is over.</span><br><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching French VS Spain</span><br><span class="line">The film is over.</span><br></pre></td></tr></table></figure>

<p>同样是通过 Proxy.newProxyInstance() 方法，却产生了 Movie 和 WorldCup 两种接口的实现类代理，这就是动态代理的强大之处。</p>
<h1 id="动态代理的秘密"><a href="#动态代理的秘密" class="headerlink" title="动态代理的秘密"></a>动态代理的秘密</h1><p>Proxy 能够动态产生不同接口类型的代理，是通过传递的接口，然后通过反射动态生成了一个接口实例。</p>
<p>Proxy的全部源码查看<a href="https://github.com/mynawang/Java8-Source-Code/blob/master/src/main/jdk8/java/lang/reflect/Proxy.java"><strong>点击这里</strong></a></p>
<p>newProxyInstance()方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        InvocationHandler h)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">      <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">      <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">          checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">              checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">          <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">          <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">              AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                      cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">          Throwable t = e.getCause();</span><br><span class="line">          <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">              <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Proxy类的newProxyInstance方法，<strong>主要业务逻辑</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成代理类class，并加载到jvm中</span></span><br><span class="line">Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);</span><br><span class="line"><span class="comment">//获取代理类参数为InvocationHandler的构造函数</span></span><br><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="comment">//生成代理类，并返回</span></span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码做了三件事：</p>
<ul>
<li><p>根据传入的参数interfaces动态生成一个类，它实现interfaces中的接口，该例中即Movie接口的play方法。假设动态生成的类为$Proxy0。</p>
</li>
<li><p>通过传入的classloder,将刚生成的$Proxy0类加载到jvm中。</p>
</li>
<li><p>利用中介类，调用 $Proxy0的$Proxy0(InvocationHandler)构造函数，创建$Proxy0类的实例，其InvocationHandler属性，为我们创建的中介类。</p>
</li>
</ul>
<p>newProxyInstance 方法创建了一个实例，它是通过 cl 这个 Class 文件的构造方法反射生成。cl 由 getProxyClass0() 方法获取。<br>上面的核心，就在于getProxyClass0方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在Proxy类中有个属性proxyClassCache，这是一个WeakCache类型的静态变量。它指示了类加载器和代理类之间的映射。所以proxyClassCache的get方法用于根据类加载器来获取Proxy类，如果已经存在则直接从cache中返回，如果没有则创建一个映射并更新cache表。</p>
<p>直接通过缓存获取，如果获取不到，注释说会通过 ProxyClassFactory 生成。(这里就不贴ProxyClassFactory方法的全部源码,可以去上面的连接查看)</p>
<p>ProxyClassFactory的部分源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment"> * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">BiFunction</span>&lt;<span class="title">ClassLoader</span>, <span class="title">Class</span>&lt;?&gt;[], <span class="title">Class</span>&lt;?&gt;&gt;</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">          <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">         String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">         <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">             proxyName, interfaces, accessFlags);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                 proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">               * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">               * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">               * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">               * exceeded).</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个类的注释说，通过指定的 ClassLoader 和 接口数组 用工厂方法生成 proxy class。 然后这个 proxy class 的名字是：<strong>包名+$Proxy+id序号</strong></p>
<p>跟一下代理类的创建流程：<br>调用Factory类的get方法，而它又调用了ProxyClassFactory类的apply方法，最终找到下面一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">              proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure>
<p>就是它，生成了代理类。</p>
<p>下面检测检测一下动态生成的代理类的名字是不是包名+$Proxy+id序号,在测试类中添加如下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;dynamicProxyAvengers class name:&quot;</span>+dynamicProxyAvengers.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamicProxyTheMatrix class name:&quot;</span>+dynamicProxyTheMatrix.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;dynamicProxyFVSS class name:&quot;</span>+dynamicProxyFVSS.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching Avengers4</span><br><span class="line">The film is over.</span><br><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching The Matrix.</span><br><span class="line">The film is over.</span><br><span class="line">This is Cinema.The film will be on at once.</span><br><span class="line">You are watching French VS Spain</span><br><span class="line">The film is over.</span><br><span class="line">dynamicProxyAvengers class name:com.sun.proxy.$Proxy0</span><br><span class="line">dynamicProxyTheMatrix class name:com.sun.proxy.$Proxy0</span><br><span class="line">dynamicProxyFVSS class name:com.sun.proxy.$Proxy1</span><br></pre></td></tr></table></figure>

<p>Movie 接口的代理类名是：<code>com.sun.proxy.$Proxy0</code><br>WorldCup 接口的代理类名是：<code>com.sun.proxy.$Proxy1</code><br>这说明动态生成的 proxy class 与 Proxy 这个类同一个包。</p>
<p><img src="%E6%B5%85%E8%B0%88Java%E4%BB%A3%E7%90%86-Proxy/2.png" alt="动态代理设计的角色"></p>
<p>图片来自 <a href="https://blog.csdn.net/briblue/article/details/73928350">https://blog.csdn.net/briblue/article/details/73928350</a></p>
<p>红框中 <code>$Proxy0</code>就是通过 Proxy 动态生成的。<br><code>$Proxy0</code>实现了要代理的接口。<br><code>$Proxy0</code>通过调用 InvocationHandler来执行任务。</p>
<h1 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h1><p>主要作用，还是在不修改被代理对象的源码上，进行功能的增强。</p>
<p>这在 AOP 面向切面编程领域经常见。</p>
<blockquote>
<p>代理类是在程序运行过程中创建。然而一旦被创建,就变成了常规类，与虚拟机中的任何其他类没有什么区别。<br>所有的代理类都拓展于Proxy类。一个代理类只有一个实例域——调用处理器，它定义在Proxy的超类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。</p>
</blockquote>
<p>例如上面我们代理Avengers4对象时,Cinema包装了实际的对象。(因为电影要在电影院播放)。</p>
<blockquote>
<p>没有定义代理类的名字,Sun虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名。<br>对于特定的类加载器和预设的一组接口来说,只能有一个代理类。也就是说,如果使用同一个类加载器和接口数组调用两次newProxyInstance方法的话,那么只能够得到同一个类的两个对象,也可以利用getProxyClass方法获得这个类:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class proxyClass = Proxy.getProxyClass(<span class="keyword">null</span>,interfaces);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代理类一定是public和final。如果代理类实现的所有接口都是pubic,代理类就不属于某个特定的包;否则,所有非公有的接口都必须属于同一个包,同时,代理类也属于这个包。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的例子可以用下图来概括。</p>
<p><img src="%E6%B5%85%E8%B0%88Java%E4%BB%A3%E7%90%86-Proxy/3.png" alt="代理"></p>
<ul>
<li>代理分为静态代理和动态代理两种。</li>
<li>静态代理，代理类需要自己编写代码写成。</li>
<li>动态代理，代理类通过 Proxy.newInstance() 方法生成。<br>不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。</li>
<li>静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。</li>
<li>动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。</li>
<li>代理模式本质上的目的是为了增强现有代码的功能。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>《JAVA核心技术卷I》</p>
</li>
<li><p><a href="https://blog.csdn.net/briblue/article/details/73928350">轻松学，Java 中的代理模式及动态代理</a></p>
</li>
<li><p><a href="https://github.com/mynawang/Java8-Source-Code">Java8-Source-Code</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011291179">Java三种代理模式：静态代理、动态代理和cglib代理</a></p>
</li>
<li><p><a href="http://www.importnew.com/26116.html">说说JAVA代理模式</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析IOC和DI</title>
    <url>/2019/06/06/%E6%B5%85%E6%9E%90IOC%E5%92%8CDI/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li><p>IOC(Inversion of Control): 其思想是<strong>反转资源获取的方向</strong>.传统的资源查找方式要求组件向容器发起请求查找资源.作为回应，容器适时的返回资源。而应用了IOC之后，则是<strong>容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源</strong>.这种形式也被称为查找的被动形式。</p>
<ul>
<li>控制什么？<br>控制对象的创建及销毁（生命周期）</li>
<li>反转什么？<br>对象的控制权被反转了，将对象的控制权交给IOC容器</li>
</ul>
</li>
<li><p>DI(Dependency Injection)——IOC的另一种表述方式：即<strong>组件以一些预先定义好的方式(如:setter方法)接受来自肉容器的资源注入</strong>.相对于IOC而言，这种表述更直接.</p>
</li>
</ul>
<p>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
<p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<ul>
<li><p>依赖注入：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
</li>
<li><p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li><p>谁依赖于谁：当然是某个容器管理对象依赖于IoC容器；“被注入对象的对象”依赖于“依赖对象”；</p>
</li>
<li><p>为什么需要依赖：容器管理对象需要IoC容器来提供对象需要的外部资源；</p>
</li>
<li><p>谁注入谁：很明显是IoC容器注入某个对象，也就是注入“依赖对象”；</p>
</li>
<li><p>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
</li>
</ul>
</li>
</ul>
<p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<h1 id="分析实际"><a href="#分析实际" class="headerlink" title="分析实际"></a>分析实际</h1><p>假设有个人叫张三，他有一辆奥迪车。张三下班的时候要开车回家，那么他对奥迪便产生了一种依赖关系。</p>
<p>Audi和ZhangSan的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnLeft&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnRight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.stop&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangSan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Audi audi = <span class="keyword">new</span> Audi();</span><br><span class="line">        </span><br><span class="line">        audi.start();</span><br><span class="line">        audi.turnLeft();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，张三要回家的话，需要</p>
<ul>
<li>创建一辆车<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Audi audi = <span class="keyword">new</span> Audi();</span><br></pre></td></tr></table></figure></li>
<li>控制车辆启动、直行、左右转<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">audi.start();</span><br><span class="line">audi.turnLeft();</span><br><span class="line">audi.turnRight();</span><br><span class="line">audi.turnRight();</span><br><span class="line">audi.stop();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>那么，张三用车肯定不只是用来回家。还可以买东西、约会、飙车等等。<br>这时候，代码就该修改为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangSan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Audi audi = <span class="keyword">new</span> Audi();</span><br><span class="line">        </span><br><span class="line">        audi.start();</span><br><span class="line">        audi.turnLeft();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Audi audi = <span class="keyword">new</span> Audi();</span><br><span class="line">        </span><br><span class="line">        audi.start();</span><br><span class="line">        audi.turnLeft();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候，张三换车了，换成一辆BMW</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnLeft&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnRight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这时候要把所有<code>ZhangSan</code>类中的引用Audi的代码都改为BMW。<br>这体现出来了车和张三之间的高耦合性。其次，这在设计时有一些问题：</p>
<ul>
<li>张三所有的行为都需要自己主动创建一辆车。</li>
<li>更换车辆的代价是巨大的。要把所有奥迪车的引用都换为BMW。</li>
</ul>
<p>这时候可以在张三类中进行一些改进，把他的车提到张三的属性域中，这样只需修改属性域中的车辆就可以了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangSan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> BMW bmw = <span class="keyword">new</span> BMW();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        audi.start();</span><br><span class="line">        audi.turnLeft();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShop</span><span class="params">()</span></span>&#123;</span><br><span class="line">      audi.start();</span><br><span class="line">      audi.turnLeft();</span><br><span class="line">      audi.turnRight();</span><br><span class="line">      audi.turnRight();</span><br><span class="line">      audi.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么接着思考：</p>
<ul>
<li>张三需要的事一辆奥迪车？还是一辆宝马车？还是只是一辆车？<br>张三只需要回家和买东西，只是需要一辆车而已。</li>
<li>张三会制造（创建）车辆吗？<br>不会。车辆不应该由张三进行创建。</li>
</ul>
<p>解决方法：抽象出一个车的接口,并且车辆不由张三创建，而是在构造函数中以参数的形式传入。</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让奥迪和宝马实现接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnLeft&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnRight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnLeft&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnRight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着回到张三这个类，张三只是需要一辆车，车不应该由张三创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangSan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    </span><br><span class="line">    ZhangSan(Car car)&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        audi.start();</span><br><span class="line">        audi.turnLeft();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        audi.start();</span><br><span class="line">        audi.turnLeft();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.turnRight();</span><br><span class="line">        audi.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么接着思考一下：既然车不应该由张三创建，那么应该由谁创建呢？<br>那就是今天的主角：<font color='red'><strong>IOC容器</strong></font></p>
<h1 id="实现一个自己的IOC容器"><a href="#实现一个自己的IOC容器" class="headerlink" title="实现一个自己的IOC容器"></a>实现一个自己的IOC容器</h1><h2 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h2><p>延续上一节中场景的例子，新增一个Human接口，和HumanWithCar类(有车一族类)，张三和李四继承自有车一族类。如下图：</p>
<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile modified=\&quot;2019-06-07T11:55:43.873Z\&quot; host=\&quot;www.draw.io\&quot; agent=\&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36\&quot; etag=\&quot;cMJ_EGGJR-Qaq343x0gh\&quot; version=\&quot;10.7.5\&quot;&gt;&lt;diagram id=\&quot;ivcPhOSlkpp--JMVBmTc\&quot; name=\&quot;第 1 页\&quot;&gt;7VxbT+M4FP41lXYfQI1zaftIWhhWWyQEK7Hsm2lM4sGJu65L2/n1ayfOxUnobZqms4qESn1iO8fnOzf7GHrmOFx/Y3AePFAPkR7oe+ueOekBMLT64lMSNgnBckBC8Bn2EpKRE57xD6SIapy/xB5aaB05pYTjuU6c0ShCM67RIGN0pXd7p0R/6xz6qEJ4nkFSpb5gjwdqWWCQ0+8R9oP0zYYzSp6EMO2sVrIIoEdXBZJ52zPHjFKefAvXY0Sk7FK5JOPuvniaMcZQxPcZcPvmP7l/vjgr6oR3V+D1Y/V9cqXA+IRkqRbcAw4R87lzyTLfKDk4/y4ln24ImY+jnnkjnvbna/EpiPFqJf2K03nyzCo842jNryDBvho3Ewwjls8pvvnqd/xmXCDAUEzokmrrDznHO5yhjKwP0WYUQsHlt7yxCiUljCErjHwr9xO0eZnWnrQq7FUX1ugiCHrnhVV8xeZiDqOc5sZvgoz/9nsy9pMKNc1Z03tvWdeZ1hADs2TRVHSsY/kSeHuSXugSmVsIPT+GL6BxBD4R41g45pvENiax9bjKUiYJJy4Vvd5J7GbfsXB/pvtOI67CigFU+w6GmMiAdI/IJ5KzigcBD4nslL276FqVt5U8oHWBpFztN0RDxNlGdEmf9pXbV3HPUc1VHkSMgaIFhQCShQuoApefTZ37dvFFufcDXL0BKiJFnoh1qkkZD6hPI0huc6rL6DLykJxWAp/3mVIp/VhY3xHnGyVhuORUF6WQINv8Lcdf22nztfhsslaTJ61N1vJuZPgWzTdCZx8J6S7GdNLfhtGCLtkMbRGEqdIIocKI746NUkhbEWeIQI4/9YTh5PCZlUh9s/RwBdLFCocERijVfPXEKJiKiiimW29RswATbwo3dCmFI7z07CNtuQFl+IeYFqbwxk5cgQ8crcezHKnAYmgh+jymYBkl0gNcax2ncMEVYUYJgfMFfsuWkbgel3JOw126cIi9auZqmjX2atfY69BpCG+rLjPrAdNIFlz4WtIAmUDEyDD6gcaUUAH1JKKJSgj7KZFKDrReJ0Q8nuHIn8Z9JlZOeVKSsHTfG2DPQ1HsPzjkMAFPcjunOOKxqGxX/AiBjqVjsAXjY9E28rb4kd0ZH9NIrAXiGFokNGOFFrwW9K12s1sTFPTA2Q950BTydg3yJYwJjrFLME73JcZRAIcCqtjVK0T/ih37lVFB3ayibtYgTOAbIo90gTmmcn6W9C0h3xa4NtjTrBvC1umsuh3g6/Kvs1q1YbWTfmVplNIMPYtCa8wL2ZlovRae5LmZbKSp2fGZ1/DUGZUa+ij1rxDLh7YezPu2PkWS+qlRxSOT0kRgUMoKQGmiZMWViYTI4abQTdnHlwxX3qMYzvUtmTHXvkxYxyvksOKK3IeXLp88VT45Kulg6wnlqAs9Jwk9w71V4VISynRv02WUDaDbdkZpGDXgdnZ9BuTbTynrdopt1yNar97cL8O4eNDVb5qt3/j0XujxL1TA8elzUF+J+B/VHWyg552DPesOo6bKDmnee+Z97xH72p0lh2NrGcdvmA0VOnbWKtJQ0PTW2imdk2e6tGNrfapNq1E9QIv9/QvmQVy277avp3Ejpo5zVpYs+hGnxo8YRlOOxBhUoL+S8VWgHjv0Ovi7FLfeen5q71oHe3M5bvWYqtu7ngzeus1rHbyNbV7rDqW+TC7zneyX6Vy32W1KVep2u3WqYjfl/0H1FOufAEa+qTZ8XeQ/SeS3LD3yW32zCvxZD65Bd8J1GqPPLOjXObpOo30X/puAt+2za1C91NZZ9nmgb/3wGlQvuE2x1cXyU8Zyx9QPAy8glteWLDqLP9zirb2V4WJied3lty6Wnwje1mN59Xius+zzQN9+LB9WQD3v3cYv6jVZEciyzV6hDHTdj0tyW0pBovGIGBbikUnFT1Zx0uys6eKMDQbXpVtnI+N6vyuLOys92QW2HZWeQ+8+2v2h/h5ncBhfev9m7kqCUcsKfgGXd1O/dO4SYwrwwbd3BwY42hwO1eJBG1ppGq1oZap1mke1t/vTtHKelcoLo/b7K0A6j+OzbgEeXATxWrbenthdZlcadjF/Eiia+T8GSNQl/+8K5u1/&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>

<p>在使用IOC管理这个场景之前，进行一些约定,以便简化IOC的业务逻辑：</p>
<ul>
<li>所有的Bean的声明周期交给IOC容器管理</li>
<li>所有被依赖的Bean通过构造方法进行注入。(其实除了构造方法注入，还有setter方法注入)</li>
<li>被依赖的Bean需要优先创建。（比如要创建张三，那么张三依赖的奥迪需要先创建了并且交由IOC容器管理了）</li>
</ul>
<p>这是新的场景模拟的代码：<br>Car接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy.car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>奥迪实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy.car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnLeft&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnRight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宝马实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy.car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnLeft&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.turnRight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Audi.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Human接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy.Human;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HumanWithCar类，它要实现接口中的goHome方法和goShop方法，但是有车一族是一个笼统的概念，张三和李四都是有车一族，他们回家和购物的路线和方式肯定不是一样的，要执行的方法的具体内容不一样。所以,这两个方法应该被声明为虚方法，HumanWithCar类也应是抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy.Human;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.iocstudy.car.Car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanWithCar</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Car car;</span><br><span class="line"></span><br><span class="line">    HumanWithCar(Car car)&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">goShop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>张三和李四:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy.Human;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.iocstudy.car.Car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangSan</span> <span class="keyword">extends</span> <span class="title">HumanWithCar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZhangSan</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        car.start();</span><br><span class="line">        car.turnLeft();</span><br><span class="line">        car.turnRight();</span><br><span class="line">        car.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        car.start();</span><br><span class="line">        car.turnRight();</span><br><span class="line">        car.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy.Human;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.iocstudy.car.Car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiSi</span> <span class="keyword">extends</span> <span class="title">HumanWithCar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiSi</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        car.start();</span><br><span class="line">        car.turnLeft();</span><br><span class="line">        car.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        car.start();</span><br><span class="line">        car.turnRight();</span><br><span class="line">        car.turnLeft();</span><br><span class="line">        car.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后要书写IoC容器，按照约定，</p>
<ul>
<li>所有的Bean的声明周期交给IOC容器管理</li>
<li>所有被依赖的Bean通过构造方法进行注入。</li>
<li>被依赖的Bean需要优先创建。</li>
</ul>
<p>所以，</p>
<ul>
<li>容器要能实例化bean</li>
<li>实例化后要保存bean</li>
<li>要能够提供bean</li>
<li>每个bean要产生一个id与之相对应</li>
</ul>
<p>那么，</p>
<ul>
<li>保存bean：要有私有域来存储IoC创建好的bean(使用Map存储)</li>
<li>提供bean:提供一个getBean()方法</li>
<li>实例化bean：提供一个setBean()方法，向Map中增加bean</li>
</ul>
<p>创建容器类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beans = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据beanId获取一个bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanId beanId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.get(beanId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 委托ioc容器创建一个bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 要创建的bean的class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanId beanId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramBeanIds 要创建的bean的class的构造方法所需要的参数的beanId(即要创建的bean所需要的依赖bean)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeans</span><span class="params">(Class&lt;?&gt; clazz,String beanId,String... paramBeanIds)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是实现setBeans方法：</p>
<ul>
<li>因为是根据构造方法创建一个bean,构造方法是需要参数值的，所以要组装构造方法所需要的参数值</li>
<li>调用构造方法，实例化bean</li>
<li>将实例化的bean放到Map中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeans</span><span class="params">(Class&lt;?&gt; clazz,String beanId,String... paramBeanIds)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 1 组装构造方法所需要的参数值</span></span><br><span class="line">       Object[] paramValues = <span class="keyword">new</span> Object[paramBeanIds.length];</span><br><span class="line">          <span class="comment">//因为约定中所有的被依赖的bean需要被优先创建,所以需要的bean从beans中取就可以了</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramBeanIds.length; i++) &#123;</span><br><span class="line">           paramValues[i] = beans.get(paramBeanIds[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2 调用构造方法，实例化bean</span></span><br><span class="line">       Object bean = <span class="keyword">null</span>; <span class="comment">//先定义好最重要实例化的bean</span></span><br><span class="line">           <span class="comment">//循环使用要创建的bean的构造方法</span></span><br><span class="line">       <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : clazz.getConstructors()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               bean = constructor.newInstance(paramValues);</span><br><span class="line">               <span class="comment">//这里不处理异常。如果最终所有的构造方法都不能完成实例化，则bean为null</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果最终没有实例化，则抛出错误</span></span><br><span class="line">       <span class="keyword">if</span>(bean == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;找不到合适的构造方法实例化bean&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3 将实例化的bean放到Map中</span></span><br><span class="line">       beans.put(beanId,bean);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>使用单元测试类进行测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iocstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.iocstudy.Human.Human;</span><br><span class="line"><span class="keyword">import</span> com.iocstudy.Human.LiSi;</span><br><span class="line"><span class="keyword">import</span> com.iocstudy.Human.ZhangSan;</span><br><span class="line"><span class="keyword">import</span> com.iocstudy.car.Audi;</span><br><span class="line"><span class="keyword">import</span> com.iocstudy.car.BMW;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">springIocTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IoCContainer ioCContainer = <span class="keyword">new</span> IoCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="comment">//向容器中注册bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ioCContainer.setBeans(Audi.class,<span class="string">&quot;audi&quot;</span>);</span><br><span class="line">        ioCContainer.setBeans(BMW.class,<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">        ioCContainer.setBeans(ZhangSan.class,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;audi&quot;</span>);</span><br><span class="line">        ioCContainer.setBeans(LiSi.class,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        Human zhangsan  = (Human) ioCContainer.getBean(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        zhangsan.goHome();</span><br><span class="line">        Human lisi  = (Human) ioCContainer.getBean(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        lisi.goHome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Audi.start</span><br><span class="line">Audi.turnLeft</span><br><span class="line">Audi.turnRight</span><br><span class="line">Audi.stop</span><br><span class="line">Audi.start</span><br><span class="line">Audi.turnLeft</span><br><span class="line">Audi.stop</span><br></pre></td></tr></table></figure>

<p>这样就实现了一个最简单的IoC容器。</p>
<p>这样做的好处:</p>
<ul>
<li>所有的依赖关系被集中统一的管理起来，清晰明了。在Before中将所有的依赖关系先集中管理起来。</li>
<li>每个类只需要关注于自己的业务逻辑。例如在张三的代码中，张三只需要关注goHome()的方法，而不需要关心他的车是什么，只需要IoC容器提供一辆就可以了。</li>
<li>修改依赖关系是很简单的事情。例如，张三现在依赖的是奥迪车，那么在setBean中只需修改为BMW，他就依赖于宝马了。</li>
</ul>
<p>那么再回过头来看看IOC和DI的理解：</p>
<blockquote>
<p>在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。<br>所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。<br>这是我对Spring的IoC(控制反转)的理解。DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://www.imooc.com/video/19046">https://www.imooc.com/video/19046</a></p>
</li>
<li><p><a href="https://blog.csdn.net/bestone0213/article/details/47424255">https://blog.csdn.net/bestone0213/article/details/47424255</a></p>
</li>
<li><p><a href="http://sishuok.com/forum/blogPost/list/2427.html">http://sishuok.com/forum/blogPost/list/2427.html</a></p>
</li>
<li><p><a href="https://blog.csdn.net/yqj2065/article/details/80450929">https://blog.csdn.net/yqj2065/article/details/80450929</a></p>
</li>
</ul>
<script type="text/javascript" src="https://www.draw.io/js/viewer.min.js"></script>]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2019/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="有权图"><a href="#有权图" class="headerlink" title="有权图"></a>有权图</h1><p>有权图是指在无权图的基础上，每一条边都有一个数值，代表两个结点之间有一定的数值关系，比如图用来表示路网时，权值可以表示两点之间的距离，到达彼此所需要的时间等。</p>
<p>有权图的邻接矩阵表达见下图:</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/1.png" alt="邻接矩阵"></p>
<p>有权图的邻接表表达见下图:<br>s<br><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/2.png" alt="邻接表"></p>
<p>邻接表每个节点后面存储两个信息:<code>to</code>表示和它相邻的节点的索引，<code>w</code>表示对应的边的权值.所以可以将这两个信息封装为<code>Edge</code>属性，它包含to和w属性。</p>
<p>当然要注意一点，邻接矩阵中依然用了传统的二维数组来存储，为了统一图的接口，也可以将a[i][j]位置存储为<code>Edge</code>格式。</p>
<p>这里就直接先写java代码了</p>
<p>创建<code>WeightedGraph.java</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeightedGraph</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>;  <span class="comment">//获取图的顶点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>;  <span class="comment">//获取图的边数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge&lt;Weight&gt; e)</span></span>; <span class="comment">//在v和w两个顶点间添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span>;<span class="comment">//查看v和w两个顶点间是否有边</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//打印图</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Edge&lt;Weight&gt;&gt; adj(<span class="keyword">int</span> v); <span class="comment">//获取与v顶点连接的所有边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现有权图，先编写一个<code>Edge.java</code>类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a,b; <span class="comment">//边的两个端点</span></span><br><span class="line">    <span class="keyword">private</span> Weight weight; <span class="comment">//边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b , Weight weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a ;</span><br><span class="line">        <span class="keyword">this</span>.b = b ;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Edge&lt;Weight&gt; e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = e.a;</span><br><span class="line">        <span class="keyword">this</span>.b = e.b;</span><br><span class="line">        <span class="keyword">this</span>.weight = e.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">v</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a;&#125; <span class="comment">//返回第一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> b;&#125; <span class="comment">//返回第二个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weight <span class="title">wt</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> weight;&#125; <span class="comment">// 返回权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给定一个顶点，返回另一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x == a || x == b)&#123;</span><br><span class="line">            <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;x is not correct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出边的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + a + <span class="string">&quot;-&quot;</span> + b + <span class="string">&quot;: &quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(weight.compareTo(that.wt()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(weight.compareTo(that.wt()) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>DenseGraph.java</code>的基础上修改，创建<code>DenseGraph.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DenseWeightedGraph</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">WeightedGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> directed; <span class="comment">// 是否为有向图</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[][] g; <span class="comment">//图的具体数据，用二维数组表达</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DenseWeightedGraph</span><span class="params">( <span class="keyword">int</span> n , <span class="keyword">boolean</span> directed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of n should be &gt;= 0.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="number">0</span> ;<span class="comment">//初始化时没有任何边</span></span><br><span class="line">        <span class="keyword">this</span>.directed = directed;</span><br><span class="line">        <span class="comment">// g初始化为n*n的布尔矩阵, 每一个g[i][j]均为null, 表示没有任和边</span></span><br><span class="line">        <span class="comment">// false为boolean型变量的默认值</span></span><br><span class="line">        g = <span class="keyword">new</span> Edge[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ;j ++)</span><br><span class="line">                g[i][j] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(e.v() &gt;= <span class="number">0</span> &amp;&amp; e.v() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;you should type v &gt;= 0 &amp;&amp; v &lt; n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(e.w() &gt;= <span class="number">0</span> &amp;&amp; e.w() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;you should type w &gt;= 0 &amp;&amp; w &lt; n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasEdge(e.v(),e.w()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        g[e.v()][e.w()] = <span class="keyword">new</span> Edge(e);</span><br><span class="line">        <span class="keyword">if</span>(e.v() != e.w() &amp;&amp; !directed)</span><br><span class="line">            g[e.w()][e.v()] = <span class="keyword">new</span> Edge(e.w(),e.v(),e.wt());</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断图中是否有v到w的边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[v][w] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印显示图的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++)</span><br><span class="line">               <span class="keyword">if</span>( g[i][j] != <span class="keyword">null</span>)</span><br><span class="line">                   System.out.println(g[i][j].wt()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;NULL\t&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回图中v顶点的所有邻边</span></span><br><span class="line">    <span class="comment">//由于java使用引用机制，返回一个Vector不会带来额外开销</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Edge&lt;Weight&gt;&gt; adj(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; adjV = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(g[v][i] != <span class="keyword">null</span>)</span><br><span class="line">                adjV.add(g[v][i]);</span><br><span class="line">        <span class="keyword">return</span> adjV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的修改<code>SparseGraph.java</code>后得到<code>SparseWeightedGraph.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseWeightedGraph</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">WeightedGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> directed; <span class="comment">//是否为有向图</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt;[] g; <span class="comment">//图的具体数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SparseWeightedGraph</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">boolean</span> directed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of n should be &gt;= 0.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.directed = directed;</span><br><span class="line">        <span class="comment">//g初始化为n个空的vector,表示每一个g[i]都为空，即没有任何边</span></span><br><span class="line">        g = (Vector&lt;Edge&lt;Weight&gt;&gt;[]) <span class="keyword">new</span> Vector[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            g[i] = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(e.v() &gt;= <span class="number">0</span> &amp;&amp; e.v() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(e.w() &gt;= <span class="number">0</span> &amp;&amp; e.w() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        g[e.v()].add(<span class="keyword">new</span> Edge&lt;&gt;(e));</span><br><span class="line">        <span class="keyword">if</span>(e.v() != e.w() &amp;&amp; !directed) <span class="comment">//如果不是自环边，并且它是无向图，则创建w到v的边</span></span><br><span class="line">            g[e.w()].add(<span class="keyword">new</span> Edge(e.w(),e.v(),e.wt()));</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证图中是否有v到w的边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; g[v].size() ; i++)</span><br><span class="line">            <span class="keyword">if</span>( g[v].elementAt(i).other(v) == w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;vertex %d :\t&quot;</span>,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; g[i].size() ; j++)&#123;</span><br><span class="line">                Edge e = g[i].elementAt(j);</span><br><span class="line">                System.out.print(<span class="string">&quot;( to:&quot;</span> + e.other(i) + <span class="string">&quot;,wt:&quot;</span> + e.wt() + <span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中一个顶点的所有邻边</span></span><br><span class="line">    <span class="comment">// 由于java使用引用机制，返回一个Vector不会带来额外开销,</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Edge&lt;Weight&gt;&gt; adj(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>ReadGraph.java</code>后得到<code>ReadWeightedGraph</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWeightedGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Scanner scanner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWeightedGraph</span><span class="params">(WeightedGraph&lt;Double&gt; graph , String filename)</span></span>&#123;</span><br><span class="line">        readFile(filename);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> V = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(V &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;number of vertices in a Graph must be nonnegative&quot;</span>);</span><br><span class="line">            <span class="keyword">assert</span> V == graph.V();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> E = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(E &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;number of edges in a Graph must be nonnegative&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; E ; i ++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v = scanner.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = scanner.nextInt();</span><br><span class="line">                Double weight = scanner.nextDouble();  <span class="comment">//读取权值</span></span><br><span class="line">                <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; V))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; V))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">                graph.addEdge(<span class="keyword">new</span> Edge&lt;Double&gt;(v,w,weight) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">            String token = scanner.next();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException(<span class="string">&quot;attempts to read an &#x27;int&#x27; value from input stream,but the next token is \&quot;&quot;</span>+token +<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NoSuchElementException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;attemps to read an &#x27;int&#x27; value from input stream, but there are no more tokens available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(filename == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;filename should not be null!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(fis), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                scanner.useLocale(Locale.ENGLISH);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(filename + <span class="string">&quot;doesn&#x27;t exists.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Could not open &quot;</span> + filename,ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试文件<code>testG1.txt</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 16</span><br><span class="line">4 5 .35</span><br><span class="line">4 7 .37</span><br><span class="line">5 7 .28</span><br><span class="line">0 7 .16</span><br><span class="line">1 5 .32</span><br><span class="line">0 4 .38</span><br><span class="line">2 3 .17</span><br><span class="line">1 7 .19</span><br><span class="line">0 2 .26</span><br><span class="line">1 2 .36</span><br><span class="line">1 3 .29</span><br><span class="line">2 7 .34</span><br><span class="line">6 2 .40</span><br><span class="line">3 6 .52</span><br><span class="line">6 0 .58</span><br><span class="line">6 4 .93</span><br></pre></td></tr></table></figure>

<p>在<code>Main.java</code>中进行测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试通过文件读取图的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用两种图的存储方式读取testG1.txt文件</span></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g1 = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(<span class="number">8</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph1 = <span class="keyword">new</span> ReadWeightedGraph(g1, filename);</span><br><span class="line">        System.out.println(<span class="string">&quot;test G1 in Sparse Weighted Graph:&quot;</span>);</span><br><span class="line">        g1.show();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        DenseWeightedGraph&lt;Double&gt; g2 = <span class="keyword">new</span> DenseWeightedGraph&lt;Double&gt;(<span class="number">8</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph2 = <span class="keyword">new</span> ReadWeightedGraph(g2 , filename );</span><br><span class="line">        System.out.println(<span class="string">&quot;test G1 in Dense Graph:&quot;</span>);</span><br><span class="line">        g2.show();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/3.png" alt="测试结果"></p>
<h1 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h1><p>算法（第四版）中的定义：<br>最小生成树。给定一个加权无向图，找到它的一棵最小生成树（Minimum Span Tree）。</p>
<p>如果一个图有v个节点，那么就应该有v-1条边连接这V个节点，这就是这个图的生成树。不仅如此，这v-1条边连接了所有的v个节点，这v-1条边的权值相加也是最小的，如何找到这个生成树，就是最小生成树问题。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/4.png" alt="最小生成树"></p>
<h2 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h2><p>这里在计算最小生成树的过程中会出现各种特殊情况，所以为了行文流畅，进行约定：</p>
<ul>
<li>只考虑连通图</li>
<li>针对带权无向图</li>
<li>所有边的权重都各不相同</li>
</ul>
<p>所以在进行最小生成树相关算法的过程中要找V-1条边，连接V个顶点使得其总权值最小。</p>
<h2 id="切分定理-Cut-Property"><a href="#切分定理-Cut-Property" class="headerlink" title="切分定理 - Cut Property"></a>切分定理 - Cut Property</h2><p>把图中的结点分为两个部分，成为一个<code>切分(Cut)</code>.</p>
<p>如下图就是一个切分:</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/5.png" alt="切分"></p>
<p>如果一个边的两个端点，属于<code>切分(Cut)</code>不同的两边，这个边称为<code>横切边(Crossing Edge)</code>.</p>
<p>如下图的蓝色线条就是横切边:</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/6.png" alt="横切边"></p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/7.png" alt="横切边"></p>
<p><code>切分定理</code>的定义：<br>在一副加权图中，给定<code>任意</code>切分，横切边中权值最小的边必然属于图的最小生成树。</p>
<p>例如上图中的权重为0.4的边肯定是最小生成树的一条边:<br><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/8.png" alt="横切边"></p>
<p>算法(第四版)中的证明:</p>
<blockquote>
<p>今e为权重最小的横切边，T为图的最小生成树。我们采用反证法:假设T不包含e。那么如果将e加入T，得到的图必然含有一条经过e的环，且这个环至少含有另一条横切边——设为f，f的权重必然大于e(因为e的权重是最小的且图中所有边的权重均不同)。那么我们删掉f而保留e就可以得到一棵权重更小的生成树。这和我们的假设T矛盾。</p>
</blockquote>
<blockquote>
<p>在假设所有的边的权重均不相同的前提下，每幅连通图都只有一棵唯一的最小生成树，切分定理也表明了对于每一种切分，权重最小的横切边必然属于最小生成树。</p>
</blockquote>
<blockquote>
<p>切分定理是解决最小生成树问题的所有算法的基础。更确切的说，这些算法都是一种贪心算法的特殊情况:使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。这些算法相互之间的不同之处在于保存切分和判定权重最小的横切边的方式。</p>
</blockquote>
<h2 id="Lazy-Prim算法"><a href="#Lazy-Prim算法" class="headerlink" title="Lazy Prim算法"></a>Lazy Prim算法</h2><p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/9.png" alt="Lazy-Prim"></p>
<p>首先将一个起始节点作为切分的一部分，这里从0节点开始。将0节点作为切分的一部分，剩下的节点作为切分的另一部分。每一次找到横切边中权值最小的边。这里可以使用最小堆，将横切边放入最小堆中，作为最小生成树所包含的边的候选。这些边进入堆后，下一步只需拿出最小堆中的最短边就可以了。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/10.png" alt="第一步的横切边"></p>
<p>这一步找出的是<code>0-7:0.16</code>权值为0.16的边，它一定属于最小生成树。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/11.png" alt="第一步的最小边"></p>
<p>第二步，确定了<code>0-7</code>这条边为最小生成树的一条边，而结点7没有被访问过，此时就可以将结点7加入到红色节点部分，这样就形成了一个新的切分。这个新的切分就和另一部分切分形成了新的横切边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/12.png" alt="第二步的横切边"></p>
<p>然后将这些新的横切边推入最小堆，然后在最小堆中选出权值最小的边<code>1-7:0.19</code>。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/13.png" alt="第二步的最小边"></p>
<p>第三步，确定了<code>1-7</code>为最小生成树的一条边，而节点1没有被访问过，此时将结点1加入到红色结点部分，这样又形成了一个新的切分。也相应的和另一部分切分形成了新的横切边。将这些新的横切边加入到最小堆。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/14.png" alt="第三步的横切边"></p>
<p>接着看在候选的横切边中，最短的边为<code>0-2:0.26</code>的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/15.png" alt="第三步的最小边"></p>
<p>第四步，确定了<code>0-2</code>为最小生成树的一条边，而结点2没有被访问过，所以将结点2加入红色结点部分，这样就又形成一个新的切分。又有新的边成为了横切边。将他们加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/16.png" alt="第四步的横切边"></p>
<p>此时需要注意，将结点2加入到红色部分后，最小堆中蓝色的部分中，边<code>2-7:0.34</code>和边<code>1-2:0.36</code>，实际上已经不是横切边了，所以这两条边不应该成为最小生成树的边的候选了。所以这里体现出<code>Lazy Prim</code>算法的”懒惰”性，当前这两条边虽然不可能成为最小生成树的候选边，但是这里不需要着急将其剔除，先将其保留在最小堆中，当拿出这两条边时，发现这两条边不是横切边时，再将这两条边剔除。</p>
<p>接着在最小堆中寻找最小的边，最短边为<code>2-3:0.17</code>的边.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/17.png" alt="第四步的最小边"></p>
<p>第五步，确定了<code>2-3</code>为最小生成树的一条边，而结点3没有被访问过，所以将结点3加入到红色结点部分，形成新的切分后，将新的横切边加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/18.png" alt="第五步的横切边"></p>
<p>接着最小堆中的最小边应该是<code>5-7:0.28</code>的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/19.png" alt="第五步的最小边"></p>
<p>第六步，确定了<code>5-7</code>为最小生成树的一条边，而结点5没有被访问过，所以将结点5加入到红色部分，形成新的切分并将新的横切边加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/20.png" alt="第六步的横切边"></p>
<p>接着看在最小堆中，最小的边为<code>1-3:0.29</code>的边，当将其拿出后发现，结点1和结点3都是红色的结点，即这条边不是一条横切边（只有横切边中的最小边才是最小生成树的边），所以将其拿出后剔除。接着看在最小堆中的最短边为<code>1-5:0.32</code>的边，拿出后发现结点1和结点5都是红色的结点，所以也要将其剔除。接着看剩下的最小堆中的最短边为<code>2-7:0.34</code>，也不满足横切边的性质，剔除。<br>接着看剩下的最小堆中的最短边为<code>4-5:0.35</code>，满足横切边的性质，所以将这条边作为最小生成树的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/21.png" alt="第六步的最小边"></p>
<p>第七步，确定了<code>5-4</code>为最小生成树的一条边，由于结点4没有被访问过，所以将结点4加入到红色部分，行成新的切分并将新的横切边<code>4-6:0.93</code>加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/22.png" alt="第七步的横切边"></p>
<p>然后在最小堆中找最短的边，为<code>1-2:0.36</code>这条边，但是它不是横切边，将其剔除。接着最小堆中最短的边为<code>4-7:0.37</code>，它不是横切边，将其剔除。继续找最小堆中最短边为<code>0-4:0.38</code>，不是横切边，将其剔除。<br>继续找最小堆中的最短边为<code>2-6:0.40</code>，它是横切边，将其作为最小生成树的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/23.png" alt="第七步的最小边"></p>
<p>由于结点6没有被访问过，将其加入到红色部分。这时所有节点都在红色部分，程序至此就可以结束。</p>
<p>如果以最小堆中的边为空作为判断依据的话，那么依然可以拿出最小堆中的最小边进行判断，此时所有的边都不是横切边，将剩下的边判断完后，程序结束。</p>
<p>此时就用<code>Lazy Prim</code>算法获得了最小生成树。</p>
<h2 id="Lazy-Prim算法代码"><a href="#Lazy-Prim算法代码" class="headerlink" title="Lazy Prim算法代码"></a>Lazy Prim算法代码</h2><p>见附录1</p>
<h2 id="Prim算法的优化"><a href="#Prim算法的优化" class="headerlink" title="Prim算法的优化"></a>Prim算法的优化</h2><p><code>pq.extractMin()</code>操作的时间复杂度为O(logE),因为pq中最多承载E条边。<br><code>visit()</code>操作时，遍历节点的所有临边，合在一起也是O(E)，如果是邻接矩阵就是O(V^2)，在稠密图的邻接矩阵中O(V^2)和O(E)是一个级别的。同时其中有个<code>add()</code>操作，它是O(logE)级别的。</p>
<p>所以，<code>Lazy Prim</code>算法的时间复杂度为O(ElogE).</p>
<p>通过优化，<code>Prim</code>算法的时间复杂度可以改进为O(ElogV).</p>
<p><code>Lazy Prim</code>算法的一个问题就是，所有的边都要进入最小堆，随着切分的进行，很多已经不是横切边的边仍在最小堆中。另一问题是，虽然有很多横切边，但我们只关注最短的那个横切边，尤其是和一个节点相连的很多横切边，其实只需考虑和这个点相连的最短的横切边就可以了。</p>
<p>基于这个思想，需要维护一个数据结构——存储和每个节点相连的那个最短的横切边。在不断增加红色节点改变切分的过程中，只要不断更新和每个节点相连的最短的横切边就可以了。即这个数据结构要满足：①它能取到最小值②能够供我们更新。所以需要使用<code>IndexMinHeap</code>.</p>
<p>第一步:<br>以0作为起点开始，由于最小生成树有V-1个边，而IndexMinHeap有V个空间，所以肯定有一个节点不需要存储任何东西。就将初始结点作为不需要存储东西的节点。此时有了初始节点后，相当于有了切分，这时，这个节点的所有临边都是横切边，这种情况下，就将这些横切边加入到IndexMinHeap中。<br>此时，和2相连的横切边，最小权值是0.26;和4相连的横切边，最小权值是0.38;和6相连的横切边，最小权值是0.58;和7相连的横切边，最小权值是0.16.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/25.png" alt="Prim第一步-1"></p>
<p>这时，从IndexMinHeap中找出权值最小的一条边，根据切分定理，一定是最小生成树的边，即0.16这条边。这时节点7加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/26.png" alt="Prim第一步-2"></p>
<p>第二步，由于结点7加入了红色部分。要考虑更多的横切边，这时遍历结点7的临边。先看<code>1-7</code>，此时IndexMinHeap中没有和1相连的横切边权值最小的边，所以IndexMinHeap中1的值更新为0.19;再看<code>2-7</code>，其值为0.34，而IndexMinHeap中和2相连的横切边权值最小的是<code>0-2:0.26</code>，所以<code>2-7</code>肯定不会是最小生成树中的一条边，可以直接剔除；接着看<code>4-7</code>，这个边的权值为0.37,它小于当前IndexMinHeap中存储的0.38，所以将<code>4-7:0.37</code>更新到最小索引堆中，与此同时，意味着将<code>0-4:0.38</code>这条边丢弃，因为这条边不可能会是最小生成树的边;最后，看<code>5-7</code>，这个边的权值为0.28，当前IndexMinHeap和5相连的边还没有，所以将其放入IndexMinHeap索引为5的位置中。这时候就完成了<code>visit(7)</code>操作。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/27.png" alt="Prim第二步-1"></p>
<p>然后从最小索引堆IndexMinHeap中找出权值最小的边，即和1相连的<code>1-7:0.19</code>这条边，可以确定它属于最小生成树。因此结点1也可以加入红色部分</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/28.png" alt="Prim第二步-2"></p>
<p>第三步，看和结点1相邻的所有边。首先是<code>1-2:0.36</code>，在IndexMinHeap中索引为2的位置其值为0.26，所以<code>1-2</code>不是最小生成树的边；接着看<code>1-5:0.32</code>，但是在IndexMinHeap中和5相连的横切边最小的值为0.28，所以它也不是最小生成树的边;最后看<code>1-3:0.29</code>，由于IndexMinHeap中没有和3相连的横切边，将其放入IndexMinHeap中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/29.png" alt="Prim第三步-1"></p>
<p>然后从最小索引堆中找出权值最小的边，即和2相连的<code>0-2:0.26</code>这条边，可以确定它属于最小生成树。与此同时结点2加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/30.png" alt="Prim第三步-2"></p>
<p>第四步，看和结点2相邻的所有边。这里注意<code>2-7</code>和<code>1-2</code>不是横切边，所以不用再看了；然后看<code>2-3:0.17</code>，此时最小索引堆中索引为3的位置的值为0.29，所以将其更新为0.17,同时0.29这条边可以剔除不在考虑;接着看<code>2-6:0.40</code>，此时最小索引堆中的索引为6的位置的值为0.58，所以将其更新为0.40，同时0.58这条边可以剔除不在考虑了.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/31.png" alt="Prim第四步-1"></p>
<p>然后从最小索引堆中取出权值最小的边，即和3相连的0.17这条边，根据切分定理，其一定属于最小生成树。同时，将接点3加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/32.png" alt="Prim第四步-2"></p>
<p>第五步，看和接点3相邻的所有边。<code>1-3</code>不是横切边，所以不用看；剩下一条<code>3-6:0.52</code>,其值0.52大于最小索引堆索引为6处的0.40，所以这条边剔除不再考虑。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/33.png" alt="Prim第五步-1"></p>
<p>然后从最小索引堆中找出权值最小的边，即和5相连的0.28这条边，它一定是最小生成树的边。同时将结点5加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/34.png" alt="Prim第五步-2"></p>
<p>第六步，看和节点5相邻的所有边。<code>1-5</code>、<code>5-7</code>不是横切边，所以不用再看；<code>4-5:0.35</code>其值小于最小索引堆索引为4处的值0.37，将其更新为0.35，同时将0.37这条边剔除.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/35.png" alt="Prim第六步-1"></p>
<p>然后从最小索引堆中找出最小边，即0.35这条边，它就是最小生成树的边。同时将结点4加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/36.png" alt="Prim第六步-2"></p>
<p>第七步，看和节点4相邻的所有横切边。此时只有<code>4-6:0.93</code>这一条横切边，其值大于此时最小索引堆中索引为6处的值0.40，所以将其剔除。</p>
<p>最后将最小索引堆中的0.40这条边取出，作为最小生成树的边。同时结点6加入红色部分。这时所有节点遍历完毕，并且找到了最小生成树。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/37.png" alt="Prim第七步"></p>
<p>这种方法对于不是横切边的边在判断后会扔掉，所以Prim的时间复杂度改进还是很可观的。</p>
<h2 id="Prim算法代码"><a href="#Prim算法代码" class="headerlink" title="Prim算法代码"></a>Prim算法代码</h2><p>见附录2</p>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><blockquote>
<p>Kruskal算法的主要思想是按照边的权重顺序(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，知道树中含有V-1条边为止。这些边逐渐由一片森林合并为一棵树，也就是图的最小生成树。——算法第四版</p>
</blockquote>
<p>使用Kruskal算法，为了方便地每次都能取出最短的边，首先对图中所有的边按照权值排序。</p>
<p>然后就要取出还没有考虑的边中最短的那条边，看将此边加入到图中是否会生成环（如果生成环那么就不是最小生成树或者说不是树），如果没有生成环那么它就是最小生成树中的边。</p>
<p>第一步：<code>0-7:0.16</code>,将其放入最小生成树中，不会生成环，所以将这条边作为最小生成树中的一条边</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/38.png" alt="Kruskal第一步"></p>
<p>第二步：下一条最小的边为<code>2-3:0.17</code>，将其放入最小生成树中，也不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/39.png" alt="Kruskal第二步"></p>
<p>第三步：下一条最小的边为<code>1-7:0.19</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p>第四步：下一条最小的边为<code>0-2:0.26</code>，这里需要注意，虽然节点0和节点2都是红色，但是将这条边加入最小生成树后并没有形成环，所以它可以作为最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/40.png" alt="Kruskal第四步"></p>
<p>第五步：下一条最小的边为<code>5-7:0.28</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/45.png" alt="Kruskal第五步"></p>
<p>第六步：下一条最小的边为<code>1-3:0.29</code>，将其放入最小生成树中，<font color=red>会生成环</font>，不能作为最小生成树的一条边，所以不再考虑它。</p>
<p>第七步：下一条最小的边为<code>1-5:0.32</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它。</p>
<p>第八步：下一条最小的边为<code>2-7:0.34</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它。</p>
<p>第九步：下一条最小的边为<code>4-5:0.35</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/41.png" alt="Kruskal第九步"></p>
<p>第十步：下一条最小的边为<code>1-2:0.36</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它。</p>
<p>第十一步、第十二步的边<code>4-7:0.37</code>、<code>0-4:0.38</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它们。</p>
<p>第十三步：下一条最小的边为<code>2-6:0.40</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/42.png" alt="Kruskal第十三步"></p>
<p>至此已经有了V-1条边，并且将V个顶点都连接起来了，这时候算法就可以结束了。如果继续扫描的话，剩下的边也都会让最小生成树形成环，也都不会被考虑，直到扫描结束。</p>
<p>整个过程中，关键的操作是判断加入一条边后，是否会行程一个环，这个操作可以使用<a href="https://homxuwang.github.io/2019/01/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>结构进行辅助。</p>
<p>那么如何使用并查集进行辅助呢？<br>在每一次加入一条边作为最小生成树的同时，对一条边的两个端点进行Union操作。比如此时要加入<code>1-3</code>这条边，去找并查集中1的根节点和3的根节点，它们一定属于同一个根，说明最小生成树中已经连接了节点1和节点3了，此时再将<code>1-3</code>连接的话，就必然形成一个环，这时就可以不考虑这条边了。</p>
<h2 id="Kruskal算法代码实现"><a href="#Kruskal算法代码实现" class="headerlink" title="Kruskal算法代码实现"></a>Kruskal算法代码实现</h2><p>见附录3</p>
<blockquote>
<p>Kruskal算法的计算一副含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和E成正比，所需的时间和ElogE成正比(最坏情况)。</p>
</blockquote>
<blockquote>
<p>与Prim算法一样，这个估计是比较保守的，因为算法在找到V-1条边之后就会终止。实际的成本应该与E+E0logE成正比，其中E0是权重小于最小生成树中权重最大的边的所有边的总数。尽管拥有这个优势，Kruskal算法一般还是比Prim算法要慢，因为在处理每条边时除了两种算法都要完成的优先队列操作之外，他还要进行一次connect()操作。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lazy Prim   :    O(ElogE)<br>Prim        :    O(ElogV)  整体而言效率最高<br>Kruskal     :    O(ElogE)</p>
<p>在算法第四版有约定，所有边的权重都各不相同。但是如果有横切边相等的边，那么根据算法的具体实现，每次选择一个边，此时存在多个最小生成树。</p>
<p>另外还有个<code>Vyssotsky&#39;s Algorithm</code>提出的算法，将边逐渐的添加到生成树中，一旦形成环，就删除环中权值最大的边。这个过程完成后可以形成一个最小生成树。</p>
<h1 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h1><p>首先创建最小堆<code>MinHeap.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在堆的有关操作中，需要比较堆中元素的大小，所以Item需要extends Comparable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 通过一个给定数组创建一个最小堆</span></span><br><span class="line">    <span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(Item arr[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最小堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> count + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        count ++;</span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小堆中取出堆顶元素, 即堆中所存储的最小数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( <span class="number">1</span> , count );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Item t = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="comment">//* 最小堆核心辅助函数</span></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>].compareTo(data[k]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            swap(k, k/<span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>].compareTo(data[j]) &lt; <span class="number">0</span> )</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最小值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[k].compareTo(data[j]) &lt;= <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 MinHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MinHeap&lt;Integer&gt; minHeap = <span class="keyword">new</span> MinHeap&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">100</span>; <span class="comment">// 堆中元素个数</span></span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">100</span>; <span class="comment">// 堆中元素取值范围[0, M)</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )</span><br><span class="line">            minHeap.insert( <span class="keyword">new</span> Integer((<span class="keyword">int</span>)(Math.random() * M)) );</span><br><span class="line"></span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[N];</span><br><span class="line">        <span class="comment">// 将minheap中的数据逐渐使用extractMin取出来</span></span><br><span class="line">        <span class="comment">// 取出来的顺序应该是按照从小到大的顺序取出来的</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )&#123;</span><br><span class="line">            arr[i] = minHeap.extractMin();</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保arr数组是从小到大排列的</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; i ++ )</span><br><span class="line">            <span class="keyword">assert</span> arr[i-<span class="number">1</span>] &lt;= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建<code>LazyPrimMST.java</code>类进行算法的编写.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph&lt;Weight&gt; G;    <span class="comment">//图的引用</span></span><br><span class="line">    <span class="keyword">private</span> MinHeap&lt;Edge&lt;Weight&gt;&gt; pq;   <span class="comment">//最小堆，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;         <span class="comment">//标记数组，在算法运行过程中标记节点i是否被访问（即图中的蓝色部分和红色部分）</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst;   <span class="comment">//最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;          <span class="comment">//最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(WeightedGraph&lt;Weight&gt; graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        G = graph;</span><br><span class="line">        pq = <span class="keyword">new</span> MinHeap&lt;Edge&lt;Weight&gt;&gt;(G.E());</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        mst = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lazy Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 使用最小堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            Edge&lt;Weight&gt; e = pq.extractMin();</span><br><span class="line">            <span class="comment">// 如果这条边的两端都已经访问过了, 它不是横切边,扔掉这条边</span></span><br><span class="line">            <span class="keyword">if</span>(marked[e.v()] == marked[e.w()])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//否则，这条边应该存在最小生成树中</span></span><br><span class="line">            mst.add(e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//访问和这条边连接的还没有被访问过的节点(找到蓝色一端的端点)</span></span><br><span class="line">            <span class="keyword">if</span>( !marked[e.v()] )</span><br><span class="line">                visit(e.v());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                visit(e.w());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; mst.size() ; i ++)</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( marked[v] )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;this point has been visited!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将和节点v相连的所有未访问的边放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span>(Edge&lt;Weight&gt; e : G.adj(v))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[e.other(v)]) <span class="comment">//找到与其对应的另一个端点，如果是横切边</span></span><br><span class="line">                pq.insert(e);        <span class="comment">//就加入到堆中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Main.java</code>中进行测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试通过文件读取图的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用两种图的存储方式读取testG1.txt文件</span></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(<span class="number">8</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph1 = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line">         <span class="comment">// Test Lazy Prim MST</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Lazy Prim MST:&quot;</span>);</span><br><span class="line">        LazyPrimMST&lt;Double&gt; lazyPrimMST = <span class="keyword">new</span> LazyPrimMST&lt;Double&gt;(g);</span><br><span class="line">        Vector&lt;Edge&lt;Double&gt;&gt; mst = lazyPrimMST.mstEdges();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; mst.size() ; i ++ )</span><br><span class="line">            System.out.println(mst.elementAt(i));</span><br><span class="line">        System.out.println(<span class="string">&quot;The MST weight is: &quot;</span> + lazyPrimMST.result());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/24.png" alt="测试结果"></p>
<h1 id="附录2"><a href="#附录2" class="headerlink" title="附录2"></a>附录2</h1><p>最小索引堆<code>IndexMinHeap.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小索引堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMinHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;      <span class="comment">// 最小索引堆中的数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] indexes;    <span class="comment">// 最小索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] reverse;    <span class="comment">// 最小索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMinHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最小索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> count + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">        <span class="keyword">assert</span> i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        <span class="keyword">assert</span> !contain(i);</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line">        count ++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素, 即索引堆中所存储的最小数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swapIndexes( <span class="number">1</span> , count );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">extractMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swapIndexes( <span class="number">1</span> , count );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>  i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">contain</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最小索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">contain</span><span class="params">(i)</span></span>;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有了 reverse 之后,</span></span><br><span class="line">        <span class="comment">// 我们可以非常简单的通过reverse直接定位索引i在indexes中的位置</span></span><br><span class="line">        shiftUp( reverse[i] );</span><br><span class="line">        shiftDown( reverse[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换索引堆中的索引i和j</span></span><br><span class="line">    <span class="comment">// 由于有了反向索引reverse数组，</span></span><br><span class="line">    <span class="comment">// indexes数组发生改变以后， 相应的就需要维护reverse数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapIndexes</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = indexes[i];</span><br><span class="line">        indexes[i] = indexes[j];</span><br><span class="line">        indexes[j] = t;</span><br><span class="line"></span><br><span class="line">        reverse[indexes[i]] = i;</span><br><span class="line">        reverse[indexes[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="comment">//* 最小索引堆核心辅助函数</span></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]].compareTo(data[indexes[k]]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            swapIndexes(k, k/<span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]].compareTo(data[indexes[j]]) &lt; <span class="number">0</span> )</span><br><span class="line">                j ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]].compareTo(data[indexes[j]]) &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swapIndexes(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 IndexMinHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">        IndexMinHeap&lt;Integer&gt; indexMinHeap = <span class="keyword">new</span> IndexMinHeap&lt;Integer&gt;(N);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )</span><br><span class="line">            indexMinHeap.insert( i , (<span class="keyword">int</span>)(Math.random()*N) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PrimMST.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph G;          <span class="comment">//图的引用</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinHeap&lt;Weight&gt; ipq; <span class="comment">//最小索引堆</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[] edgeTo;   <span class="comment">//访问的点所对应的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;       <span class="comment">//标记数组,在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst; <span class="comment">//最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;        <span class="comment">//最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(WeightedGraph graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">if</span>(!(graph.E() &gt;= <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Edges of graph should &gt;= 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ipq = <span class="keyword">new</span> IndexMinHeap&lt;&gt;(graph.V());  <span class="comment">//开辟顶点个数的空间就可以</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            marked[i] = <span class="keyword">false</span>;</span><br><span class="line">            edgeTo[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mst = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!ipq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 使用最小索引堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            <span class="comment">// 最小索引堆中存储的是点的索引, 通过点的索引找到相对应的边</span></span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            <span class="keyword">if</span>(edgeTo[v] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Edge should&#x27;t be null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mst.add(edgeTo[v]);</span><br><span class="line">            visit(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; mst.size() ; i ++)&#123;</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问节点v</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( marked[v] )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;this point has been visited!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将和节点v相连接的未访问的另一端点, 和与之相连接的边, 放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span>(Object item :G.adj(v))&#123;</span><br><span class="line">            Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="comment">//如果边的另一端点未被访问</span></span><br><span class="line">            <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">                <span class="comment">//如果从没有考虑过这个端点，直接将这个端点和与之相连接的边加入索引堆，即它是横切边</span></span><br><span class="line">                <span class="keyword">if</span>(edgeTo[w] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.insert(w,e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果曾经考虑这个端点,但现在的边比之前考虑的边更短,则进行替换</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(e.wt().compareTo(edgeTo[w].wt())&lt; <span class="number">0</span> )&#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.change(w,e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 Prim</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(V, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Prim MST</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Prim MST:&quot;</span>);</span><br><span class="line">        PrimMST&lt;Double&gt; primMST = <span class="keyword">new</span> PrimMST&lt;Double&gt;(g);</span><br><span class="line">        Vector&lt;Edge&lt;Double&gt;&gt; mst = primMST.mstEdges();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; mst.size() ; i ++ )</span><br><span class="line">            System.out.println(mst.elementAt(i));</span><br><span class="line">        System.out.println(<span class="string">&quot;The MST weight is: &quot;</span> + primMST.result());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/44.png" alt="测试结果"></p>
<h1 id="附录3"><a href="#附录3" class="headerlink" title="附录3"></a>附录3</h1><p><code>UnionFind.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Union-Find</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">    <span class="comment">// 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span></span><br><span class="line">    <span class="comment">// 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;    <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path compression 1</span></span><br><span class="line">        <span class="keyword">while</span>( p != parent[p] )&#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">        <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">        <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MinHeap.java</code>:<br>见附录1</p>
<p><code>KruskalMST.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst;    <span class="comment">//最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;           <span class="comment">//最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，使用Kruskal算法计算graph的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(WeightedGraph graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        mst  = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有的边进行排序，使用堆排序，将所有的边放入一个最小堆中</span></span><br><span class="line">        MinHeap&lt;Edge&lt;Weight&gt;&gt; pq = <span class="keyword">new</span> MinHeap&lt;Edge&lt;Weight&gt;&gt;(graph.E());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; graph.V(); i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Object item : graph.adj(i))&#123;</span><br><span class="line">                Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">                <span class="keyword">if</span>( e.v() &lt;= e.w() )  <span class="comment">//防止存入两次同一条边(比如边1-2和边2-1，只存入边1-2)</span></span><br><span class="line">                    pq.insert(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个并查集，查看已经访问的节点的联通情况</span></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(graph.V());</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; graph.V() - <span class="number">1</span>)&#123;<span class="comment">//pq不为空且最小生成树的边数小于V-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//从最小堆中依次从小到大取出所有的边</span></span><br><span class="line">            Edge&lt;Weight&gt; e = pq.extractMin();</span><br><span class="line">            <span class="comment">//如果该边的两个端点是联通的，说明加入这条边将产生环，扔掉这条边</span></span><br><span class="line">            <span class="keyword">if</span>(uf.isConnected(e.v(),e.w()))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//否则，将这条边加入最小生成树，同时标记边的两个端点联通</span></span><br><span class="line">            mst.add(e);</span><br><span class="line">            uf.unionElements(e.v(),e.w());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; mst.size() ; i ++)&#123;</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 Kruskal</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(V, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Kruskal</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Kruskal:&quot;</span>);</span><br><span class="line">        KruskalMST&lt;Double&gt; kruskalMST = <span class="keyword">new</span> KruskalMST&lt;Double&gt;(g);</span><br><span class="line">        Vector&lt;Edge&lt;Double&gt;&gt; mst = kruskalMST.mstEdges();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; mst.size() ; i ++ )</span><br><span class="line">            System.out.println(mst.elementAt(i));</span><br><span class="line">        System.out.println(<span class="string">&quot;The MST weight is: &quot;</span> + kruskalMST.result());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果:<br><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/43.png" alt="测试结果"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2019/03/07/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h1><p>红黑树是一棵二分搜索树。</p>
<p>红黑树的五个性质：</p>
<p>1、每个结点或者是红的，或者是黑的。</p>
<p>2、根结点是黑的。</p>
<p>3、每一个叶结点（nil结点,即最后的空结点）是黑的。</p>
<p>4、如果一个结点是红的，则其孩子结点都是黑的。</p>
<p>5、对于任意结点，从该结点到其子孙叶结点（nil结点）的所有路径上包含相同数目的黑结点。</p>
<p>红黑树是保持“黑平衡”的二叉树。严格意义上并不是平衡二叉树。因为有红色结点，所以红黑树的最大高度为O(logn)。</p>
<p>与AVL树相比，如果添加和删除操作比较频繁，那么用红黑树将有很大的优势。但是如果使用的数据近乎是不会改变，只涉及到查询操作，那么AVL树比红黑树有优势（虽然它们的查询复杂度都是O(logn)）。</p>
<h1 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h1><p>2-3树满足二分搜索树的基本性质。</p>
<p>结点可以存放一个元素或者两个元素。</p>
<p>在《算法4》中，2-3树的定义如下：</p>
<blockquote>
<p>一棵2-3查找树或为一棵空树，或由以下结点组成：<br>2-结点，含有一个建（与其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。<br>3-结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
</blockquote>
<p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91/1.png" alt="2-3树"></p>
<p>2-3树是一棵绝对平衡的树。</p>
<blockquote>
<p>一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。</p>
</blockquote>
<h2 id="2-3树的绝对平衡性"><a href="#2-3树的绝对平衡性" class="headerlink" title="2-3树的绝对平衡性"></a>2-3树的绝对平衡性</h2><h3 id="插入新键"><a href="#插入新键" class="headerlink" title="插入新键"></a>插入新键</h3><blockquote>
<p>要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树就无法保持完美平衡性。我们使用2-3树的蛀牙原因就在于它能够在插入后继续保持平衡。如果未命中的查找结束于一个2-结点，事情就好办了：我们只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。</p>
</blockquote>
<p>在2-3树中，添加一个结点将永远不会添加到一个空的位置。如图，如果将37插入到以42为根的2-3树中，插入37时，因为42的左孩子为空，新结点将融合到之前添加过程中最后的一个叶子结点上，即42，所以产生了结点融合.42由2-结点变成了3-结点。而若如果继续添加一个12结点，那么由于12小于37，它要添加到3-树的左子树，又因为2-3树的性质，不能添加到空的位置，那么先将12与3-树进行融合，产生一个4-树，接着进行分裂操作。这时候一个4-结点就转变成了一个由3个2-结点组成的平衡的树，同时这棵树保持着绝对平衡。此时，如果继续添加一个18结点，那么18要添加到12的右子树，12的右子树为空，不能添加到空结点，而是与它找到的最后一个叶子结点，即12结点进行融合，从而成为一个3-结点。接着插入6结点，6从根结点出发，比37小，要插入到37的左子树上，而其左子树是<code>12 18</code>的3-结点，它比12要小，所以要插入到其左子树，但它的左子树是一棵空树，添加结点不能添加到一个空的位置，而是找到它最后添加位置的叶子结点，与叶子结点进行融合，此时的叶子结点是一个3-结点，暂时与其融合成为4-结点，然后进行分裂拆解，但是此时如果拆解，那么树将不是一个绝对平衡的二叉树，而是应该将此时拆解后的新的根结点12与其父结点37进行融合，37是一个2-结点，进行融合就很容易了，37融合成3-结点，进而12结点对应的左右孩子变为新的根结点的左孩子和中孩子。继续添加11结点，11应插入到根结点的总左子树，11比6大，本应插入到6的右子树，但是6的右子树为空，所以11和6融合。再插入5,5应插入到<code>12 37</code>的左子树<code>6 11</code>的左结点，其左结点为空，此时应与其融合，首先融合成4-结点，再分裂为3个2-结点，6接着应与父结点融合，形成一个4-结点，4-结点应该进行分裂，分裂成3个2-结点。至此所有结点都是2-结点，仍是平衡的。</p>
<p>其实总结来说添加元素，添加的结点不会添加到空的位置，它会添加到最后搜索到的叶子结点，与其融合。如果其本身是2-结点，那么融合为3-结点，如果本身是3-结点，先融合为4-结点后，在分裂为3个2-结点。</p>
<p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91/2.png" alt="2-3树的插入操作"></p>
<h1 id="2-3树和红黑树的等价性"><a href="#2-3树和红黑树的等价性" class="headerlink" title="2-3树和红黑树的等价性"></a>2-3树和红黑树的等价性</h1><p>在使用2-3树进行表达和实现时，有的结点包含2个子结点，有的结点包含3个子结点。使用红黑树，均使用含有两个子结点的结点进行表达。</p>
<p>以下是《算法4》中关于替换3-结点的描述：</p>
<blockquote>
<p>红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。我们将树中的链接分为两种类型：红连接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接。确切地说，我们将3-结点表示为由一条左斜的红色链接（两个2-结点其中之一是另一个的左子结点）相连的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。我们将这种表示2-3树的二叉查找树称为红黑二叉树（以下简称为红黑树）。</p>
</blockquote>
<blockquote>
<p>红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：<br>1.红链接均为左链接<br>2.没有任何一个结点同时和两条红链接相连<br>3.该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同<br>满足这样定义的红黑树和相应的2-3树是一一对应的</p>
</blockquote>
<p>即红结点和它的父结点一起表示原来2-3树中的3-结点。所有的红色结点都是向左倾斜的。</p>
<p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91/3.png" alt="2-3树和红黑树"></p>
<p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91/4.png" alt="2-3树和红黑树的转换"></p>
<p>在原来的2-3树中有3个3-结点，所以在红黑树中有3个红结点。</p>
<h1 id="颜色表示"><a href="#颜色表示" class="headerlink" title="颜色表示"></a>颜色表示</h1><p>直接上代码吧:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;<span class="comment">//由其父结点指向它的链接的颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            color = RED; <span class="comment">//初始化为红结点，相当于刚创建时就与其父结点进行融合，融合后的操作是后续的事。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根节点的二分搜索树中，key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;<span class="keyword">return</span> getNode(root,key) != <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        Node node = getNode(root,key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在红黑树中添加新元素"><a href="#在红黑树中添加新元素" class="headerlink" title="在红黑树中添加新元素"></a>在红黑树中添加新元素</h1><p>在2-3树中添加一个新结点时，它都是或者添加进2-结点，行程一个3-结点；或者是添加进3-结点，暂时形成一个4-结点，然后在进行后续的操作。总之就是把要添加的元素融合到已有的结点中。所以在红黑树中假设永远添加红色结点的意图也就是，添加的结点和其他结点先融合。</p>
<p>在上面的代码中可以看到，我们将新添加的结点定义为红结点。所以在添加时有几种情况。</p>
<p>1.最初情况是刚开始的树为空，然后让红黑树的根为新添加的元素，然后让根结点的红色变为黑色。</p>
<p>2.要添加的结点小于根结点，即添加到根结点的左孩子位置，则直接添加过去就可以了。</p>
<p>3.要添加的结点大于根结点，则先添加到根结点的右孩子位置，然后进行左旋转。左旋转方法和AVL树的左旋转类似。在左旋转后，有可能会产生两个红色结点(<code>x.color = node.color;node.color = RED;</code>)，这时候不用担心，因为返回的根结点如果为红色，它将会继续和上一层进行相关转换操作。</p>
<p>4.向红黑树中的3-结点添加元素时：<br>①：向3-结点的右孩子添加时，直接添加到右孩子，然后所有子结点变为黑结点，也就是相当于在2-3树中先将3-结点变为4-结点，然后再分离为3个2-结点，然后再和其上面的父结点进行融合，所以这里要将其根结点变为红色（这样才能保证在红黑树中这个结点和其父结点进行融合）<br>②：向3-结点添加元素时，新元素小于根结点的左孩子（即新键小于原树中的两个键），需要继续添加到根结点的左孩子的左孩子（即连接到最左边的空链接），它应该是一个红色结点，这样就产生了两个连续的红链接。此时需要将上层的红链接右旋转（中值键作为根结点并和其他两个结点用红链接相连）<br>③：如果新键的值介于原树中的两个树之间，这样又会产生两个连续的红链接，一条红色左链接一条红色右链接。这时候需要将下层的红链接左旋转得到第②种情况，然后在②情况的基础上继续操作。</p>
<p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91/5.png" alt="添加新元素"></p>
<p>维护红黑树的时机和AVL树一样，在基于二分搜索树的基础上，添加了新结点后回溯向上维护。</p>
<p>相关代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断节点node的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node ==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node x = node.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转操作</span></span><br><span class="line">    node.right = x.left;</span><br><span class="line">    x.left = node;</span><br><span class="line"></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node x = node.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋转</span></span><br><span class="line">    node.left = x.right;</span><br><span class="line">    x.right = node;</span><br><span class="line"></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//颜色翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    node.color = RED;</span><br><span class="line">    node.left.color = BLACK;</span><br><span class="line">    node.right.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向红黑树中添加新元素(key,value)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">    root = add(root,key,value);</span><br><span class="line">    root.color = BLACK;<span class="comment">//保证最后的根节点为黑色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向以node为根的红黑树中插入元素(key,value),递归算法</span></span><br><span class="line"><span class="comment">//返回插入新节点后红黑树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node,K key,V value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value); <span class="comment">//默认插入红色结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">        node.left = add(node.left,key,value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">        node.right = add(node.right,key,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        node.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入结点结束后，进行红黑树性质的维护</span></span><br><span class="line">    <span class="comment">//如果右孩子是红色，左孩子不是红色，则进行左旋转</span></span><br><span class="line">    <span class="keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">        node = leftRotate(node);</span><br><span class="line">    <span class="comment">//如果左孩子是红色，左孩子的左孩子也是红色，则进行右旋转</span></span><br><span class="line">    <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">        node = rightRotate(node);</span><br><span class="line">    <span class="comment">//如果node的左孩子和右孩子都是红结点，则进行颜色反转</span></span><br><span class="line">    <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">        flipColors(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与其他树的比较"><a href="#与其他树的比较" class="headerlink" title="与其他树的比较"></a>与其他树的比较</h1><p>如果对于完全随机的数据，普通的二分搜索树BST就已经很好用了。<br>缺点：极端情况下退化成链表（高度不平衡）</p>
<p>对于查询较多的情况，AVL树的性能很好。<br>红黑树牺牲了平衡性（2logn的高度）</p>
<p>红黑树的统计性能更优（综合增删改查所有的操作）</p>
<h1 id="红黑树中删除节点"><a href="#红黑树中删除节点" class="headerlink" title="红黑树中删除节点"></a>红黑树中删除节点</h1><p>删除节点的操作较为复杂，以后有缘在整理 0.0</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈TCP协议</title>
    <url>/2019/05/06/%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>TCP协议比较复杂，这里主要记录学习TCP过程中的一些要点。</p>
<p>目前有四层、五层、七层协议。</p>
<h1 id="OSI开放式互联参考模型-概念化七层协议"><a href="#OSI开放式互联参考模型-概念化七层协议" class="headerlink" title="OSI开放式互联参考模型(概念化七层协议)"></a>OSI开放式互联参考模型(概念化七层协议)</h1><p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/18.png" alt="OSI七层模型"></p>
<ul>
<li>第一层(物理层)<br>要解决两台物理机之间的通讯需求,机器A向机器B发送比特流,机器B能收到比特流。这是物理层要解决的问题。<br>物理层定义了物理设备的标准,比如网线的类型、光纤接口类型、各种传输介质的传输速率。它的主要作用是传输比特流(0101)数据,将其转化为电流强弱进行传输,到达目的地后再转化为0101的机器码,也就是数模转换和模数转化,这一层的数据是比特。网卡工作在这一层。</li>
<li>第二层(数据链路层)<br>物理寻址，同时将原始比特流转为逻辑传输线路。<br>在传输比特流的过程中，可能会产生错传和数据不完整的情况。这一层定义了如何格式化数据以进行传输,以及控制对物理介质的访问。这一层还提供错误检测和纠正，以确保数据传输的可靠性。该层将比特数据组成了帧,其中交换机工作在该层,对帧解码，并根据帧中包含的信息发送到接收方。</li>
<li>第三层(网络层)<br>随着网络节点的增加，点对点的通讯是要经过多个节点的,如何找到目标节点、选择最佳路径成为首要需求，此时便有了网络层。<br>网络层的主要功能是将网络地址翻译为对应的物理地址,并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先权、网络拥塞程度、服务质量、可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。由于网络层处理并智能指导数据传送,路由器连接网络各个节点,所以路由器属于网络层。此层的数据被称为数据包,此层需要关注的协议是TCP/IP协议中的IP协议。</li>
<li>第四层(传输层)<br>随着网络通讯需求的进一步扩大，通讯过程中需要发送大量数据,如海量文件传输等,可能需要很长的时间,而网络在通讯过程中会中断好多次,此时为了保证传输大量文件的准确性,需要对数据进行切分,切割为一个个的段落,如果其中一个段落丢失了需不需要重新传输,每个段落是否要按照顺序到达,这便是传输层要考虑的问题。<br>传输层解决了主机间的数据传输(可以是不同网络),同时解决了传输质量的问题。该层是OSI模型中最重要的一层:传输协议同时进行流量控制,或是基于接收方可接受数据的快慢程度规定适当的发送速率。除此之外,传输层按照网络处理的最大尺寸,将较长的数据包进行强制分割,将文件处理为数据片并为每一个数据片安排一个序列号,以便数据片到达接收方时能够正确重组。该过程即称为排序。<br>传输层中需要关注的协议有TCP/IP协议中的TCP协议和UDP协议。</li>
<li>第五层(会话层)<br>第四层保证了给正确的计算机发送正确的封装过后的信息了,但是用户的体验好不好(难道每次都要调用TCP去打包,然后调用IP协议去找路由),当然不可以。我们要建立一个自动收发包，自动寻址的功能，于是发明了会话层。<br>会话层的作用就是管理和应用程序之间的通讯。</li>
<li>第六层(表示层)<br>在第五层的基础上，可以保证应用程序自动收发包和寻址了。但是如果是两个不同的系统之间通讯，往往有阻碍。就像shell不能在windows下直接执行一样。于是需要表示层帮用户解决不同系统之间的通讯语法的问题。</li>
<li>第七层(应用层)<br>在表示层，数据将按照网络能理解的方案进行格式化。这种格式化也因所使用的网络类型的不同而不同，此时发送方虽然知道自己发送的是什么，转化为字节数组后有多长，但接收方不知道。所以应用层的网络协议诞生了。<br>它规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头必须记录消息体的长度等信息，以方便接收方正确解析发送方发送的数据。<br>应用层旨在让用户更方便的应用从网络中接收到的数据，至于数据传递，没有该层用户也可以在两台电脑间传递信息。只不过穿来穿去都是01组成的字节数组。<br>该层需要重点关注的是TCP/IP协议中的HTTP协议。</li>
</ul>
<p>以上就是OSI各层次的划分。<br>先自上而下从应用层开始都要对传输的数据头部进行处理，加上本层的一些信息。最后由物理层通过电缆、以太网等介质将数据解析为比特流在网络中进行传输。数据传递到目标地址，再自底而上的将先前对应层的头部进行解析分离。这就是网络处理的整个流程。(先自上而下，后自下而上处理数据头部)</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/1.png" alt="七层模型对应通信示意图"></p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/2.png"><br>图片<a href="https://www.cnblogs.com/qishui/p/5428938.html">引自</a></p>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>OSI并不是一个标准，只是一个在指定标准时使用的概念框架。<br>其标准是TCP/IP，即TCP/IP是OSI的实现。</p>
<p>虽然TCP/IP并不完全符合OSI的七层参考模型。但是它依然是OSI的一种实现。</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/3.png" alt="OSI与TCP/IP"><br><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/4.png" alt="OSI与TCP/IP"><br><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/5.png" alt="OSI与TCP/IP"><br>图片<a href="https://www.cnblogs.com/qishui/p/5428938.html">引自</a></p>
<p>TCP/IP很多情况下是用IP进行通信时所必须用到的协议群的统称。TCP/IP在分层模块上与OSI略有缺别，可参照上图。</p>
<p>OSI注重通讯协议必要的功能是什么，而TCP/IP则更强调实现协议要开发哪种程序。</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/6.png" alt="TCP/IP的处理流程"></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-Transmission-Control-Protocol-简介"><a href="#TCP-Transmission-Control-Protocol-简介" class="headerlink" title="TCP(Transmission Control Protocol)简介"></a>TCP(Transmission Control Protocol)简介</h2><p>TCP是属于传输层的协议，是传输控制协议。</p>
<ul>
<li>是一种<strong>面向连接的</strong>，<strong>可靠的</strong>，<strong>基于字节流的</strong>传输层通信协议</li>
<li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li>
<li>TCP为了不丢失包,每个数据包都有序号,对方收到则发送ACK确认,未收到则重新传送</li>
<li>使用校验和函数来检验数据再传输过程中是否有误，发送和接收时都要计算校验和。即使用校验和,确认和重传机制来保证可靠传输</li>
<li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li>
<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>
<h2 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h2><p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/8.jpg" alt="TCP报文头"></p>
<p>TCP连接中传送的字节流中的每个字节都按顺序编号。例如一短报文的序列号字段值是107,而携带的字段为100个字段。如果有下一个报文段，则从207开始。</p>
<p><code>Source Port</code> 代表源端口 占2字节</p>
<p><code>Destination Port</code> 代表目的端口 占2字节</p>
<p><code>Sequence Number</code> 包的序号Seq，用于解决网络包乱序（reordering） 占4个字节</p>
<p><code>Acknowledgment Number</code> 确认字符 占4个字节 代表期望收到对方下一段报文的下一个字节的序号 用于确认收到，用来解决不丢包的问题(本文图片中的ACKnum 有的则写成小写ack)</p>
<p>例如B收到了A发来的报文，其序列号字段是301,而数据长度为200字节。这表明B收到了到序号到500(301+200-1)为止的数据。因此B期望收到A的下一个数据序号是501.所以B发送给A的确认报文段中把ACK置为501.</p>
<p><code>Offset</code> 数据偏移<br>由于头部有可选字段，长度不固定，因此它指出TCP报文的数据距离TCP报文的起始处有多远</p>
<p><code>Reserved</code> 保留域</p>
<p><code>TCP Flags</code> 控制位 由八个标志位组成 每一个位置表示一个控制功能<br>TCP Flags中常见的6个:</p>
<ul>
<li>URG: 紧急指针标志。为1时紧急指针有效，为0则忽略紧急指针</li>
<li><font color="red">ACK(Acknowledgement)</font>: 确认序号标志。为1时表示确认号有效，为0表示报文中不含确认信息。上面的确认号是否有效就是由该控制位控制的。</li>
<li>PSH: push标志。为1时表示是带有PUSH标志的数据，指示接收方接收到后尽快将报文段交给应用程序，而不是在缓冲区排队。</li>
<li>RST: 重置连接标志。用于重置由于主机崩溃或其他原因而出现错误的连接，或者用于拒绝非法的报文段或拒绝连接请求。</li>
<li><font color="red">SYN(Synchronize Sequence Numbers)</font>: 同步序号,用于建立连接过程。在连接请求中,SYN=1和ACK=0表示该数据段没有使用捎带的确认域,而连接应答捎带一个确认即SYN=1和ACK=1.</li>
<li><font color="red">FIN(finish)</font>: finish标志，用于释放连接。为1时表示发送方已经没有数据发送了，即关闭本方数据流。</li>
</ul>
<p><code>Window</code> 又叫Advertised Window，可以近似理解为滑动窗口（Sliding Window）的大小，用于流控。以此控制发送端发送数据的速率，从而达到流量控制。详细解析可见本文的<a href="https://homxuwang.github.io/2019/05/06/%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/#TCP%E7%9A%84%E6%BB%91%E7%AA%97">滑动窗口</a>部分.</p>
<p><code>Checksum</code> 校验和。此校验和是对TCP报文段,包括TCP头部,和TCP数据以16位进行计算所得。由发送端计算和存储并由接收端进行验证</p>
<p><code>Urgent Pointer</code> 紧急指针。只有当URG为1时有效，指出本报文段中紧急数据的字节数。</p>
<p><code>TCP Options</code> 可选项。长度可变，定义一些可选参数。</p>
<p><strong>注意</strong>:</p>
<ul>
<li><p>TCP和UDP不包含IP地址信息,但是它们包含源端口和目的端口。即端口是属于传输层范畴的，IP地址是IP层上的事。</p>
</li>
<li><p>在本地两个进程间进行通信时，可以使用唯一标识符PID。但是如果是两台不同计算机之间的进程进行通信时,只用PID是不够的,这时就在传输层中使用协议端口号,简称端口。IP可以唯一标识主机，而TCP协议和端口号可以唯一标识一个主机中的进程。这样可以用IP地址+协议+端口号唯一标识一个网络中的进程。一些场合中，这种唯一标识模式也称为套接字(socket)。虽然通信的重点是应用进程，但是只要把要传送的报文交给目的主机的正确端口，剩下的工作就由TCP来完成。</p>
</li>
<li><p>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）（准确说是五元组，还有一个是协议，但因为这里只是说TCP协议，所以，这里我只说四元组）。</p>
</li>
</ul>
<p>其他字段参考下图:<br><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/9.jpg" alt="TCP报文头"></p>
<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>当应用程序希望通过TCP与另一个应用程序通信时，它会发送一个通信请求，这个请求必须被送到一个确切的地址。在双方握手之后，TCP将会在两个应用程序之间建立一个全双工的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。<br><strong>注</strong>:全双工是指允许数据在两个方向上进行传输,即在同一时间,服务器可以发送数据给客户端,客户端也可以发送数据给服务器。</p>
<p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p>
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p>
<ul>
<li>第一次握手(SYN=1, seq=x):</li>
</ul>
<p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p>
<p>发送完毕后，客户端进入 SYN_SEND 状态。<br>这个报文不携带数据，并消耗一个序号。</p>
<ul>
<li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</li>
</ul>
<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN(Initial Sequence Number) 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即ACKnum=X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。<br>这个报文不携带数据，并消耗一个序号。</p>
<ul>
<li>第三次握手(ACK=1，ACKnum=y+1)</li>
</ul>
<p>客户端再次发送确认包(ACK)，确认报文的 ACK = 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p>
<p>发送完毕后，TCP连接建立，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，这时双方就可以开始进行通信了。TCP 握手结束。</p>
<p>TCP规定，这个ACK报文段可以携带数据(也可以不携带).如果不携带数据就不会消耗序号。</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/7.png" alt="TCP三次握手"></p>
<p>三次握手主要是要初始化Sequence Number 的初始值。双方需要发送自己的ISN（初始化序列号，Inital Sequence Number）给对方，并收到对方的回复——最简单的方式也是两个一来一回，四次握手，但此处进行了优化，将server端回复的ACK同server端自己的SYN合并在一个报文中发送给client，所以减少为三次。</p>
<blockquote>
<p>通信的双方要同步对方ISN——所以叫SYN（全称Synchronize Sequence Numbers）。也就是上图中的 x 和 y。这个号在以后的数据通信中，在client端按发送顺序递增，在server端按递增顺序重新组织，以保证应用层接收到的数据不会因为网络问题乱序。</p>
</blockquote>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>使用抓包工具,对三次握手进行查看:<br><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/10.png" alt="TCP三次握手抓包"></p>
<p>图中9087-&gt;80是客户端的9087端口号发送到服务器端的80端口.</p>
<p>(1)中,客户端发送了一个SYN包,在SYN包中首次握手，标明了Seq = x = 0。客户端进入 <code>SYN_SEND</code> 状态。<br>(2)中，服务器收到了SYN包,再回送SYN = 1, Ack = 1的确认包。此时服务器端的Seq = 0.Ack = 1是因为客户端最开始发送的Seq = x = 0,所以消耗一个序号后Ack = x + 1 = 0 + 1 = 1.将Seq = y = 0 ,Ack = 1 回发给客户端.服务器端进入 <code>SYN_RCVD</code> 状态<br>(3)中，浏览器接收到服务器的ACK确认后，回发一个ACK,因为服务器的Seq = y = 0 ,需要消耗掉一个序号，所以此时的Ack = y + 1 = 0 + 1 = 1.Seq = 1.<br>服务器和客户端进入<code>ESTABLISHED</code>状态.双方建立起连接，可以开始通信了.</p>
<p>其中 <code>Win = xxxx</code> ,Win的值就是作为滑动窗口进行流量控制的。</p>
<p><strong>总结</strong>：<br>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<p>第一次握手:建立连接时,客户端发送SYN包(syn=j)到服务器，并进入<code>SYN_SEND</code>状态，等待服务器确认；<br>第二次握手:服务器收到SYN包，必须确认用户的SYN(ack = j + 1),同时自己也发送一个SYN包(syn = k),即SYN+ACK包,此时服务器进入<code>SYN_RECV</code>状态;<br>第三次握手:客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack = k + 1),此包发送完毕，客户端和服务器进入ESTABLISHED状态,完成三次握手。</p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><ul>
<li>为什么要三次握手建立连接？</li>
</ul>
<p><strong>为了初始化Sequence Number的初始值</strong>.通信的双方要互相通知对方自己初始化的Sequence Number，也就是上图的x和y,这个号要作为以后数据通讯的序号，以保证传输的数据不会因为网络上的传输问题而乱序,即TCP用这个序号进行拼接数据。因此在服务器回发Sequence Number即第二次握手之后，还需要发送确认报文给服务器，告诉服务器客户端已经收到初始化的Sequence Number了。</p>
<ul>
<li>首次握手的隐患—SYN超时</li>
</ul>
<p><strong>问题起因分析</strong>:<br>Server收到Client的SYN,回复SYN-ACK的时候未收到ACK确认(比如客户端掉线).那么连接就会处于中间状态即半连接(half-open connect)，没有成功也没有失败。</p>
<p>Server不断重试(重新发送SYN-ACK)直至超时，Linux默认最多发送5次,每次发送时间翻倍。默认等待63秒才判定超时，TCP才断开连接。这样可能会产生针对SYN-Flood攻击的风险。</p>
<ul>
<li>SYN攻击</li>
</ul>
<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。<br>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
<ul>
<li>针对SYN-Flood的防护措施：</li>
</ul>
<p>①检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<p>②SYN cookies技术</p>
<ul>
<li>SYN队列满后,TCP通过源地址端口，目标地址端口和时间戳，打造一个特别的Sequence Number回发回去.(通过tcp_syncookies参数回发SYN Cookie.)</li>
<li>若是攻击者则没有响应。如果是正常用户，则Client会回发SYN Cookie,直接建立连接</li>
</ul>
<p>③缩短超时（SYN Timeout）时间<br>④过滤网关防护<br>⑤增加最大半连接数</p>
<ul>
<li><p>建立连接后,Client出现故障怎么办？</p>
</li>
<li><p><em>保活机制</em>*:<br>在一段时间处于保活时间(KeepAlive Time)，在这段时间连接处于非活动状态。开启保活功能的一段将向对方发送保活探测报文，如果发送端未收到响应报文，经过一个提前配置好的保活时间间隔,继续发送保活探测报文。直到发送次数达到保活探测数仍未收到响应，则对方主机则确认为不可达，此时中断连接。</p>
</li>
<li><p>KeepAlive 的局限<br>首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。</p>
</li>
</ul>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p>是为了终止连接，客户端和服务器总共要发送4个包，来确认连接的断开,因此称为四次挥手(Four-way handshake)。客户端或服务器均可主动发起挥手动作,任何一方执行 <code>close()</code> 操作即可产生挥手操作.</p>
<ul>
<li>第一次挥手(FIN=1,seq=x)<br>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。此时的序列号seq = ESTABLISHED状态下数据最后一次发送的时候已经传送过来的数据的最后一个字节的序号+1。</li>
</ul>
<p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p>
<ul>
<li>第二次挥手(ACK=1,ACKnum=x+1)<br>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</li>
</ul>
<p>发送完毕后，服务器端进入 <strong><code>CLOSE_WAIT</code></strong> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器发送释放连接报文。</p>
<ul>
<li>第三次挥手(FIN=1,ACK=1,seq=y)<br>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN = 1,ACK = 1。</li>
</ul>
<p>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</p>
<ul>
<li>第四次挥手(ACK=1，ACKnum=y+1)<br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code> 状态，等待可能出现的要求重传的 ACK 包。</li>
</ul>
<p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/11.png" alt="TCP四次挥手"></p>
<p><strong>总结</strong>:<br>第一次挥手：Client发送一个FIN,用来关闭Client到Server的数据传送,Client进入FIN_WAIT_1状态;<br>第二次挥手: Server收到FIN后,发送一个ACK给Client,确认序号为收到序号+1(与SYN相同,一个FIN占用一个序号),Server进入CLOSE_WAIT状态;<br>第三次挥手: Server发送一个FIN,用来关闭Server到Client的数据传送,Server进入LAST_ACK状态;<br>第四次挥手: Client收到FIN后,Client进入TIME_WAIT状态,接着发送一个ACK给Server,确认序号为收到序号+1,Server进入CLOSED状态,客户端等待2MSL时间后,进入CLOSED状态.完成四次挥手。</p>
<h2 id="相关问题-1"><a href="#相关问题-1" class="headerlink" title="相关问题"></a>相关问题</h2><ul>
<li><p>为什么要设置2MSL时间后客户端才关闭？<br>①:确保有足够的时间让对方收到ACK包或主动方收到了被动方超时重传的FIN。即，如果被动方没有收到Ack，就会触发被动方重传FIN，发送Ack+接收FIN正好2个MSL，TIME_WAIT状态的连接收到重传的FIN后，重传Ack，再等待2 * MSL时间。<br>②:避免新旧连接混淆.确保有足够的时间让“迷途的重复分组”过期丢弃。这只需要1 * MSL即可，超过MSL的分组将被丢弃，否则很容易同新连接的数据混在一起（仅仅依靠ISN是不行的）。因为有些路由器会缓存IP数据包,如果连接被重用了,那么延迟收到的包就有可能跟新连接混在一起.</p>
</li>
<li><p>为什么要进行四次才能完成挥手操作？<br>参照三次握手的过程，其实是双方各自关闭资源进行2次挥手。握手的目的是同步双方的ISN，不是耗时操作，因此可以“将server端回复的ACK同server端自己的SYN合并在一个报文中发送给client”；但挥手要回收大量资源，是耗时操作，因此，不能强制“将server端回复的ACK同server端自己的FIN合并在一个报文中发送给client”，所以通常认为挥手需要四次。<br>对于挥手，因为TCP是全双工的，client与server都占用各自的资源发送segment（同一通道，同时双向传输seq和ack），所以，<strong>双方都需要关闭自己的资源（向对方发送FIN）并确认对方资源已关闭（回复对方Ack）</strong>,也就是双方都需要FIN报文和ACK报文；而双方可以同时主动关闭，也可以由一方主动关闭带动另一方被动关闭。只不过，通常以一方主动另一方被动举例（如图，client主动server被动），所以看上去是所谓的4次挥手。<br><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/12.png" alt="TCP四次挥手"></p>
</li>
<li><p>服务器出现大量CLOSE_WAIT状态的原因<br>对方关闭socket连接,我方忙于读或写,没有及时关闭连接.<br>需要检查代码,特别是释放资源的代码.<br>检查配置,特别是处理请求的线程配置.<br>如果CLOSE_WAIT状态的连接过多的话,就需要去排查问题。如果CLOSE_WAIT一直保持，意味着对应数目的通道一直被占用,一旦达到了上限,则新的请求就无法被处理，甚至会让服务器崩溃。</p>
</li>
</ul>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP报文结构相比TCP要简单,主要包括:<br><code>Source Port</code>: 源端口<br><code>Destination Port</code>: 目标端口<br><code>Length</code>: 数据包长度<br><code>Checksum</code>: 校验值<br>最后一部分为用户数据<br><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/13.png" alt="UDP报文结构"></p>
<p>因为UDP的报文头较TCP简单,所以它不像TCP一样会支持错误重传、滑动窗口等精细控制.</p>
<p><strong>UDP的特点:</strong></p>
<ul>
<li><p>面向非连接的协议,传输数据之前,<strong>源端与终端不建立连接</strong>。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。当想传送时,就简单抓取来自应用程序的数据,并尽可能快的放到网络上.发送端,UDP的传送速度是应用程序生成数据的速度、计算机的能力、传送带宽的限制.在接收端，UDP把每个消息段放在队列中,应用程序每次从队列中读取一个消息段.</p>
</li>
<li><p>由于不建立连接,所以不需要维护连接状态,因此UDP <strong>支持多播和广播</strong>,即支持向多个客户端传送相同的消息。</p>
</li>
<li><p>UDP数据包报头只有8个字节(TCP有20个字节),额外开销较小</p>
</li>
<li><p>吞吐量不受拥挤控制算法的调节，只受限于数据生成速率、传输带宽及机器性能</p>
</li>
<li><p>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次。(UDP尽最大努力交付,不保证可靠交付,不需要维持复杂的链接状态表)</p>
</li>
<li><p>UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</p>
</li>
<li><p>UDP面向报文,不对应用程序提交的报文信息进行拆分或者合并。因此应用程序要选择合适的大小。</p>
</li>
</ul>
<p><strong>TCP和UDP的区别</strong>:<br>||TCP|UDP|<br>| – | – | – |<br>|面向连接 vs 无连接|面向连接|无连接|<br>||点对点传输|单个点向多个点传输|<br>|可靠性|可靠性保证(握手、挥手)|不提供可靠性保证(可能会丢失,不知道是否被接收)|<br>|有序性|有序性保证(到达可能无序,但是会进行排序保证有序)|不具备有序性|<br>|速度|速度慢(要创建连接、保证可靠性、有序性等)|较快(比较适合对速度敏感的应用:在线视频等)|<br>|量级(体现在元数据头的大小)|重量级(20个字节)|轻量级(8个字节)|</p>
<h1 id="TCP的滑窗"><a href="#TCP的滑窗" class="headerlink" title="TCP的滑窗"></a>TCP的滑窗</h1><h2 id="RTT和RTO"><a href="#RTT和RTO" class="headerlink" title="RTT和RTO"></a>RTT和RTO</h2><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效,即TCP在发送一个数据包之后,会启动一个重传定时器,RTO就是这个定时器的重传时间. 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。<br>所以简单的说,RTT就是发送一个数据包(记录时间为t0)到收到对应的ACK(记录时间为t1)所花费的时间(RTT=t1-t0)；<br>RTO(Retransmission TimeOut)是重传时间间隔,最开始预先算一个定时器时间,如果回复了ACK那么重传定时器就失效,即不用重传了.如果没有回复ACK,而RTO定时器的时间又到了,则就重传.由于RTO是本次发送当前数据包所预估的超时时间,则RTO就需要一个很好的算法来统计,更好的预测这次的超时时间,所以RTO不是写死的配置,而是根据RTT计算出来的.有了RTT才能计算出RTO.关于具体计算方法可以参考本文的<code>参考</code>部分的链接.</p>
<p>基于RTO才有了重传机制,进一步有了滑动窗口.</p>
<h2 id="滑动窗口计算过程"><a href="#滑动窗口计算过程" class="headerlink" title="滑动窗口计算过程"></a>滑动窗口计算过程</h2><p>TCP在传送时会将数据拆分成段,出于效率和传输速度的考虑,不可能将数据一段一段的发送,而是要实现对数据的批量发送,所以TCP要解决可靠传输和包乱序的问题.所以TCP要知道网络实际的数据处理带宽或数据处理速度,这样才不会引起网络拥塞,导致丢包.<br><strong>TCP使用滑动窗口(Sliding Window)做流量控制与乱序重排</strong><br>即它的两个作用是</p>
<ul>
<li>保证TCP的可靠性</li>
<li>保证TCP的流控特性</li>
</ul>
<p>在本文前面TCP的报文字段中,有一个<code>Window</code>值,也叫<code>Advertised-Window</code>,用于接收方通知发送方自己还有多少缓冲区可以接收数据,发送方根据接收方的处理能力来发送数据,这样不会导致接收方处理不过来,这就是<strong>流量控制</strong>.<br>同时窗口控制还体现了TCP面向字节流的设计思路.</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/14.png" alt="滑动窗口计算过程"><br>上图中左半部分是TCP协议的发送端缓冲区,右图是接收端缓冲区.</p>
<ul>
<li>LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认）,即从左端算起连续已经被接收端的程序发送ACK回执确认，已收到了Sequence Number.</li>
<li>LastByteSent指向已发送的最后一个字节的位置,该位置只是发送出去,但是还没有收到ACK的回应.</li>
<li>LastByteWritten指向上层应用已写完的最后一个字节的位置.即当前程序已经准备好的需要发送的最后一个数据段.</li>
</ul>
<p>所以LastByteAcked之前的数据是已经发送并确认的数据,LastByteAcked和LastByteSent之间的数据是已经发送出去但还没有确认的数据,LastByteWritten指向的是上层应用正在写的地方。</p>
<ul>
<li>LastByteRead指向上层应用已经读完的最后一个字节的位置(TCP缓冲区中读到的位置),即收到了发送方的数据,并且已经处理和回执了的数据的最后一个位置.</li>
<li>NextByteExpected指向收到的连续最大的Sequence的位置(收到的连续包的最后一个位置)，即这段数据已经收到了但是还没有给发送端发送回执信息.</li>
<li>LastByteRcved指向已收到包的最后一个字节的位置,中间有些数据还没有到达，所以有数据空白区.</li>
</ul>
<p>接收端在给发送端回ACK中会汇报自己还能处理的数据<strong>AdvertisedWindow = MaxRcvBuffer – (LastByteRcvd – LastByteRead)</strong>;<br>MaxRcvBuffer:接收方能接收的最大数据量,可以理解为接收端缓存池的大小;<br>LastByteRcvd – LastByteRead: 表示当前接收方已为接收到的数据或为还没有接收到的预定的数据留出来的空间.<br>这样做减法，用最大缓存减去不能用的缓存,就是还能接收的数据量。然后将接收端在给发送端回ACK中会汇报自己还能处理的数据AdvertisedWindow告知发送方.发送方要根据接收端在给发送端回ACK中会汇报自己还能处理的数据AdvertisedWindow的值,保证<strong>LastByteSent - LastByteAcked &lt;= AdvertisedWindow</strong></p>
<p>窗口内剩余可发送数据的大小<strong>EffectiveWindow = AdvertisedWindow - (LastByteSent - LastByteAcked)</strong>.即LastByteSent - LastByteAcked为已经发送了但待确认的,那么还能发送的内容就用接收方能承受的数据量AdvertisedWindow为基准,减去这部分大小.这样才能保证接收方能处理这些数据.</p>
<h2 id="滑动窗口的基本原理"><a href="#滑动窗口的基本原理" class="headerlink" title="滑动窗口的基本原理"></a>滑动窗口的基本原理</h2><p>TCP会话的发送方</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/15.png" alt="滑动前"><br>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>1已发送并收到端ack回应的数据</li>
<li>2已经发送但还没收到ack的</li>
<li>3在窗口中未发送但还允许发送的</li>
<li>4未发送且由于达到了window的大小,对端不允许发送的数据</li>
</ul>
<p>则2 3部分就组成了一个发送窗口</p>
<p><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/16.png" alt="滑动后"></p>
<p>原滑动窗口的边界为32-51,已发送但未被确认的序号为32-45,此时如果32和33都没有被确认,即使34被确认了,窗口也不会向右滑动,只有等到32也被确认后(即连续确认后)窗口才会移动,在移动之前,大于51的数据是不能被发送的.<br>滑动后32-36都被确认了,则滑动窗口向右移动了5位,进而后面能继续发送52-56的数据了.滑动后收到36的ack，并发出了46-51的字节</p>
<p>TCP会话的接收方<br><img src="%E6%B5%85%E8%B0%88TCP%E5%8D%8F%E8%AE%AE/17.png" alt="接收方"></p>
<ul>
<li>1 2已接收和已发送回执的状态</li>
<li>3未接收但可以接收的数据(准备接收的状态)</li>
<li>4未接收并不能接收的状态(因为达到窗口阈值)</li>
</ul>
<p>由于ACK直接由TCP栈回复,默认没有应用延迟,所以不存在已接收但是未回复ACK的状态</p>
<p>其中绿色部分(未接收但准备接收)就是接收窗口.其滑动机制和传送方的机制是一样的.</p>
<p><strong>总结</strong>:<br>TCP的最基本的传输可靠性来源于确认重传机制,TCP的滑动窗口的可靠性也是建立在确认重传基础上.发送窗口只有收到接收端对于本段发送窗口内字节的ack确认,才会移动发送窗口的左边界,接收窗口只有在前面所有的段都确认的情况下,才会移动左边界.当前面还有字节未接收,但收到后面字节的情况下窗口是不会移动的,不会对后续的字节确认,以此确保对端会对数据重传.滑动窗口的大小可以依据一定的策略进行动态调整,应用会根据自身处理能力的变化,通过本端TCP接收窗口大小的控制实现对端的发送窗口进行流量限制.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://coolshell.cn/articles/11609.html">https://coolshell.cn/articles/11609.html</a></p>
<p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></p>
<p><a href="https://monkeysayhi.github.io/2018/03/07/%E6%B5%85%E8%B0%88TCP%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8E%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/">https://monkeysayhi.github.io/2018/03/07/%E6%B5%85%E8%B0%88TCP%EF%BC%881%EF%BC%89%EF%BC%9A%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8E%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]JavaScript原型和原型链</title>
    <url>/2019/05/10/%E8%BD%AC-JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>本文转自: <a href="https://github.com/mqyqingfeng/Blog/issues/2">https://github.com/mqyqingfeng/Blog/issues/2</a></p>
<h1 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h1><p>我们先使用构造函数创建一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<p>很简单吧，接下来进入正题：</p>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虽然写在注释里，但是你要注意：</span></span><br><span class="line"><span class="comment">// prototype是函数才会有的属性</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>
<p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p>
<p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</p>
<p><img src="%E8%BD%AC-JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/1.png" alt="Person.prototype"></p>
<p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：<br><img src="%E8%BD%AC-JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/2.png" alt="prototype1"></p>
<p>在这张图中我们用 Object.prototype 表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>
<h1 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h1><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>
<p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>于是我们更新下关系图：<br><img src="%E8%BD%AC-JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/3.png" alt="prototype2"><br>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<p>为了验证这一点，我们可以尝试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以再更新下关系图：<br><img src="%E8%BD%AC-JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/4.png" alt="prototype3"><br>综上我们已经得出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p>
<h1 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h1><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&#x27;Daisy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h1 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h1><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&#x27;Kevin&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>
<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：<br><img src="%E8%BD%AC-JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/5.png" alt="prototype4"></p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>那 Object.prototype 的原型呢？</p>
<p>null，我们可以打印：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>然而 null 究竟代表了什么呢？</p>
<p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》</a> 就是：</p>
<blockquote>
<p>null 表示“没有对象”，即该处不应该有值。</p>
</blockquote>
<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：<br><img src="%E8%BD%AC-JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/6.png" alt="prototype5"><br>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>最后，补充三点大家可能不会注意的地方：</p>
<h2 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h2><p>首先是 constructor 属性，我们看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>
<h2 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h2><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h2 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h2><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>构造函数的prototype属性指向原型,实例的__proto__属性指向原型,原型链通过__proto__链接起来</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>本文转自 <a href="https://github.com/mqyqingfeng/Blog/issues/2">https://github.com/mqyqingfeng/Blog/issues/2</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>用户日志统计分析</title>
    <url>/2018/08/04/%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="离线数据处理架构"><a href="#离线数据处理架构" class="headerlink" title="离线数据处理架构"></a>离线数据处理架构</h1><p><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/13.png" alt="离线数据处理架构"></p>
<ol>
<li>用户通过APP或者PC访问服务器</li>
<li>这期间的操作日志信息用nginx记录下来(如记录在/var/log/access.log)，记录在nginx服务器</li>
<li>借助Flume框架，将日志信息抽取到HDFS中（命名规则根据自己的需要进行修改）</li>
<li>离线数据处理的第一步就是清理脏数据，清理完脏数据后继续写入HDFS</li>
<li>继续进行Hive（这里的Hive是一个统称，如Spark Sql）</li>
<li>处理完的结果写入RDBMS中或者NO SQL中</li>
<li>进行相应的数据输出(如表格，图形化输出)</li>
</ol>
<p>离线处理的作业过程可以使用任务调度框架（Oozie或Azkaban）进行任务调度，安排每天进行作业的时间。可以将4.5.步骤串联起来</p>
<p>Kafka可以将日志进行实时处理，数据来了后进行立即处理（这是实时流处理）</p>
<p>本篇是写离线处理的一些代码分析和实现。</p>
<p>首先看数据(数据来自粉丝日志的教程，地址：<a href="http://blog.fens.me/hadoop-mapreduce-log-kpi/)%EF%BC%9A">http://blog.fens.me/hadoop-mapreduce-log-kpi/)：</a></p>
<p><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/8.png" alt="nginx日志"></p>
<p>摘取某一行的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">222.68.172.190 - - [18/Sep/2013:06:49:57 +0000] &quot;GET /images/my.jpg HTTP/1.1&quot; 200 19939 &quot;http://www.angularjs.cn/A00n&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote_addr: 记录客户端的ip地址, 222.68.172.190</span><br><span class="line">remote_user: 记录客户端用户名称, –</span><br><span class="line">time_local: 记录访问时间与时区, [18/Sep/2013:06:49:57 +0000]</span><br><span class="line">request: 记录请求的url与http协议, “GET /images/my.jpg HTTP/1.1”</span><br><span class="line">status: 记录请求状态,成功是200, 200</span><br><span class="line">body_bytes_sent: 记录发送给客户端文件主体内容大小, 19939</span><br><span class="line">http_referer: 用来记录从那个页面链接访问过来的, “http://www.angularjs.cn/A00n”</span><br><span class="line">http_user_agent: 记录客户浏览器的相关信息, “Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36”</span><br></pre></td></tr></table></figure>
<p>目的：</p>
<ul>
<li>根据日志信息抽取出浏览器的信息</li>
<li>针对不同的浏览器进行统计</li>
</ul>
<h1 id="单机版代码分析和实现"><a href="#单机版代码分析和实现" class="headerlink" title="单机版代码分析和实现"></a>单机版代码分析和实现</h1><h2 id="新建一个类，进行单机的测试"><a href="#新建一个类，进行单机的测试" class="headerlink" title="新建一个类，进行单机的测试"></a>新建一个类，进行单机的测试</h2><h2 id="下载配置userAgentParser工具类"><a href="#下载配置userAgentParser工具类" class="headerlink" title="下载配置userAgentParser工具类"></a>下载配置userAgentParser工具类</h2><p>在github上下载工具类：<a href="https://github.com/LeeKemp/UserAgentParser">https://github.com/LeeKemp/UserAgentParser</a></p>
<p>然后在本地用<code>maven</code>进行编译，编译的时候我出现了一些问题，见文章最后的踩坑记。</p>
<p>新建一个单元测试方法：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/9.png" alt="userAgentParser单元测试"><br>输入一行数据进行测试<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/10.png" alt="userAgentParser单元测试"></p>
<h2 id="进行日志读取分析，统计访问网站的浏览器的数据"><a href="#进行日志读取分析，统计访问网站的浏览器的数据" class="headerlink" title="进行日志读取分析，统计访问网站的浏览器的数据"></a>进行日志读取分析，统计访问网站的浏览器的数据</h2><p>相应的引入的文件：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/12.png" alt="userAgentParser单元测试"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFileTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        String path = <span class="string">&quot;/home/hadoop/study/data/access.log.10&quot;</span>;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">               <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path)))</span><br><span class="line">        );</span><br><span class="line">        String line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        UserAgentParser userAgentParser  = <span class="keyword">new</span> UserAgentParser();</span><br><span class="line">        UserAgent agent ;</span><br><span class="line">        Map&lt;String,Integer&gt; broswerMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(line != <span class="keyword">null</span>)&#123;</span><br><span class="line">            line = reader.readLine(); <span class="comment">//一次读一行数据</span></span><br><span class="line">            i ++;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isNotBlank(line))&#123;<span class="comment">//判断是否为空</span></span><br><span class="line">                String source = line.substring(getCharacterPosition(line,<span class="string">&quot;\&quot;&quot;</span>,<span class="number">5</span>) + <span class="number">1</span>);</span><br><span class="line">                agent = userAgentParser.parse(source);</span><br><span class="line">                String browser = agent.getBrowser();</span><br><span class="line">                String engine = agent.getEngine();</span><br><span class="line">                String engineVersion = agent.getEngineVersion();</span><br><span class="line">                String os = agent.getOs();</span><br><span class="line">                String platform = agent.getPlatform();</span><br><span class="line">                <span class="keyword">boolean</span> isMobile = agent.isMobile();</span><br><span class="line"></span><br><span class="line">                Integer broswerValue = broswerMap.get(browser);</span><br><span class="line">                <span class="keyword">if</span>(broswerMap.get(browser) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    broswerMap.put(browser,broswerValue + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    broswerMap.put(browser,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                System.out.println(browser + &quot;,&quot; + engine + &quot; &quot; + engineVersion + &quot; &quot; + os + &quot; &quot; + platform);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一共有多少条数据</span></span><br><span class="line">        System.out.println(i-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : broswerMap.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>定义私有方法获取指定字符串中指定标识的字符串出现的索引，分析某一行的用户日志，可以使用<code>&quot;</code>进行分割，获取访问的客户端等信息在第5个<code>&quot;</code>，所以<code>operator = &quot;</code>,<code>index = 5</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 获取指定字符串中指定标识的字符串出现的索引</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCharacterPosition</span><span class="params">(String value,String operator,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	Matcher slashMatcher = Pattern.compile(operator).matcher(value);</span><br><span class="line">	<span class="keyword">int</span> mIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(slashMatcher.find())&#123;</span><br><span class="line">		mIndex ++;</span><br><span class="line">		<span class="keyword">if</span>(mIndex == index)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slashMatcher.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以查看打印结果：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/11.png" alt="userAgentParser单元测试"></p>
<h1 id="MapReduce实现需求统计"><a href="#MapReduce实现需求统计" class="headerlink" title="MapReduce实现需求统计"></a>MapReduce实现需求统计</h1><h2 id="新建类"><a href="#新建类" class="headerlink" title="新建类"></a>新建类</h2><p><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/14.png"></p>
<h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>可以参考 MapReduce的补充和WordCount简单实战(二):<a href="https://homxuwang.github.io/2018/07/29/MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/">https://homxuwang.github.io/2018/07/29/MapReduce%E7%9A%84%E8%A1%A5%E5%85%85%E5%92%8CWordCount%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%982/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hadoop.project;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kumkee.userAgent.UserAgent;</span><br><span class="line"><span class="keyword">import</span> com.kumkee.userAgent.UserAgentParser;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用MapReduce 统计浏览器的访问次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">        LongWritable plusone = <span class="keyword">new</span> LongWritable(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> UserAgentParser userAgentParser ;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            userAgentParser = <span class="keyword">new</span> UserAgentParser();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            UserAgent agent ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先读入没一行数据</span></span><br><span class="line">            String line = value.toString();</span><br><span class="line"></span><br><span class="line">            String source = line.substring(getCharacterPosition(line,<span class="string">&quot;\&quot;&quot;</span>,<span class="number">5</span>) + <span class="number">1</span>);</span><br><span class="line">            agent = userAgentParser.parse(source);</span><br><span class="line">            String browser = agent.getBrowser();</span><br><span class="line"></span><br><span class="line">                context.write(<span class="keyword">new</span> Text(browser),plusone);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            userAgentParser = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(LongWritable value : values)&#123;</span><br><span class="line">                sum += value.get();<span class="comment">//通过get()转化为java中的类型</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最终统计结果输出</span></span><br><span class="line">            context.write(key,<span class="keyword">new</span> LongWritable(sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定字符串中指定标识的字符串出现的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCharacterPosition</span><span class="params">(String value,String operator,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        Matcher slashMatcher = Pattern.compile(operator).matcher(value);</span><br><span class="line">        <span class="keyword">int</span> mIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slashMatcher.find())&#123;</span><br><span class="line">            mIndex ++;</span><br><span class="line">            <span class="keyword">if</span>(mIndex == index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slashMatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException,InterruptedException </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        Path outputPath = <span class="keyword">new</span> Path(args[<span class="number">1</span>]);</span><br><span class="line">        FileSystem fileSystem = FileSystem.get(configuration);</span><br><span class="line">        <span class="keyword">if</span>(fileSystem.exists(outputPath))&#123;</span><br><span class="line">            fileSystem.delete(outputPath,<span class="keyword">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;filePath exists,but it has deleted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(configuration,<span class="string">&quot;LogBrowser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        job.setJarByClass(LogApp.class);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job,<span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(LogApp.MyMapper.class);</span><br><span class="line"></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line"></span><br><span class="line">        job.setCombinerClass(LogApp.MyReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setReducerClass(LogApp.MyReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(LongWritable.class);</span><br><span class="line"></span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>)? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置pom-xml文件"><a href="#配置pom-xml文件" class="headerlink" title="配置pom.xml文件"></a>配置pom.xml文件</h2><p>在生产环境中hadoop的包是不需要的，所以加一个<code>&lt;scope&gt;provided&lt;/scope&gt;</code><br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/15.png"></p>
<p>而因为<code>UserAgentParser</code>是第三方的包，在mvn打包的时候需要进行配置才能够添加进去，使用<code>maven-assembly-plugin</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span><span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包命令使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn assembly:assembly</span><br></pre></td></tr></table></figure>
<p><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/16.png"><br>可以看到打包成功的信息<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/17.png"><br><code>hdfs-1.0-SNAPSHOT-jar-with-dependencies.jar</code>就是打包成功的文件</p>
<p>然后传到指定位置（或者服务器），我这里单机的伪分布式框架，所以传到本地一个目录就可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp hdfs-1.0-SNAPSHOT-jar-with-dependencies.jar ~/lib</span><br></pre></td></tr></table></figure>
<p>然后将日志数据上传到hdfs的根目录:<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/19.png"><br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/18.png"></p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop jar /home/hadoop/lib/hdfs-1.0-SNAPSHOT-jar-with-dependencies.jar com.hadoop.project.LogApp hdfs://localhost:9000/access.log.10 hdfs://localhost:9000/Log/logBrowser</span><br></pre></td></tr></table></figure>
<p>可以看到成功信息<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/21.png"><br>在目录中查看：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/22.png"><br>查看结果：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/23.png"><br>这与在单元测试中看到的信息是一样的：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/11.png"></p>
<p>下一步可以写到RDBMS中或者NOSQL数据库中，进一步进行可视化展示<br>这只是单纯的统计了浏览器的记录，在实际应用中，应该根据日志中的时间记录统计每一天或者没一星期的时间周期中的访问记录。</p>
<h1 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h1><h2 id="mvn打包时的错误"><a href="#mvn打包时的错误" class="headerlink" title="mvn打包时的错误"></a>mvn打包时的错误</h2><p>在github仓库下载了<code>UserAgentParser</code>工具类后，需要在自己电脑上打包（<code>mvn clean package -DskipTests</code>）。打包过程中报错：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/6.png" alt="mvn打包报错"><br>这里报错为<code>(请使用 -source 5 或更高版本以启用泛型)</code>和<code>-source1.3 中不支持泛型</code>.后来发现原来是下载的项目年代过久（已经7年了）。我本地的环境是<code>maven 3.0.5</code>和<code>java 1.7</code>.所以在下载的项目的<code>pom.xml</code>中添加一段代码，用来指定打包的项目所使用的java版本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/5.png" alt="pom.xml"><br>这样打包就可以了<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/1.png" alt="打包成功"></p>
<h2 id="maven引入刚才打包的文件出现的问题"><a href="#maven引入刚才打包的文件出现的问题" class="headerlink" title="maven引入刚才打包的文件出现的问题"></a>maven引入刚才打包的文件出现的问题</h2><p>在打包完成后,还需要将打包后的文件放入maven的本地仓库以便使用(<code>mvn clean install -DskipTest</code>).打包完成后的信息：<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/2.png"><br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/3.png"></p>
<p>可以看到打包完成后的目录在<code>/home/hadoop/.m2/respository/com/kumkee/</code>下，这个是maven的本地默认仓库目录。<br>而我在项目中使用的目录是后来指定的目录，所以在引用时一直不行，后来终于找到了这个问题<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/4.png"></p>
<p>可以看到本地的仓库指定在<code>/home/hadoop/文档/maven_repos</code>，所以在打包的时候可以指定打包到本地的maven目录，即<code>mvn clean install -DskipTest -Dmaven.repo.local=/home/hadoop/文档/maven_repos</code></p>
<p>这样就可以在项目中引入了</p>
<p><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/7.png"></p>
<h2 id="MapReduce作业时报错"><a href="#MapReduce作业时报错" class="headerlink" title="MapReduce作业时报错"></a>MapReduce作业时报错</h2><p>错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TaskAttemptListenerImpl: Task: attempt_1533460421274_0001_m_000000_0 - exited : java.io.IOException: Type mismatch in key from map: expected org.apache.hadoop.io.LongWritable, received org.apache.hadoop.io.Text</span><br></pre></td></tr></table></figure>

<p>原来是写成了两个<code>job.setMapOutpuKeyClass()</code>方法，改正后重新编译jar包并运行即可<br><img src="%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/20.png"></p>
]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈HTTP/HTTPS协议</title>
    <url>/2019/05/08/%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>HTTP即超文本传输协议</p>
<h1 id="HTTP的特性"><a href="#HTTP的特性" class="headerlink" title="HTTP的特性"></a>HTTP的特性</h1><ul>
<li>HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80</li>
<li>HTTP 是基于请求与相应模式的<strong>无连接无状态</strong>的协议.<br>无连接的目的是限制每次连接只处理一个请求,服务器处理完客户请求并受到客户应答后即断开连接,采用这种方式可以节省时间.HTTP1.1起默认使用长连接,即服务器要等待一定时间后才断开连接,以保证连接特性,虽然目前的一些技术(如keepAlive)使用长连接进行优化,但这些是属于HTTP请求之外的.也就是说,在每个独立的HTTP请求之中,用户无法知道当前的HTTP是否处于长连接的状态,所以用户始终都要认为HTTP在请求结束后就会关闭.至于下层实现是否在HTTP请求结束后关闭连接,都不会改变这个特性.长连接可以理解为下层实现对上层透明.<br>无状态是指协议对于事务处理没有记忆能力,缺少状态意味着如果后续处理需要前面的信息,则必须被重传.可能导致每次连接传送的数据量增大,不过再服务器不需要先前信息时,它的应答就较快.</li>
<li>HTTP 支持客户服务器模式.HTTP工作在Client、Server架构之上,浏览器作为HTTP客户端,通过URL向HTTP服务端(Web服务器)发送请求.Web服务器根据请求向客户端发送响应信息.</li>
<li>HTTP 简单快速.客户端发送请求时只需发送请求方法和路径.由于HTTP协议较为简单，使HTTP程序规模小,因而通信速度很快</li>
<li>HTTP 较为灵活.HTTP可以传输任意类型的数据对象(使用ContentType标记).</li>
</ul>
<h1 id="HTTP请求-响应"><a href="#HTTP请求-响应" class="headerlink" title="HTTP请求/响应"></a>HTTP请求/响应</h1><h2 id="HTTP请求结构"><a href="#HTTP请求结构" class="headerlink" title="HTTP请求结构"></a>HTTP请求结构</h2><p><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/1.png" alt="HTTP请求报文"></p>
<p>HTTP的请求报文主要由<strong>请求行</strong>、<strong>请求头部</strong>、<strong>空行</strong>、<strong>请求数据</strong>组成.</p>
<ul>
<li><p>请求行主要包括:<br><code>请求方法</code>: 主要有GET、POST、PUT、DELETE等<br><code>URL</code>: 全称是资源描述符,即请求路径.一个URL地址，用于描述一个网络上的资源<br><code>协议版本</code>: HTTP版本(1.0、1.1)</p>
</li>
<li><p>请求头部主要包括:<br>请求头部由若干个报头组成,每个报头的格式为<code>头部字段名:值</code><br>用来设置HTTP请求的一些参数.例如HOST,被请求数据的主机和端口号;ContentType等.</p>
</li>
<li><p>请求数据:<br>请求数据就是数据体,它一般只在POST请求中用到,表示上传的数据</p>
</li>
<li><p>注意:<br>请求头部后面的空行是必须的,用它来标识已经结束了头部信息的发送.</p>
</li>
</ul>
<p><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/2.png" alt="HTTP抓包"><br>使用抓包工具查看一段HTTP请求的信息.</p>
<p>可以看到第一行请求方法为GET;接着空格;然后是URL;接着空格;然后是协议版本,为HTTP1.1;最后回车换行.<br>第二部分就是一些请求头,包括Host、Connection等.请求头部分一般就是Host到Cookie部分.<br>再往下就空出一行.</p>
<h3 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h3><table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP报文层面</td>
<td>请求信息放在URL</td>
<td>请求信息放在报文体</td>
</tr>
<tr>
<td>数据库层面</td>
<td>符合幂等性和安全性</td>
<td>不符合幂等性和安全性</td>
</tr>
<tr>
<td>其他层面</td>
<td>可以被缓存、被存储</td>
<td>不可以被缓存、被存取</td>
</tr>
</tbody></table>
<p>GET的请求信息和URL之间以<code>?</code>隔开,请求信息的格式为键值对,可参考上图GET请求的路径.因为是通过URL,所以是有长度限制的(HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制).<br>POST将请求信息放在报文体中，想获得请求信息要解析报文,所以安全性较GET方式要高一些(其实要获得报文信息也很简单,所以二者安全性没有太大区别,如果要提高安全性最好使用HTTPS).</p>
<p>安全性意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。<br>幂等性意味着对同一URL的多个请求应该返回同样的结果。</p>
<p>大部分的GET请求通常都被CDN缓存了,这样可以减小对Web服务器的压力.而POST是非幂等的操作,每次都要交由Web服务器处理.</p>
<h2 id="HTTP响应结构"><a href="#HTTP响应结构" class="headerlink" title="HTTP响应结构"></a>HTTP响应结构</h2><p><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/3.png" alt="HTTP响应报文"></p>
<p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文<br>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。<br>响应头是客户端要使用的一些附加信息.比如Date是响应生成的日期时间;Content-Type是对应的数据格式.<br>响应体则是具体的数据.即Content的内容</li>
</ul>
<p>常见的<strong>状态码</strong>有如下几种：</p>
<ul>
<li><code>1xx</code> 指示信息 表示请求已接收,继续处理</li>
<li><code>2xx</code> 成功 表示请求已被成功接收、理解<ul>
<li><code>200</code> OK 客户端请求成功</li>
</ul>
</li>
<li><code>3xx</code> 重定向 要完成请求必须进行更进一步操作<ul>
<li><code>301</code> Moved Permanently 请求永久重定向</li>
<li><code>302</code> Moved Temporarily 请求临时重定向</li>
<li><code>304</code> Not Modified 文件未修改，可以直接使用缓存的文件。</li>
</ul>
</li>
<li><code>4xx</code> 客户端错误 请求有语法错误或者请求无法实现<ul>
<li><code>400</code> Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</li>
<li><code>401</code> Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li><code>403</code> Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li><code>404</code> Not Found 请求的资源不存在，例如，输入了错误的URL</li>
</ul>
</li>
<li><code>5xx</code> 服务器端错误 服务器未能实现合法的请求<ul>
<li><code>500</code> Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>
<li><code>503</code> Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li>
</ul>
</li>
</ul>
<h2 id="HTTP请求-响应的步骤"><a href="#HTTP请求-响应的步骤" class="headerlink" title="HTTP请求/响应的步骤"></a>HTTP请求/响应的步骤</h2><ul>
<li>客户端连接到Web服务器.通常是浏览器客户端与Web服务器的HTTP端口(默认为80端口)建立TCP套接字(socket)连接.</li>
<li>发送HTTP请求.即客户端通过TCP套接字向服务器发送文本请求报文.</li>
<li>服务器接收请求并返回HTTP响应.Web服务器解析请求并定位请求资源,服务器将资源副本写入TCP套接字,由客户端读取.</li>
<li>释放TCP连接.若连接模式为CLOSE,则服务器主动关闭TCP连接,客户端被动关闭连接.若为KeepAlive,则该连接会保持一段时间,在该时间内可以继续接收请求.</li>
<li>客户端浏览器解析内容.客户端拿到数据后首先解析状态行,查看表明请求是否成功,然后解析每个响应头,对内容进行解析(HTML、json等)</li>
</ul>
<h2 id="浏览器键入URL-按下回车后经历的流程"><a href="#浏览器键入URL-按下回车后经历的流程" class="headerlink" title="浏览器键入URL,按下回车后经历的流程"></a>浏览器键入URL,按下回车后经历的流程</h2><ul>
<li><p>1 DNS解析.<br>浏览器根据URL逐层查询DNS服务器缓存,解析URL中域名对应的IP地址.DNS解析是一个递归查询的过程，从哪个缓存找到对应的IP后就直接返回,不再查询后面的缓存。<br>DNS域名解析过程<br>域名解析过程： . -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com/">www.google.com</a>.<br>DNS缓存从近到远依次是<br><code>浏览器缓存</code>:浏览器缓存DNS记录一段时间，操作系统并没有告诉浏览器每个DNS记录的生存时间，因此浏览器会将其缓存一段固定的时间（一般在2到30分钟之间）。<br><code>系统缓存</code>:如果浏览器缓存不包含所需的记录，则浏览器进行调用操作系统的缓存。<br><code>路由器缓存</code>:请求继续到路由器，路由器通常具有自己的DNS缓存。<br><code>ips服务器缓存</code>:检查的下一个位置是缓存ISP的DNS服务器。<br><code>根域名服务器缓存</code><br><code>顶级域名服务器缓存</code></p>
</li>
<li><p>2 TCP连接<br>找到了IP地址后,会根据IP地址和对应端口(默认为80)与服务器建立TCP连接(三次握手).</p>
</li>
<li><p>3 发送HTTP请求<br>浏览器向服务器发送HTTP请求</p>
</li>
<li><p>4 服务器处理请求并返回HTTP报文<br>服务器收到浏览器的请求后返回对应的HTTP报文</p>
</li>
<li><p>5 浏览器解析返回的数据<br>浏览器收到服务器返回的数据后,进行进一步操作(渲染页面等)</p>
</li>
<li><p>6 连接结束<br>释放TCP连接(四次挥手)</p>
</li>
</ul>
<p>其中5 6可以认为是同时发生的.</p>
<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>Cookie</code>是服务器发送给客户端的特殊信息,以文本的形式保存在客户端.当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器,而这一次Cookie信息则存放在HTTP请求头中.服务器接收到后,解析该Cookie,得到客户端特有的信息,动态生成与客户端相对应的内容。服务器还可以根据需要修改Cookie的内容。</p>
<p><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/5.png" alt="Cookie的设置及发送过程"></p>
<ul>
<li>1、首先，客户端会发送一个http请求到服务器端。</li>
<li>2、 服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。</li>
<li>3、在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</li>
</ul>
<p>客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。</p>
<p>Cookie 是可以被客户端禁用的。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session是对于服务端来说的,服务器使用一种类似于散列表的结构来保存信息.当程序需要为某个客户端的请求创建一个Session时,服务器首先检查这个请求是否已包含一个Session标识,称为session id,如果已经包含此session id,说明以前为此客户端创建过session,服务器就根据session id将这个session检索出来进行使用.如果客户端请求没有session id,就会新建一个session,并且生成一个与此session相关的session id,session id将会在本次响应中回发给客户端进行保存.</p>
<p><strong>Session的实现方式</strong></p>
<ul>
<li><p>1.使用Cookie实现.服务器为每个Session提供一个唯一的JSESSIONID,并通过Cookie发送给客户端.当客户端发起新的请求时,将在Cookie头中携带这个JSESSIONID,这样服务器能够找到客户端对应的Session.<br><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/6.png" alt="Session的Cookie实现"></p>
</li>
<li><p>2.使用URL回写来实现.这种方法是指服务器在发送给浏览器页面的所有链接中,都携带JSESSIONID的参数,这样客户端点击任何一个链接都会把JSESSIONID带回服务器,如果直接在地址栏输入URL来请求资源,那么会匹配不到Session.</p>
</li>
</ul>
<p>这两种方式的实现都和JSESSIONID有关.JSESSIONID维护了客户端和服务器之间请求和响应的映射关系.</p>
<h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td>存放位置</td>
<td>客户浏览器</td>
<td>服务器</td>
</tr>
<tr>
<td>安全性</td>
<td>不是很安全</td>
<td>更安全</td>
</tr>
<tr>
<td>服务器压力</td>
<td>对服务器压力小</td>
<td>对服务器压力大</td>
</tr>
</tbody></table>
<p>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。</p>
<p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</p>
<p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<p>建议： 将登陆信息等重要信息存放为session 其他信息如果需要保留，可以放在cookie中</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>Token 也称作令牌，由uid+time+sign[+固定参数]<br>Token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p>
<p>Token和Session有一定的类似，但是服务器不保存状态，而是生成一个Token保存在客户端，这个Token是加密并确保完整性和不变性的，也就是修改后无效的，所以是安全的，可以保存在客户端。</p>
<p>token的组成:<br><code>uid</code>: 用户唯一身份标识<br><code>time</code>: 当前时间的时间戳<br><code>sign</code>: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接<br><code>固定参数(可选)</code>: 将一些常用的固定参数加入到 token 中是为了避免重复查库</p>
<p>Token的认证流程:<br>Token 的认证流程与cookie很相似</p>
<ol>
<li>用户登录，成功后服务器返回Token给客户端</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端再次访问服务器，将token放入headers中</li>
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ol>
<p>对于<code>3</code>,Token可以用url传参，也可以用post提交，也可以夹在http的header中。<br><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/7.png" alt="Token认证流程"></p>
<p>token与session的流程对比:<br><code>session</code>:注册登录-&gt;服务端将user存入session-&gt;将sessionid存入浏览器的cookie-&gt;再次访问时根据cookie里的sessionid找到session里的user<br><code>token</code>:注册登录-&gt;服务端将生成一个token，并将token与user加密生成一个密文-&gt;将token+user+密文数据 返回给浏览器-&gt;再次访问时传递token+user+密文数据，后台会再次使用token+user生成新密文，与传递过来的密文比较，一致则正确。<br>注：上文中得token里保存的用户信息，一般不会包含敏感信息。</p>
<p><strong>Session与Token的异同点</strong></p>
<ul>
<li>Session的状态是存储在服务器端，客户端只有session id,session依赖cookie；而Token的状态是存储在客户端;</li>
<li>Token和Session其实都是为了身份验证，Session一般翻译为会话，而token更多的时候是翻译为令牌；</li>
<li>cookie + session在跨域场景表现并不好</li>
<li>作为身份认证 token 安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。基于 cookie 的机制很容易被 CSRF,Token可以抵抗CSRF</li>
</ul>
<p>注:<br>CSRF（Cross-site request forgery，跨站请求伪造）<br>CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。<br>例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：<br>  <code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容</code><br>那么，我们只需要在论坛中发一帖，包含一链接：<br> <code>http://example.com/bbs/create_post.php?title=你好&amp;content=哈哈</code><br>只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/8.png" alt="HTTP和HTTPS"></p>
<p>HTTPS(超文本传输安全协议) 即 HyperText Transfer Protocol Secure；常称为HTTP over TLS、HTTP over SSL或HTTP Secure，是一种在加密信道进行 HTTP 内容传输的协议。</p>
<blockquote>
<p>TLS 的早期版本叫做 SSL(Security Sockets Layer,安全套接层)。SSL 的 1.0, 2.0, 3.0 版本均已经被废弃，出于安全问题考虑广大浏览器也不再对老旧的 SSL 版本进行支持了，因此这里我们就统一使用 TLS 名称了。</p>
</blockquote>
<ul>
<li>为网络通信提供安全及数据完整性的一种安全协议</li>
<li>是操作系统对外的API</li>
<li>采用<strong>身份认证</strong>和<strong>数据加密</strong>保证网络通信的安全和数据的完整性</li>
</ul>
<p>加密方式:</p>
<ul>
<li>对称加密：加密和解密都使用同一个密钥.该算法性能较非对称加密要高,但是安全性相对较弱.</li>
<li>非对称加密:加密使用的密钥和解密使用的密钥是不相同的.分别称为公钥和私钥,公钥和算法都是公开的,但是私钥是保密的.该算法性能较低,但是安全性强.</li>
<li>哈希算法:将任意长度的信息转换为固定长度的值,算法不可逆.常用的有MD5加密算法.</li>
<li>数字签名:在信息后面加上一段内容,证明某个消息或者文件是某人发出的<br>实际应用中,仅使用其中一种加密方式不能满足生产要求,要么非对称加密性能过低,要么加密密钥容易泄露.因此HTTPS使用证书配合各种加密手段进行加密.</li>
</ul>
<h2 id="TLS的基本过程如下"><a href="#TLS的基本过程如下" class="headerlink" title="TLS的基本过程如下:"></a>TLS的基本过程如下:</h2><p>(参考<a href="https://github.com/skyline75489/what-happens-when-zh_CN#tls">what-happens-when-zh_CN</a>)</p>
<ul>
<li>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</li>
<li>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。</li>
<li>客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信（具体的验证过程在下一节讲解），客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li>
<li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li>
<li>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li>
<li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密</li>
<li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容<br>从上面的过程可以看到，TLS 的完整过程需要三个算法（协议），密钥交互算法，对称加密算法，和消息认证算法（TLS 的传输会使用 MAC(message authentication code) 进行完整性检查）。</li>
</ul>
<p>HTTPS在进行网络传输之前,会与网站服务器和Web浏览器进行一次握手,在握手时确认双方的加密密码信息.<br>概括来说，HTTPS数据传输流程:</p>
<ul>
<li>浏览器将支持的加密算法信息发送给服务器</li>
<li>服务器选择一套浏览器支持的加密算法和哈希算法,将验证身份的信息以证书形式回发给浏览器.证书信息中包含了证书发布的CA机构,证书的有效期,公钥,证书所有者,签名等.</li>
<li>浏览器验证证书合法性,并结合证书公钥加密信息发送给服务器</li>
<li>服务器接收到客户端的信息后,使用私钥解密信息,验证哈希值是否与Web浏览器一致,然后服务器加密响应消息回发给浏览器</li>
<li>最后,浏览器解密响应消息,并对消息进行验真,之后浏览器和服务器进行加密交换数据</li>
</ul>
<p>使用抓包工具可以看到,HTTPS抓取到的数据都是经过加密的,而HTTP的数据是明文.<br><img src="%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE/9.png" alt="HTTPS抓包"></p>
<h2 id="HTTP和HTTPS的区别："><a href="#HTTP和HTTPS的区别：" class="headerlink" title="HTTP和HTTPS的区别："></a>HTTP和HTTPS的区别：</h2><ul>
<li>HTTPS需要到CA申请证书,HTTP不需要</li>
<li>HTTPS密文传输,HTTP明文传输</li>
<li>连接方式不同,HTTPS默认使用443端口,HTTP默认使用80端口</li>
<li>HTTPS=HTTP+加密+认证+完整性保护,较HTTP安全</li>
</ul>
<h2 id="中间人攻击："><a href="#中间人攻击：" class="headerlink" title="中间人攻击："></a>中间人攻击：</h2><p>HTTPS 的过程并不是密不透风的，HTTPS 有若干漏洞，给中间人攻击（Man In The Middle Attack，简称 MITM）提供了可能。</p>
<p>所谓中间人攻击，指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。</p>
<h2 id="HTTPS并不是真的安全"><a href="#HTTPS并不是真的安全" class="headerlink" title="HTTPS并不是真的安全:"></a>HTTPS并不是真的安全:</h2><h3 id="SSL剥离"><a href="#SSL剥离" class="headerlink" title="SSL剥离"></a>SSL剥离</h3><p>SSL 剥离即阻止用户使用 HTTPS 访问网站.浏览器会默认填充<code>http://</code>,请求需要进行跳转,这个访问完全是明文的，这就给了攻击者可乘之机,有被劫持的风险.通过攻击 DNS 响应，攻击者可以将自己变成中间人。</p>
<h3 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h3><p>为了防止上面说的这种情况，一种叫做 <strong>HSTS</strong> 的技术被引入了。HSTS（HTTP Strict Transport Security）是用于强制浏览器使用 HTTPS 访问网站的一种机制。它的基本机制是在服务器返回的响应中，加上一个特殊的头部，指示浏览器对于此网站，强制使用 HTTPS 进行访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Strict-Transport-Security: max-age=31536000; includeSubdomains; preload</span><br></pre></td></tr></table></figure>
<p>可以看到如果这个过期时间非常长，就是导致在很长一段时间内，浏览器都会强制使用 HTTPS 访问该网站。</p>
<p>HSTS 有一个很明显的缺点，是需要等待第一个服务器的影响中的头部才能生效，但如果第一次访问该网站就被攻击呢？为了解决这个问题，浏览器中会带上一些网站的域名，被称为 HSTS preload list。对于在这个 list 的网站来说，直接强制使用 HTTPS。</p>
<h3 id="伪造证书攻击"><a href="#伪造证书攻击" class="headerlink" title="伪造证书攻击"></a>伪造证书攻击</h3><p>HSTS 只解决了 SSL 剥离的问题，然而即使在全程使用 HTTPS 的情况下，我们仍然有可能被监听。</p>
<p>假设我们想访问 <a href="http://www.google.com,但我们的/">www.google.com，但我们的</a> DNS 服务器被攻击了，指向的 IP 地址并非 Google 的服务器，而是攻击者的 IP。当攻击者的服务器也有合法的证书的时候，我们的浏览器就会认为对方是 Google 服务器，从而信任对方。这样，攻击者便可以监听我们和谷歌之前的所有通信了。</p>
<p>可以看到攻击者有两步需要操作，第一步是需要攻击 DNS 服务器。第二步是攻击者自己的证书需要被用户信任，这一步对于用户来说是很难控制的，需要证书颁发机构能够控制自己不滥发证书。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a></p>
<p><a href="https://hit-alibaba.github.io/interview/basic/network/HTTPS.html">https://hit-alibaba.github.io/interview/basic/network/HTTPS.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33781119">https://zhuanlan.zhihu.com/p/33781119</a></p>
<p><a href="http://blog.wizun.cn/2019/02/19/cookie-session/">http://blog.wizun.cn/2019/02/19/cookie-session/</a></p>
<p><a href="https://juejin.im/post/59d1f59bf265da06700b0934">https://juejin.im/post/59d1f59bf265da06700b0934</a></p>
<p><a href="https://segmentfault.com/a/1190000017831088">https://segmentfault.com/a/1190000017831088</a></p>
<p><a href="https://www.zhihu.com/question/51759560/answer/332128488">https://www.zhihu.com/question/51759560/answer/332128488</a></p>
<p><a href="http://www.intelligentunit.com/authorization-with-session-token-principle-and-compare/">http://www.intelligentunit.com/authorization-with-session-token-principle-and-compare/</a></p>
<p><a href="https://blog.csdn.net/qq_35891226/article/details/79931210">https://blog.csdn.net/qq_35891226/article/details/79931210</a></p>
<p><a href="https://juejin.im/post/5a437441f265da43294e54c3">https://juejin.im/post/5a437441f265da43294e54c3</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
