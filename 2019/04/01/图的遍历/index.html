<!DOCTYPE html>
<html lang="zh-Hans">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>图的遍历</title>
  
  <link rel="canonical" href="http://homxuwang.github.io/2019/04/01/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/">
  
  <meta name="description" content="对于图的遍历，和树一样，也有深度优先遍历和广度优先遍历。对于图的深度优先遍历，是从一个点开始，不停的往下试探，知道不能继续为止。但是与树不同的是，图有可能会存在环，所以要记录一下某个点是否已经被遍历过，如果已经被遍历过，则下面的遍历就不需要继续走这个点了。 以下面的数据为例: 深度优先遍历假设从0开">
  
  
  <meta name="author" content="homxuwang">
  
  
  
  <meta property="og:site_name" content="Homxu" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="图的遍历" />
  
  <meta property="og:description" content="对于图的遍历，和树一样，也有深度优先遍历和广度优先遍历。对于图的深度优先遍历，是从一个点开始，不停的往下试探，知道不能继续为止。但是与树不同的是，图有可能会存在环，所以要记录一下某个点是否已经被遍历过，如果已经被遍历过，则下面的遍历就不需要继续走这个点了。 以下面的数据为例: 深度优先遍历假设从0开">
  
  <meta property="og:url" content="http://homxuwang.github.io/2019/04/01/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="图的遍历">
  
  <meta name="twitter:description" content="对于图的遍历，和树一样，也有深度优先遍历和广度优先遍历。对于图的深度优先遍历，是从一个点开始，不停的往下试探，知道不能继续为止。但是与树不同的是，图有可能会存在环，所以要记录一下某个点是否已经被遍历过，如果已经被遍历过，则下面的遍历就不需要继续走这个点了。 以下面的数据为例: 深度优先遍历假设从0开">
  
  
  
  
  <meta name="twitter:url" content="http://homxuwang.github.io/2019/04/01/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="/fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  
  
<link rel="stylesheet" href="/css/user.css">

  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

  
  <script src="/js/pic.min.js" defer></script>
  

  
  <script src="/js/search.min.js" defer></script>
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn">🌑</div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden>☀️</div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Hi July.HX
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        <a href="/">Home</a>
        
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>图的遍历</h2>

  <p>对于图的遍历，和树一样，也有深度优先遍历和广度优先遍历。<br>对于图的深度优先遍历，是从一个点开始，不停的往下试探，知道不能继续为止。但是与树不同的是，图有可能会存在环，所以要记录一下某个点是否已经被遍历过，如果已经被遍历过，则下面的遍历就不需要继续走这个点了。</p>
<p>以下面的数据为例:<br><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/1.png" alt="图"></p>
<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><p>假设从0开始遍历，看与0相连的第一个节点1，节点1没有遍历过所以遍历了1，此时为<code>0 1</code>；<br>接着看和节点1相邻的节点，只有节点0，节点0已经被遍历过了，不用管，此时1没有其他相邻节点了，此时这条路就算走完了，则退回到节点0；<br>然后看0的下一个没有被遍历的节点为节点2,节点2没有被遍历过，所以将2遍历，此时为<code>0 1 2</code>；<br>接着看和节点2相邻的节点，只有节点0，节点0已经被遍历过，退回到节点0；<br>接着看下一个和0相邻的节点，为节点5，没有被遍历过，所以对节点5进行遍历，此时遍历的元素为<code>0 1 2 5</code>；<br>接着看和节点5相邻的节点，第一个节点为节点0，已经被遍历过；第二个节点为节点3，没有被遍历过，所以进行遍历，此时遍历的元素为<code>0 1 2 5 3</code>；<br>接着看和节点3相邻的节点，第一个为节点4，没有被遍历过，所以进行遍历，此时遍历元素为<code>0 1 2 5 3 4</code>；<br>然后看和节点4相邻的节点，节点3和节点5已经被遍历过了，不进行遍历；节点6没有被遍历过，所以进行遍历，此时遍历的元素为<code>0 1 2 5 3 4 6</code>；<br>然后来到节点6，和节点6相邻的节点0和节点4已经被遍历过了，所以不进行遍历；<br>然后退回到节点4，节点4从节点6退回来之后，没有其他节点，节点4的这条路遍历完了，所以从节点4退回到节点3；对于节点3来说，刚才将节点4遍历了，下一个节点5也已经遍历了，节点3这条路遍历完了；所以又从节点3退回到节点5，对于节点5的下一个节点——节点4也已经遍历过了，所以节点5这条路也遍历完了；退回到节点0，节点0的下一个要遍历的节点6已经被遍历过了，所以节点0这条路也已经便利完了；<br>至此，使用深度优先的方式，将所有节点全部遍历了一遍。</p>
<p>整个过程需要记录一下某个节点是否已经被遍历过。</p>
<h2 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h2><p>深度优先遍历的一个典型应用就是求连通分量。</p>
<p>对于一张有三个部分的图，在图论中，这三部分就是连通分量。连通分量之间没有任何边相连。求连通分量只需整体遍历这个图，从某个点开始遍历，先将这个连通分量遍历完；然后再找一个没有被遍历的点，继续遍历，则也可以将第二部分遍历完；最后将剩下的部分进行遍历。</p>
<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/2.png" alt="图"></p>
<p>以求连通分量为例，实现图的深度优先遍历。<br>创建<code>Component.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">bool</span> *visited; <span class="comment">//记录某个节点是否已经被访问过</span></span><br><span class="line">    <span class="keyword">int</span> ccount; <span class="comment">//连通分量个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//加typename指定adjInterator是一个类型而不是一个成员变量</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() ) &#123;<span class="comment">//从adj的第一个开始，只要不到adj的结尾，就进行循环，每次i变为adj的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] ) <span class="comment">//如果没有被访问过，使用递归方法对它继续进行深度优先遍历，</span></span><br><span class="line">                dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Component(Graph &amp;graph): G(graph)&#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        ccount = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">//如果当前的节点没有被访问过的话，就进行深度优先遍历</span></span><br><span class="line">                dfs(i);     <span class="comment">//遍历之后，所有连通的节点都置为true</span></span><br><span class="line">                ccount ++;  <span class="comment">//遍历之后，连通分量+1；然后接着找没有被遍历的节点作为起点进行深度遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Component()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// COMPONENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<p>新建文件<code>testG3.txt</code>，例子中的图表达为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 5</span><br><span class="line">0 6</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>

<p>在main函数中进行测试:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ReadGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Component.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename1 = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">    SparseGraph g1 = SparseGraph(<span class="number">13</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g1, filename1)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;SparseGraph&gt; <span class="title">component1</span><span class="params">(g1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG1.txt, Using Sparse Graph, Component Count: &quot;</span>&lt;&lt;component1.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    DenseGraph g2 = DenseGraph(<span class="number">13</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph2</span><span class="params">(g2, filename1)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;DenseGraph&gt; <span class="title">component2</span><span class="params">(g2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG1.txt, Using Dense Graph, Component Count: &quot;</span>&lt;&lt;component2.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TestG3.txt - g3 and g4</span></span><br><span class="line">    <span class="built_in">string</span> filename2 = <span class="string">&quot;testG2.txt&quot;</span>;</span><br><span class="line">    SparseGraph g3 = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph3</span><span class="params">(g3, filename2)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;SparseGraph&gt; <span class="title">component3</span><span class="params">(g3)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG3.txt, Using Sparse Graph, Component Count: &quot;</span>&lt;&lt;component3.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    DenseGraph g4 = DenseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph4</span><span class="params">(g4, filename2)</span></span>;</span><br><span class="line">    <span class="function">Component&lt;DenseGraph&gt; <span class="title">component4</span><span class="params">(g4)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;TestG3.txt, Using Dense Graph, Component Count: &quot;</span>&lt;&lt;component4.count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/3.png" alt="测试结果"></p>
<p>相应的，如果能求出连通分量，也能求出两个结点之间是否是相连的。对<code>Component.h</code>做出修改:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPONENT_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">bool</span> *visited; <span class="comment">//记录某个节点是否已经被访问过</span></span><br><span class="line">    <span class="keyword">int</span> ccount; <span class="comment">//连通分量个数</span></span><br><span class="line">    <span class="keyword">int</span> *id;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        id[v] = ccount;  <span class="comment">//在进行dfs操作时，将id[v]的值设置为ccount的值，这样不同连通分量部分的顶点其值不同</span></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//加typename指定adjInterator是一个类型而不是一个成员变量</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() ) &#123;<span class="comment">//从adj的第一个开始，只要不到adj的结尾，就进行循环，每次i变为adj的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] ) <span class="comment">//如果没有被访问过，使用递归方法对它继续进行深度优先遍历，</span></span><br><span class="line">                dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Component(Graph &amp;graph): G(graph)&#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        ccount = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            id[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">//如果当前的节点没有被访问过的话，就进行深度优先遍历</span></span><br><span class="line">                dfs(i);     <span class="comment">//遍历之后，所有连通的节点都置为true</span></span><br><span class="line">                ccount ++;  <span class="comment">//遍历之后，连通分量+1；然后接着找没有被遍历的节点作为起点进行深度遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Component()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// COMPONENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<h2 id="获得两点间的一条路径"><a href="#获得两点间的一条路径" class="headerlink" title="获得两点间的一条路径"></a>获得两点间的一条路径</h2><p>使用深度优先的方式，不一定能获得一条最短路径。在<code>Path.h</code>类中新增一个数组<code>from</code>，用来记录每访问一个节点时，该节点是从哪个节点过来的，根据from数组，就可以倒推出两点之间相应的路径。<br><code>Path.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PATH_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">bool</span>* visited;</span><br><span class="line">    <span class="keyword">int</span>* from; <span class="comment">// 记录路径, from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//加typename指定adjInterator是一个类型而不是一个成员变量</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() ) &#123;<span class="comment">//从adj的第一个开始，只要不到adj的结尾，就进行循环，每次i变为adj的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] ) &#123;</span><br><span class="line">                <span class="comment">//如果没有被访问过，使用递归方法对它继续进行深度优先遍历，并将该节点放入from[]数组，说明是从v节点过来的</span></span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 寻路算法, 寻找图graph从s点到其他点的路径</span></span><br><span class="line">    Path(Graph &amp;graph, <span class="keyword">int</span> s):G(graph)&#123;</span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++ )&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻路算法</span></span><br><span class="line">        <span class="comment">// 其实就是进行深度优先遍历的过程中，记录一下</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Path()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点s到w是否有路</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从原点到w的具体路径是什么样的</span></span><br><span class="line">    <span class="comment">//因为是从w节点倒着走，所以先存放在stack中，然后在依次放在vector中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            vec.push_back( s.top() );</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s到w的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">        path(w,vec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; vec.size() ; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PATH_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>main.h</code>中进行测试，打印从0到6的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ReadGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Path.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">&quot;testG3.txt&quot;</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;DFS : &quot;</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/4.png" alt="测试结果"></p>
<h2 id="深度优先遍历的复杂度"><a href="#深度优先遍历的复杂度" class="headerlink" title="深度优先遍历的复杂度"></a>深度优先遍历的复杂度</h2><p>稀疏图（邻接表）:O(V+E)<br>稠密图（邻接矩阵）:O(V^2)</p>
<p>深度优先遍历对有向图依然有效</p>
<h1 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h1><p>广度优先遍历，使用队列进行辅助。<br>还是使用最开始的图进行讲解。<br><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/1.png" alt="图"><br>首先将节点0推入队列中，然后开始遍历过程；（和树的遍历一致，先将根节点推入）(此时队列为<code>0</code>)<br>遍历时，每次遍历都将队列首的元素取出来作为遍历的对象，现在队列首是节点0，将其取出，遍历节点0；(此时队列为空,遍历过的节点有<code>0</code>)<br>然后将所有与节点0相邻的节点，如果还没有加入队列中，就将其加入，所以将节点1，节点2，节点5，节点6加入到队列中，这样就完成了一次操作；(此时队列为<code>1 2 5 6</code>,遍历过的节点有<code>0</code>)<br>接着，将队列首的节点1拿出来作为遍历的对象，节点1就被遍历了，而与节点1相邻的节点只有节点0,0已经遍历过；所以继续将节点2从队列首拿出来，作为遍历的对象，而节点2相邻的节点也只有节点0,不用管；(此时队列为<code>5 6</code>，遍历过的节点有<code>0 1 2</code>)<br>接着将队列首的节点5拿出来，作为遍历的对象，对于节点5，它相邻的节点有节点0，节点3，节点4，节点0已经加入过队列并遍历完，所以将节点3，节点4加入到队列中；(此时队列为<code>6 3 4</code>，遍历过的节点有<code>0 1 2 5</code>)<br>继续将队列首的节点6拿出来，作为遍历的对象，节点6的相邻节点有节点0和节点4，需要注意节点0已经被遍历过不需要管，节点4虽然没有被遍历过，但是它已经被加入到队列中（所以在代码实现时，注意需要对加入到队列中的元素进行标记，因为一旦被加入到队列，那么它一定会被遍历），所以这次遍历就算完成;(此时队列为<code>3 4</code>,遍历过的节点有<code>0 1 2 5 6</code>)<br>接着将队列首的节点3拿出来进行遍历，节点3相邻的节点有节点4和节点5，节点5和节点4都已经被加入过队列，这次遍历结束；(此时队列为<code>4</code>，遍历过的节点有<code>0 1 2 5 6 3</code>)<br>最后将队列首的节点4拿出来进行遍历，对于节点4相邻的节点3，节点5，节点6都已经加入过队列，所以这次遍历结束。<br>至此，队列为空，广度优先遍历结束。</p>
<p>其实广度优先遍历，是以距起始节点的距离为顺序进行遍历的。<br>首先0节点自己到自己的距离为0，然后与节点0所有相邻的节点1、2、5、6被推进队列，它们距节点0的距离都为1；<br>接着将节点3,4推入到队列，它们距节点0的距离都为2。<br>所以广度优先遍历有时候也成为层序优先遍历，以遍历的起点开始，一层层的往下推，先遍历的节点距离起始节点近（更严谨的说法是先遍历的节点到起始节点的距离是小于等于后遍历的节点的，比如先遍历节点1后遍历节点6，但是它们到节点0 的距离都是1）。<br>利用这种方法，可以在程序中记录这个距离。在无权图中记录到起始节点的距离，不仅如此，如果像深度优先遍历，同时用<code>from[]</code>记录每一个节点是从哪一个节点过来，还可以将最短路径同时求出来。所以，广度优先遍历的一个应用就是求出<code>无权图</code>的最短路径(这里注意是无权图，但是不局限于有向图还是无向图)。</p>
<p>新建<code>ShortestPath.h</code>类:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHORTESTPATH_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHORTESTPATH_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">bool</span> *visited;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">int</span> *from;  <span class="comment">// 记录路径, from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line">    <span class="keyword">int</span> *ord; <span class="comment">//记录s到每一个节点的距离是多少，即记录路径中节点的次序。ord[i]表示i节点在路径中的次序。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ShortestPath( Graph &amp;graph, <span class="keyword">int</span> s):G(graph)&#123;</span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        assert( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; graph.V() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; graph.V() ; i++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">            ord[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 无向图最短路径算法, 从s开始广度优先遍历整张图</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(s); <span class="comment">//首先向队列中推入原点s</span></span><br><span class="line">        visited[s] = <span class="literal">true</span>; <span class="comment">//标记s已经被访问</span></span><br><span class="line">        ord[s] = <span class="number">0</span>; <span class="comment">//标记原点到自己的距离为0</span></span><br><span class="line">        <span class="keyword">while</span>( !q.empty() )&#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.front(); <span class="comment">//将队列首的元素取出</span></span><br><span class="line">            q.pop(); <span class="comment">//队列首的元素出队</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,v)</span></span>;   <span class="comment">//遍历与队列首元素v所有相邻的元素</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = adj.begin() ; !adj.end() ; i = adj.next() )&#123;</span><br><span class="line">                <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">//查看i元素是不是已经被访问过，即是否已经被加入过队列，如果没有的话</span></span><br><span class="line">                    q.push(i); <span class="comment">//把i加入到队列中</span></span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                    from[i] = v; <span class="comment">//是从v节点走到i的</span></span><br><span class="line">                    ord[i] = ord[v] + <span class="number">1</span>; <span class="comment">//从过来的节点的距离+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~ShortestPath()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] from;</span><br><span class="line">        <span class="keyword">delete</span>[] ord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V());</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            vec.push_back( s.top() );</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w,vec);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; vec.size() ; i ++ )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size() - <span class="number">1</span> )</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHORTESTPATH_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<p>使用main函数测试:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SparseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DenseGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ReadGraph.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Path.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ShortestPath.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">&quot;testG3.txt&quot;</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;DFS : &quot;</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">ShortestPath&lt;SparseGraph&gt; <span class="title">bfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;BFS : &quot;</span>;</span><br><span class="line">    bfs.showPath(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/5.png" alt="测试结果"></p>
<p>使用深度优先遍历有可能会找到最短路径，这与图的创建、具体的存储顺序有关；但是使用广度优先遍历，一定能够找到两个连通点的最短路径。此外，在这个图中，如果求0到4的最短路径，有可能取出<code>0-&gt;6-&gt;4</code>或者<code>0-&gt;5-&gt;4</code>，这与在图中遍历的顺序是怎样的有关。</p>
<h2 id="广度优先遍历的复杂度"><a href="#广度优先遍历的复杂度" class="headerlink" title="广度优先遍历的复杂度"></a>广度优先遍历的复杂度</h2><p>广度优先遍历的复杂度和深度优先遍历的复杂度是一样的:</p>
<p>稀疏图（邻接表）:O(V+E)<br>稠密图（邻接矩阵）:O(V^2)</p>
<h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/6.png" alt="程序结构"></p>
<p>其中几个主要的类实现参考<br><a href="https://homxuwang.github.io/2019/03/29/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/">图论基础</a></p>
<p><code>Path.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Graph G; <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;  <span class="comment">//起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited; <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] from;  <span class="comment">// 记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">( <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i : G.adj(v) )&#123; <span class="comment">// 遍历所有v的相邻点</span></span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123; <span class="comment">// 如果没有被遍历过</span></span><br><span class="line">                from[i] = v;   <span class="comment">//将v加入到路径数组</span></span><br><span class="line">                dfs(i);     <span class="comment">//递归进行遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 寻路算法, 寻找图graph从s点到其他点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Path</span><span class="params">(Graph graph , <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">if</span>(!(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that s &gt;= 0 and s &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻路算法</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that w &gt;= 0 and w &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点的路径,存放在vec中</span></span><br><span class="line">    <span class="function">Vector&lt;Integer&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(hasPath(w)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过from数组逆向查找从s到w的路径，存放到栈中</span></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span> (p != -<span class="number">1</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈中取出元素，获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Integer&gt; res = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            res.add( s.pop() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasPath(w))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = path(w);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.size() ; i++)&#123;</span><br><span class="line">            System.out.print(vec.elementAt(i));</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size() - <span class="number">1</span> )</span><br><span class="line">                System.out.println();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ShortestPath.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Graph G; <span class="comment">//图的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;  <span class="comment">//起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited; <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] from; <span class="comment">//记录路径，from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ord;  <span class="comment">//记录路径中节点的次序，ord[i]表示i节点在路径中的次序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，寻路算法，寻找图graph从s点到其他点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShortestPath</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">if</span>(!(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that s &gt;= 0 and s &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            from[i] = -<span class="number">1</span>;</span><br><span class="line">            ord[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无向图最短路径算法，s开始广度优先遍历整张图</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        q.add(s);</span><br><span class="line">        visited[s] = <span class="keyword">true</span>;</span><br><span class="line">        ord[s] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : G.adj(v))</span><br><span class="line">                <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                    q.add(i);</span><br><span class="line">                    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                    from[i] = v;</span><br><span class="line">                    ord[i] = ord[v] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that w &gt;= 0 and w &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从s点到w点的路径，存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector&lt;Integer&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(hasPath(w)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过from数组逆向查找从s到w的路径,存放在栈中</span></span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>(p != -<span class="number">1</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从栈中一次取出元素,获得顺序的从s到w的路径</span></span><br><span class="line">        Vector&lt;Integer&gt; res = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line">            res.add(s.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出从s到w的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(hasPath(w)))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no path between s and w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vec = path(w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.size() ; i ++)&#123;</span><br><span class="line">            System.out.print(vec.elementAt(i));</span><br><span class="line">            <span class="keyword">if</span>(i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                System.out.println();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="comment">//若从s到w不可达，则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() ))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;make sure that w &gt;= 0 and w &lt; G.V()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>testG3.txt</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 5</span><br><span class="line">0 6</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>

<p><code>Main.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG3.txt&quot;</span>;</span><br><span class="line">        SparseGraph g = <span class="keyword">new</span> SparseGraph(<span class="number">7</span>,<span class="keyword">false</span>);</span><br><span class="line">        ReadGraph readGraph = <span class="keyword">new</span> ReadGraph(g,filename);</span><br><span class="line">        g.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较使用深度优先遍历和广度优先遍历获得路径的不同</span></span><br><span class="line">        <span class="comment">//广度优先遍历获得的是无权图的最短路径</span></span><br><span class="line">        Path dfs = <span class="keyword">new</span> Path(g,<span class="number">0</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;DFS: &quot;</span>);</span><br><span class="line">        dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        ShortestPath bfs = <span class="keyword">new</span> ShortestPath(g,<span class="number">0</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;BFS: &quot;</span>);</span><br><span class="line">        bfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验结果:</p>
<p><img src="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/7.png" alt="实验结果"></p>

  <p><a class="classtest-link" href="/tags/%E5%9B%BE/" rel="tag">图</a>, <a class="classtest-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a> — Apr 1, 2019</p>
  


        </div>
        <div class="row mt-2">
  <h3>Search</h3>
  <div><input id="search-text" title="search" class="search-text" type="text" placeholder="search......"></div>
  <div style="margin-top: 1.5rem;">
    <ul id="result"></ul>
  </div>
</div>
        <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
        at <a href="https://en.wikipedia.org/wiki/Earth" target="_blank" rel="noreferrer">Earth</a>.</p>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/homxuwang" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      

      

      

      

    </div>
  
</div>

      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>

  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>