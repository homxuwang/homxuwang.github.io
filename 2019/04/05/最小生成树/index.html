<!DOCTYPE html>
<html lang="zh-Hans">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>最小生成树</title>
  
  <link rel="canonical" href="http://homxuwang.github.io/2019/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">
  
  <meta name="description" content="有权图有权图是指在无权图的基础上，每一条边都有一个数值，代表两个结点之间有一定的数值关系，比如图用来表示路网时，权值可以表示两点之间的距离，到达彼此所需要的时间等。 有权图的邻接矩阵表达见下图:  有权图的邻接表表达见下图:s 邻接表每个节点后面存储两个信息:to表示和它相邻的节点的索引，w表示对应">
  
  
  <meta name="author" content="homxuwang">
  
  
  
  <meta property="og:site_name" content="Homxu" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="最小生成树" />
  
  <meta property="og:description" content="有权图有权图是指在无权图的基础上，每一条边都有一个数值，代表两个结点之间有一定的数值关系，比如图用来表示路网时，权值可以表示两点之间的距离，到达彼此所需要的时间等。 有权图的邻接矩阵表达见下图:  有权图的邻接表表达见下图:s 邻接表每个节点后面存储两个信息:to表示和它相邻的节点的索引，w表示对应">
  
  <meta property="og:url" content="http://homxuwang.github.io/2019/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="最小生成树">
  
  <meta name="twitter:description" content="有权图有权图是指在无权图的基础上，每一条边都有一个数值，代表两个结点之间有一定的数值关系，比如图用来表示路网时，权值可以表示两点之间的距离，到达彼此所需要的时间等。 有权图的邻接矩阵表达见下图:  有权图的邻接表表达见下图:s 邻接表每个节点后面存储两个信息:to表示和它相邻的节点的索引，w表示对应">
  
  
  
  
  <meta name="twitter:url" content="http://homxuwang.github.io/2019/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="/fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  
  
<link rel="stylesheet" href="/css/user.css">

  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

  
  <script src="/js/pic.min.js" defer></script>
  

  
  <script src="/js/search.min.js" defer></script>
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn">🌑</div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden>☀️</div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Hi July.HX
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        <a href="/">Home</a>
        
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>最小生成树</h2>

  <h1 id="有权图"><a href="#有权图" class="headerlink" title="有权图"></a>有权图</h1><p>有权图是指在无权图的基础上，每一条边都有一个数值，代表两个结点之间有一定的数值关系，比如图用来表示路网时，权值可以表示两点之间的距离，到达彼此所需要的时间等。</p>
<p>有权图的邻接矩阵表达见下图:</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/1.png" alt="邻接矩阵"></p>
<p>有权图的邻接表表达见下图:<br>s<br><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/2.png" alt="邻接表"></p>
<p>邻接表每个节点后面存储两个信息:<code>to</code>表示和它相邻的节点的索引，<code>w</code>表示对应的边的权值.所以可以将这两个信息封装为<code>Edge</code>属性，它包含to和w属性。</p>
<p>当然要注意一点，邻接矩阵中依然用了传统的二维数组来存储，为了统一图的接口，也可以将a[i][j]位置存储为<code>Edge</code>格式。</p>
<p>这里就直接先写java代码了</p>
<p>创建<code>WeightedGraph.java</code>接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeightedGraph</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>;  <span class="comment">//获取图的顶点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>;  <span class="comment">//获取图的边数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge&lt;Weight&gt; e)</span></span>; <span class="comment">//在v和w两个顶点间添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">( <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span>;<span class="comment">//查看v和w两个顶点间是否有边</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//打印图</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Edge&lt;Weight&gt;&gt; adj(<span class="keyword">int</span> v); <span class="comment">//获取与v顶点连接的所有边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现有权图，先编写一个<code>Edge.java</code>类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a,b; <span class="comment">//边的两个端点</span></span><br><span class="line">    <span class="keyword">private</span> Weight weight; <span class="comment">//边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b , Weight weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a ;</span><br><span class="line">        <span class="keyword">this</span>.b = b ;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Edge&lt;Weight&gt; e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = e.a;</span><br><span class="line">        <span class="keyword">this</span>.b = e.b;</span><br><span class="line">        <span class="keyword">this</span>.weight = e.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">v</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a;&#125; <span class="comment">//返回第一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">w</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> b;&#125; <span class="comment">//返回第二个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weight <span class="title">wt</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> weight;&#125; <span class="comment">// 返回权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给定一个顶点，返回另一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x == a || x == b)&#123;</span><br><span class="line">            <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;x is not correct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出边的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + a + <span class="string">&quot;-&quot;</span> + b + <span class="string">&quot;: &quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(weight.compareTo(that.wt()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(weight.compareTo(that.wt()) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>DenseGraph.java</code>的基础上修改，创建<code>DenseGraph.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DenseWeightedGraph</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">WeightedGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> directed; <span class="comment">// 是否为有向图</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[][] g; <span class="comment">//图的具体数据，用二维数组表达</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DenseWeightedGraph</span><span class="params">( <span class="keyword">int</span> n , <span class="keyword">boolean</span> directed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of n should be &gt;= 0.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="number">0</span> ;<span class="comment">//初始化时没有任何边</span></span><br><span class="line">        <span class="keyword">this</span>.directed = directed;</span><br><span class="line">        <span class="comment">// g初始化为n*n的布尔矩阵, 每一个g[i][j]均为null, 表示没有任和边</span></span><br><span class="line">        <span class="comment">// false为boolean型变量的默认值</span></span><br><span class="line">        g = <span class="keyword">new</span> Edge[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ;j ++)</span><br><span class="line">                g[i][j] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(e.v() &gt;= <span class="number">0</span> &amp;&amp; e.v() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;you should type v &gt;= 0 &amp;&amp; v &lt; n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(e.w() &gt;= <span class="number">0</span> &amp;&amp; e.w() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;you should type w &gt;= 0 &amp;&amp; w &lt; n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasEdge(e.v(),e.w()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        g[e.v()][e.w()] = <span class="keyword">new</span> Edge(e);</span><br><span class="line">        <span class="keyword">if</span>(e.v() != e.w() &amp;&amp; !directed)</span><br><span class="line">            g[e.w()][e.v()] = <span class="keyword">new</span> Edge(e.w(),e.v(),e.wt());</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断图中是否有v到w的边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[v][w] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印显示图的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++)</span><br><span class="line">               <span class="keyword">if</span>( g[i][j] != <span class="keyword">null</span>)</span><br><span class="line">                   System.out.println(g[i][j].wt()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;NULL\t&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回图中v顶点的所有邻边</span></span><br><span class="line">    <span class="comment">//由于java使用引用机制，返回一个Vector不会带来额外开销</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Edge&lt;Weight&gt;&gt; adj(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        Vector&lt;Edge&lt;Weight&gt;&gt; adjV = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(g[v][i] != <span class="keyword">null</span>)</span><br><span class="line">                adjV.add(g[v][i]);</span><br><span class="line">        <span class="keyword">return</span> adjV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的修改<code>SparseGraph.java</code>后得到<code>SparseWeightedGraph.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseWeightedGraph</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; <span class="keyword">implements</span> <span class="title">WeightedGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; <span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> directed; <span class="comment">//是否为有向图</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt;[] g; <span class="comment">//图的具体数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SparseWeightedGraph</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">boolean</span> directed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of n should be &gt;= 0.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.directed = directed;</span><br><span class="line">        <span class="comment">//g初始化为n个空的vector,表示每一个g[i]都为空，即没有任何边</span></span><br><span class="line">        g = (Vector&lt;Edge&lt;Weight&gt;&gt;[]) <span class="keyword">new</span> Vector[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">            g[i] = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(e.v() &gt;= <span class="number">0</span> &amp;&amp; e.v() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(e.w() &gt;= <span class="number">0</span> &amp;&amp; e.w() &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        g[e.v()].add(<span class="keyword">new</span> Edge&lt;&gt;(e));</span><br><span class="line">        <span class="keyword">if</span>(e.v() != e.w() &amp;&amp; !directed) <span class="comment">//如果不是自环边，并且它是无向图，则创建w到v的边</span></span><br><span class="line">            g[e.w()].add(<span class="keyword">new</span> Edge(e.w(),e.v(),e.wt()));</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证图中是否有v到w的边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; g[v].size() ; i++)</span><br><span class="line">            <span class="keyword">if</span>( g[v].elementAt(i).other(v) == w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图的信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;vertex %d :\t&quot;</span>,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; g[i].size() ; j++)&#123;</span><br><span class="line">                Edge e = g[i].elementAt(j);</span><br><span class="line">                System.out.print(<span class="string">&quot;( to:&quot;</span> + e.other(i) + <span class="string">&quot;,wt:&quot;</span> + e.wt() + <span class="string">&quot;)\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中一个顶点的所有邻边</span></span><br><span class="line">    <span class="comment">// 由于java使用引用机制，返回一个Vector不会带来额外开销,</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Edge&lt;Weight&gt;&gt; adj(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>ReadGraph.java</code>后得到<code>ReadWeightedGraph</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWeightedGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Scanner scanner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWeightedGraph</span><span class="params">(WeightedGraph&lt;Double&gt; graph , String filename)</span></span>&#123;</span><br><span class="line">        readFile(filename);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> V = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(V &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;number of vertices in a Graph must be nonnegative&quot;</span>);</span><br><span class="line">            <span class="keyword">assert</span> V == graph.V();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> E = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(E &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;number of edges in a Graph must be nonnegative&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; E ; i ++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v = scanner.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = scanner.nextInt();</span><br><span class="line">                Double weight = scanner.nextDouble();  <span class="comment">//读取权值</span></span><br><span class="line">                <span class="keyword">if</span>(!(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; V))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of v is Illegal!you should type the value of v between 0 and n.(v &gt;=0 &amp;&amp; v &lt; n).&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(!(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; V))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of w is Illegal!you should type the value of w between 0 and n.(w &gt;=0 &amp;&amp; w &lt; n).&quot;</span>);</span><br><span class="line"></span><br><span class="line">                graph.addEdge(<span class="keyword">new</span> Edge&lt;Double&gt;(v,w,weight) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">            String token = scanner.next();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException(<span class="string">&quot;attempts to read an &#x27;int&#x27; value from input stream,but the next token is \&quot;&quot;</span>+token +<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NoSuchElementException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;attemps to read an &#x27;int&#x27; value from input stream, but there are no more tokens available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(filename == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;filename should not be null!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(fis), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                scanner.useLocale(Locale.ENGLISH);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(filename + <span class="string">&quot;doesn&#x27;t exists.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Could not open &quot;</span> + filename,ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试文件<code>testG1.txt</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">8 16</span><br><span class="line">4 5 .35</span><br><span class="line">4 7 .37</span><br><span class="line">5 7 .28</span><br><span class="line">0 7 .16</span><br><span class="line">1 5 .32</span><br><span class="line">0 4 .38</span><br><span class="line">2 3 .17</span><br><span class="line">1 7 .19</span><br><span class="line">0 2 .26</span><br><span class="line">1 2 .36</span><br><span class="line">1 3 .29</span><br><span class="line">2 7 .34</span><br><span class="line">6 2 .40</span><br><span class="line">3 6 .52</span><br><span class="line">6 0 .58</span><br><span class="line">6 4 .93</span><br></pre></td></tr></table></figure>

<p>在<code>Main.java</code>中进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试通过文件读取图的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用两种图的存储方式读取testG1.txt文件</span></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g1 = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(<span class="number">8</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph1 = <span class="keyword">new</span> ReadWeightedGraph(g1, filename);</span><br><span class="line">        System.out.println(<span class="string">&quot;test G1 in Sparse Weighted Graph:&quot;</span>);</span><br><span class="line">        g1.show();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        DenseWeightedGraph&lt;Double&gt; g2 = <span class="keyword">new</span> DenseWeightedGraph&lt;Double&gt;(<span class="number">8</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph2 = <span class="keyword">new</span> ReadWeightedGraph(g2 , filename );</span><br><span class="line">        System.out.println(<span class="string">&quot;test G1 in Dense Graph:&quot;</span>);</span><br><span class="line">        g2.show();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/3.png" alt="测试结果"></p>
<h1 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h1><p>算法（第四版）中的定义：<br>最小生成树。给定一个加权无向图，找到它的一棵最小生成树（Minimum Span Tree）。</p>
<p>如果一个图有v个节点，那么就应该有v-1条边连接这V个节点，这就是这个图的生成树。不仅如此，这v-1条边连接了所有的v个节点，这v-1条边的权值相加也是最小的，如何找到这个生成树，就是最小生成树问题。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/4.png" alt="最小生成树"></p>
<h2 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h2><p>这里在计算最小生成树的过程中会出现各种特殊情况，所以为了行文流畅，进行约定：</p>
<ul>
<li>只考虑连通图</li>
<li>针对带权无向图</li>
<li>所有边的权重都各不相同</li>
</ul>
<p>所以在进行最小生成树相关算法的过程中要找V-1条边，连接V个顶点使得其总权值最小。</p>
<h2 id="切分定理-Cut-Property"><a href="#切分定理-Cut-Property" class="headerlink" title="切分定理 - Cut Property"></a>切分定理 - Cut Property</h2><p>把图中的结点分为两个部分，成为一个<code>切分(Cut)</code>.</p>
<p>如下图就是一个切分:</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/5.png" alt="切分"></p>
<p>如果一个边的两个端点，属于<code>切分(Cut)</code>不同的两边，这个边称为<code>横切边(Crossing Edge)</code>.</p>
<p>如下图的蓝色线条就是横切边:</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/6.png" alt="横切边"></p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/7.png" alt="横切边"></p>
<p><code>切分定理</code>的定义：<br>在一副加权图中，给定<code>任意</code>切分，横切边中权值最小的边必然属于图的最小生成树。</p>
<p>例如上图中的权重为0.4的边肯定是最小生成树的一条边:<br><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/8.png" alt="横切边"></p>
<p>算法(第四版)中的证明:</p>
<blockquote>
<p>今e为权重最小的横切边，T为图的最小生成树。我们采用反证法:假设T不包含e。那么如果将e加入T，得到的图必然含有一条经过e的环，且这个环至少含有另一条横切边——设为f，f的权重必然大于e(因为e的权重是最小的且图中所有边的权重均不同)。那么我们删掉f而保留e就可以得到一棵权重更小的生成树。这和我们的假设T矛盾。</p>
</blockquote>
<blockquote>
<p>在假设所有的边的权重均不相同的前提下，每幅连通图都只有一棵唯一的最小生成树，切分定理也表明了对于每一种切分，权重最小的横切边必然属于最小生成树。</p>
</blockquote>
<blockquote>
<p>切分定理是解决最小生成树问题的所有算法的基础。更确切的说，这些算法都是一种贪心算法的特殊情况:使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。这些算法相互之间的不同之处在于保存切分和判定权重最小的横切边的方式。</p>
</blockquote>
<h2 id="Lazy-Prim算法"><a href="#Lazy-Prim算法" class="headerlink" title="Lazy Prim算法"></a>Lazy Prim算法</h2><p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/9.png" alt="Lazy-Prim"></p>
<p>首先将一个起始节点作为切分的一部分，这里从0节点开始。将0节点作为切分的一部分，剩下的节点作为切分的另一部分。每一次找到横切边中权值最小的边。这里可以使用最小堆，将横切边放入最小堆中，作为最小生成树所包含的边的候选。这些边进入堆后，下一步只需拿出最小堆中的最短边就可以了。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/10.png" alt="第一步的横切边"></p>
<p>这一步找出的是<code>0-7:0.16</code>权值为0.16的边，它一定属于最小生成树。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/11.png" alt="第一步的最小边"></p>
<p>第二步，确定了<code>0-7</code>这条边为最小生成树的一条边，而结点7没有被访问过，此时就可以将结点7加入到红色节点部分，这样就形成了一个新的切分。这个新的切分就和另一部分切分形成了新的横切边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/12.png" alt="第二步的横切边"></p>
<p>然后将这些新的横切边推入最小堆，然后在最小堆中选出权值最小的边<code>1-7:0.19</code>。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/13.png" alt="第二步的最小边"></p>
<p>第三步，确定了<code>1-7</code>为最小生成树的一条边，而节点1没有被访问过，此时将结点1加入到红色结点部分，这样又形成了一个新的切分。也相应的和另一部分切分形成了新的横切边。将这些新的横切边加入到最小堆。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/14.png" alt="第三步的横切边"></p>
<p>接着看在候选的横切边中，最短的边为<code>0-2:0.26</code>的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/15.png" alt="第三步的最小边"></p>
<p>第四步，确定了<code>0-2</code>为最小生成树的一条边，而结点2没有被访问过，所以将结点2加入红色结点部分，这样就又形成一个新的切分。又有新的边成为了横切边。将他们加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/16.png" alt="第四步的横切边"></p>
<p>此时需要注意，将结点2加入到红色部分后，最小堆中蓝色的部分中，边<code>2-7:0.34</code>和边<code>1-2:0.36</code>，实际上已经不是横切边了，所以这两条边不应该成为最小生成树的边的候选了。所以这里体现出<code>Lazy Prim</code>算法的”懒惰”性，当前这两条边虽然不可能成为最小生成树的候选边，但是这里不需要着急将其剔除，先将其保留在最小堆中，当拿出这两条边时，发现这两条边不是横切边时，再将这两条边剔除。</p>
<p>接着在最小堆中寻找最小的边，最短边为<code>2-3:0.17</code>的边.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/17.png" alt="第四步的最小边"></p>
<p>第五步，确定了<code>2-3</code>为最小生成树的一条边，而结点3没有被访问过，所以将结点3加入到红色结点部分，形成新的切分后，将新的横切边加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/18.png" alt="第五步的横切边"></p>
<p>接着最小堆中的最小边应该是<code>5-7:0.28</code>的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/19.png" alt="第五步的最小边"></p>
<p>第六步，确定了<code>5-7</code>为最小生成树的一条边，而结点5没有被访问过，所以将结点5加入到红色部分，形成新的切分并将新的横切边加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/20.png" alt="第六步的横切边"></p>
<p>接着看在最小堆中，最小的边为<code>1-3:0.29</code>的边，当将其拿出后发现，结点1和结点3都是红色的结点，即这条边不是一条横切边（只有横切边中的最小边才是最小生成树的边），所以将其拿出后剔除。接着看在最小堆中的最短边为<code>1-5:0.32</code>的边，拿出后发现结点1和结点5都是红色的结点，所以也要将其剔除。接着看剩下的最小堆中的最短边为<code>2-7:0.34</code>，也不满足横切边的性质，剔除。<br>接着看剩下的最小堆中的最短边为<code>4-5:0.35</code>，满足横切边的性质，所以将这条边作为最小生成树的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/21.png" alt="第六步的最小边"></p>
<p>第七步，确定了<code>5-4</code>为最小生成树的一条边，由于结点4没有被访问过，所以将结点4加入到红色部分，行成新的切分并将新的横切边<code>4-6:0.93</code>加入到最小堆中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/22.png" alt="第七步的横切边"></p>
<p>然后在最小堆中找最短的边，为<code>1-2:0.36</code>这条边，但是它不是横切边，将其剔除。接着最小堆中最短的边为<code>4-7:0.37</code>，它不是横切边，将其剔除。继续找最小堆中最短边为<code>0-4:0.38</code>，不是横切边，将其剔除。<br>继续找最小堆中的最短边为<code>2-6:0.40</code>，它是横切边，将其作为最小生成树的边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/23.png" alt="第七步的最小边"></p>
<p>由于结点6没有被访问过，将其加入到红色部分。这时所有节点都在红色部分，程序至此就可以结束。</p>
<p>如果以最小堆中的边为空作为判断依据的话，那么依然可以拿出最小堆中的最小边进行判断，此时所有的边都不是横切边，将剩下的边判断完后，程序结束。</p>
<p>此时就用<code>Lazy Prim</code>算法获得了最小生成树。</p>
<h2 id="Lazy-Prim算法代码"><a href="#Lazy-Prim算法代码" class="headerlink" title="Lazy Prim算法代码"></a>Lazy Prim算法代码</h2><p>见附录1</p>
<h2 id="Prim算法的优化"><a href="#Prim算法的优化" class="headerlink" title="Prim算法的优化"></a>Prim算法的优化</h2><p><code>pq.extractMin()</code>操作的时间复杂度为O(logE),因为pq中最多承载E条边。<br><code>visit()</code>操作时，遍历节点的所有临边，合在一起也是O(E)，如果是邻接矩阵就是O(V^2)，在稠密图的邻接矩阵中O(V^2)和O(E)是一个级别的。同时其中有个<code>add()</code>操作，它是O(logE)级别的。</p>
<p>所以，<code>Lazy Prim</code>算法的时间复杂度为O(ElogE).</p>
<p>通过优化，<code>Prim</code>算法的时间复杂度可以改进为O(ElogV).</p>
<p><code>Lazy Prim</code>算法的一个问题就是，所有的边都要进入最小堆，随着切分的进行，很多已经不是横切边的边仍在最小堆中。另一问题是，虽然有很多横切边，但我们只关注最短的那个横切边，尤其是和一个节点相连的很多横切边，其实只需考虑和这个点相连的最短的横切边就可以了。</p>
<p>基于这个思想，需要维护一个数据结构——存储和每个节点相连的那个最短的横切边。在不断增加红色节点改变切分的过程中，只要不断更新和每个节点相连的最短的横切边就可以了。即这个数据结构要满足：①它能取到最小值②能够供我们更新。所以需要使用<code>IndexMinHeap</code>.</p>
<p>第一步:<br>以0作为起点开始，由于最小生成树有V-1个边，而IndexMinHeap有V个空间，所以肯定有一个节点不需要存储任何东西。就将初始结点作为不需要存储东西的节点。此时有了初始节点后，相当于有了切分，这时，这个节点的所有临边都是横切边，这种情况下，就将这些横切边加入到IndexMinHeap中。<br>此时，和2相连的横切边，最小权值是0.26;和4相连的横切边，最小权值是0.38;和6相连的横切边，最小权值是0.58;和7相连的横切边，最小权值是0.16.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/25.png" alt="Prim第一步-1"></p>
<p>这时，从IndexMinHeap中找出权值最小的一条边，根据切分定理，一定是最小生成树的边，即0.16这条边。这时节点7加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/26.png" alt="Prim第一步-2"></p>
<p>第二步，由于结点7加入了红色部分。要考虑更多的横切边，这时遍历结点7的临边。先看<code>1-7</code>，此时IndexMinHeap中没有和1相连的横切边权值最小的边，所以IndexMinHeap中1的值更新为0.19;再看<code>2-7</code>，其值为0.34，而IndexMinHeap中和2相连的横切边权值最小的是<code>0-2:0.26</code>，所以<code>2-7</code>肯定不会是最小生成树中的一条边，可以直接剔除；接着看<code>4-7</code>，这个边的权值为0.37,它小于当前IndexMinHeap中存储的0.38，所以将<code>4-7:0.37</code>更新到最小索引堆中，与此同时，意味着将<code>0-4:0.38</code>这条边丢弃，因为这条边不可能会是最小生成树的边;最后，看<code>5-7</code>，这个边的权值为0.28，当前IndexMinHeap和5相连的边还没有，所以将其放入IndexMinHeap索引为5的位置中。这时候就完成了<code>visit(7)</code>操作。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/27.png" alt="Prim第二步-1"></p>
<p>然后从最小索引堆IndexMinHeap中找出权值最小的边，即和1相连的<code>1-7:0.19</code>这条边，可以确定它属于最小生成树。因此结点1也可以加入红色部分</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/28.png" alt="Prim第二步-2"></p>
<p>第三步，看和结点1相邻的所有边。首先是<code>1-2:0.36</code>，在IndexMinHeap中索引为2的位置其值为0.26，所以<code>1-2</code>不是最小生成树的边；接着看<code>1-5:0.32</code>，但是在IndexMinHeap中和5相连的横切边最小的值为0.28，所以它也不是最小生成树的边;最后看<code>1-3:0.29</code>，由于IndexMinHeap中没有和3相连的横切边，将其放入IndexMinHeap中。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/29.png" alt="Prim第三步-1"></p>
<p>然后从最小索引堆中找出权值最小的边，即和2相连的<code>0-2:0.26</code>这条边，可以确定它属于最小生成树。与此同时结点2加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/30.png" alt="Prim第三步-2"></p>
<p>第四步，看和结点2相邻的所有边。这里注意<code>2-7</code>和<code>1-2</code>不是横切边，所以不用再看了；然后看<code>2-3:0.17</code>，此时最小索引堆中索引为3的位置的值为0.29，所以将其更新为0.17,同时0.29这条边可以剔除不在考虑;接着看<code>2-6:0.40</code>，此时最小索引堆中的索引为6的位置的值为0.58，所以将其更新为0.40，同时0.58这条边可以剔除不在考虑了.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/31.png" alt="Prim第四步-1"></p>
<p>然后从最小索引堆中取出权值最小的边，即和3相连的0.17这条边，根据切分定理，其一定属于最小生成树。同时，将接点3加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/32.png" alt="Prim第四步-2"></p>
<p>第五步，看和接点3相邻的所有边。<code>1-3</code>不是横切边，所以不用看；剩下一条<code>3-6:0.52</code>,其值0.52大于最小索引堆索引为6处的0.40，所以这条边剔除不再考虑。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/33.png" alt="Prim第五步-1"></p>
<p>然后从最小索引堆中找出权值最小的边，即和5相连的0.28这条边，它一定是最小生成树的边。同时将结点5加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/34.png" alt="Prim第五步-2"></p>
<p>第六步，看和节点5相邻的所有边。<code>1-5</code>、<code>5-7</code>不是横切边，所以不用再看；<code>4-5:0.35</code>其值小于最小索引堆索引为4处的值0.37，将其更新为0.35，同时将0.37这条边剔除.</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/35.png" alt="Prim第六步-1"></p>
<p>然后从最小索引堆中找出最小边，即0.35这条边，它就是最小生成树的边。同时将结点4加入红色部分。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/36.png" alt="Prim第六步-2"></p>
<p>第七步，看和节点4相邻的所有横切边。此时只有<code>4-6:0.93</code>这一条横切边，其值大于此时最小索引堆中索引为6处的值0.40，所以将其剔除。</p>
<p>最后将最小索引堆中的0.40这条边取出，作为最小生成树的边。同时结点6加入红色部分。这时所有节点遍历完毕，并且找到了最小生成树。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/37.png" alt="Prim第七步"></p>
<p>这种方法对于不是横切边的边在判断后会扔掉，所以Prim的时间复杂度改进还是很可观的。</p>
<h2 id="Prim算法代码"><a href="#Prim算法代码" class="headerlink" title="Prim算法代码"></a>Prim算法代码</h2><p>见附录2</p>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><blockquote>
<p>Kruskal算法的主要思想是按照边的权重顺序(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，知道树中含有V-1条边为止。这些边逐渐由一片森林合并为一棵树，也就是图的最小生成树。——算法第四版</p>
</blockquote>
<p>使用Kruskal算法，为了方便地每次都能取出最短的边，首先对图中所有的边按照权值排序。</p>
<p>然后就要取出还没有考虑的边中最短的那条边，看将此边加入到图中是否会生成环（如果生成环那么就不是最小生成树或者说不是树），如果没有生成环那么它就是最小生成树中的边。</p>
<p>第一步：<code>0-7:0.16</code>,将其放入最小生成树中，不会生成环，所以将这条边作为最小生成树中的一条边</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/38.png" alt="Kruskal第一步"></p>
<p>第二步：下一条最小的边为<code>2-3:0.17</code>，将其放入最小生成树中，也不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/39.png" alt="Kruskal第二步"></p>
<p>第三步：下一条最小的边为<code>1-7:0.19</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p>第四步：下一条最小的边为<code>0-2:0.26</code>，这里需要注意，虽然节点0和节点2都是红色，但是将这条边加入最小生成树后并没有形成环，所以它可以作为最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/40.png" alt="Kruskal第四步"></p>
<p>第五步：下一条最小的边为<code>5-7:0.28</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/45.png" alt="Kruskal第五步"></p>
<p>第六步：下一条最小的边为<code>1-3:0.29</code>，将其放入最小生成树中，<font color=red>会生成环</font>，不能作为最小生成树的一条边，所以不再考虑它。</p>
<p>第七步：下一条最小的边为<code>1-5:0.32</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它。</p>
<p>第八步：下一条最小的边为<code>2-7:0.34</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它。</p>
<p>第九步：下一条最小的边为<code>4-5:0.35</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/41.png" alt="Kruskal第九步"></p>
<p>第十步：下一条最小的边为<code>1-2:0.36</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它。</p>
<p>第十一步、第十二步的边<code>4-7:0.37</code>、<code>0-4:0.38</code>，将其放入最小生成树中，<font color=red>会生成环</font>，所以不再考虑它们。</p>
<p>第十三步：下一条最小的边为<code>2-6:0.40</code>，将其放入最小生成树中，不会生成环，所以它是最小生成树的一条边。</p>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/42.png" alt="Kruskal第十三步"></p>
<p>至此已经有了V-1条边，并且将V个顶点都连接起来了，这时候算法就可以结束了。如果继续扫描的话，剩下的边也都会让最小生成树形成环，也都不会被考虑，直到扫描结束。</p>
<p>整个过程中，关键的操作是判断加入一条边后，是否会行程一个环，这个操作可以使用<a href="https://homxuwang.github.io/2019/01/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>结构进行辅助。</p>
<p>那么如何使用并查集进行辅助呢？<br>在每一次加入一条边作为最小生成树的同时，对一条边的两个端点进行Union操作。比如此时要加入<code>1-3</code>这条边，去找并查集中1的根节点和3的根节点，它们一定属于同一个根，说明最小生成树中已经连接了节点1和节点3了，此时再将<code>1-3</code>连接的话，就必然形成一个环，这时就可以不考虑这条边了。</p>
<h2 id="Kruskal算法代码实现"><a href="#Kruskal算法代码实现" class="headerlink" title="Kruskal算法代码实现"></a>Kruskal算法代码实现</h2><p>见附录3</p>
<blockquote>
<p>Kruskal算法的计算一副含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和E成正比，所需的时间和ElogE成正比(最坏情况)。</p>
</blockquote>
<blockquote>
<p>与Prim算法一样，这个估计是比较保守的，因为算法在找到V-1条边之后就会终止。实际的成本应该与E+E0logE成正比，其中E0是权重小于最小生成树中权重最大的边的所有边的总数。尽管拥有这个优势，Kruskal算法一般还是比Prim算法要慢，因为在处理每条边时除了两种算法都要完成的优先队列操作之外，他还要进行一次connect()操作。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lazy Prim   :    O(ElogE)<br>Prim        :    O(ElogV)  整体而言效率最高<br>Kruskal     :    O(ElogE)</p>
<p>在算法第四版有约定，所有边的权重都各不相同。但是如果有横切边相等的边，那么根据算法的具体实现，每次选择一个边，此时存在多个最小生成树。</p>
<p>另外还有个<code>Vyssotsky&#39;s Algorithm</code>提出的算法，将边逐渐的添加到生成树中，一旦形成环，就删除环中权值最大的边。这个过程完成后可以形成一个最小生成树。</p>
<h1 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h1><p>首先创建最小堆<code>MinHeap.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在堆的有关操作中，需要比较堆中元素的大小，所以Item需要extends Comparable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 通过一个给定数组创建一个最小堆</span></span><br><span class="line">    <span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(Item arr[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最小堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> count + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        count ++;</span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小堆中取出堆顶元素, 即堆中所存储的最小数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( <span class="number">1</span> , count );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Item t = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="comment">//* 最小堆核心辅助函数</span></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>].compareTo(data[k]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            swap(k, k/<span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>].compareTo(data[j]) &lt; <span class="number">0</span> )</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最小值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[k].compareTo(data[j]) &lt;= <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            swap(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 MinHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MinHeap&lt;Integer&gt; minHeap = <span class="keyword">new</span> MinHeap&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">100</span>; <span class="comment">// 堆中元素个数</span></span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">100</span>; <span class="comment">// 堆中元素取值范围[0, M)</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )</span><br><span class="line">            minHeap.insert( <span class="keyword">new</span> Integer((<span class="keyword">int</span>)(Math.random() * M)) );</span><br><span class="line"></span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[N];</span><br><span class="line">        <span class="comment">// 将minheap中的数据逐渐使用extractMin取出来</span></span><br><span class="line">        <span class="comment">// 取出来的顺序应该是按照从小到大的顺序取出来的</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )&#123;</span><br><span class="line">            arr[i] = minHeap.extractMin();</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保arr数组是从小到大排列的</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; i ++ )</span><br><span class="line">            <span class="keyword">assert</span> arr[i-<span class="number">1</span>] &lt;= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建<code>LazyPrimMST.java</code>类进行算法的编写.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph&lt;Weight&gt; G;    <span class="comment">//图的引用</span></span><br><span class="line">    <span class="keyword">private</span> MinHeap&lt;Edge&lt;Weight&gt;&gt; pq;   <span class="comment">//最小堆，算法辅助数据结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;         <span class="comment">//标记数组，在算法运行过程中标记节点i是否被访问（即图中的蓝色部分和红色部分）</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst;   <span class="comment">//最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;          <span class="comment">//最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(WeightedGraph&lt;Weight&gt; graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        G = graph;</span><br><span class="line">        pq = <span class="keyword">new</span> MinHeap&lt;Edge&lt;Weight&gt;&gt;(G.E());</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        mst = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lazy Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 使用最小堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            Edge&lt;Weight&gt; e = pq.extractMin();</span><br><span class="line">            <span class="comment">// 如果这条边的两端都已经访问过了, 它不是横切边,扔掉这条边</span></span><br><span class="line">            <span class="keyword">if</span>(marked[e.v()] == marked[e.w()])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//否则，这条边应该存在最小生成树中</span></span><br><span class="line">            mst.add(e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//访问和这条边连接的还没有被访问过的节点(找到蓝色一端的端点)</span></span><br><span class="line">            <span class="keyword">if</span>( !marked[e.v()] )</span><br><span class="line">                visit(e.v());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                visit(e.w());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; mst.size() ; i ++)</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( marked[v] )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;this point has been visited!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将和节点v相连的所有未访问的边放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span>(Edge&lt;Weight&gt; e : G.adj(v))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[e.other(v)]) <span class="comment">//找到与其对应的另一个端点，如果是横切边</span></span><br><span class="line">                pq.insert(e);        <span class="comment">//就加入到堆中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Main.java</code>中进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试通过文件读取图的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用两种图的存储方式读取testG1.txt文件</span></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(<span class="number">8</span>, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph1 = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line">         <span class="comment">// Test Lazy Prim MST</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Lazy Prim MST:&quot;</span>);</span><br><span class="line">        LazyPrimMST&lt;Double&gt; lazyPrimMST = <span class="keyword">new</span> LazyPrimMST&lt;Double&gt;(g);</span><br><span class="line">        Vector&lt;Edge&lt;Double&gt;&gt; mst = lazyPrimMST.mstEdges();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; mst.size() ; i ++ )</span><br><span class="line">            System.out.println(mst.elementAt(i));</span><br><span class="line">        System.out.println(<span class="string">&quot;The MST weight is: &quot;</span> + lazyPrimMST.result());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/24.png" alt="测试结果"></p>
<h1 id="附录2"><a href="#附录2" class="headerlink" title="附录2"></a>附录2</h1><p>最小索引堆<code>IndexMinHeap.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小索引堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMinHeap</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Item[] data;      <span class="comment">// 最小索引堆中的数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] indexes;    <span class="comment">// 最小索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span>[] reverse;    <span class="comment">// 最小索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMinHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (Item[])<span class="keyword">new</span> Comparable[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最小索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> count + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">        <span class="keyword">assert</span> i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        <span class="keyword">assert</span> !contain(i);</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count + <span class="number">1</span>;</span><br><span class="line">        count ++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素, 即索引堆中所存储的最小数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swapIndexes( <span class="number">1</span> , count );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">extractMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swapIndexes( <span class="number">1</span> , count );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>  i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">contain</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最小索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">contain</span><span class="params">(i)</span></span>;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有了 reverse 之后,</span></span><br><span class="line">        <span class="comment">// 我们可以非常简单的通过reverse直接定位索引i在indexes中的位置</span></span><br><span class="line">        shiftUp( reverse[i] );</span><br><span class="line">        shiftDown( reverse[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换索引堆中的索引i和j</span></span><br><span class="line">    <span class="comment">// 由于有了反向索引reverse数组，</span></span><br><span class="line">    <span class="comment">// indexes数组发生改变以后， 相应的就需要维护reverse数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapIndexes</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = indexes[i];</span><br><span class="line">        indexes[i] = indexes[j];</span><br><span class="line">        indexes[j] = t;</span><br><span class="line"></span><br><span class="line">        reverse[indexes[i]] = i;</span><br><span class="line">        reverse[indexes[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line">    <span class="comment">//* 最小索引堆核心辅助函数</span></span><br><span class="line">    <span class="comment">//********************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]].compareTo(data[indexes[k]]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            swapIndexes(k, k/<span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]].compareTo(data[indexes[j]]) &lt; <span class="number">0</span> )</span><br><span class="line">                j ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]].compareTo(data[indexes[j]]) &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swapIndexes(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 IndexMinHeap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">        IndexMinHeap&lt;Integer&gt; indexMinHeap = <span class="keyword">new</span> IndexMinHeap&lt;Integer&gt;(N);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++ )</span><br><span class="line">            indexMinHeap.insert( i , (<span class="keyword">int</span>)(Math.random()*N) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PrimMST.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeightedGraph G;          <span class="comment">//图的引用</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinHeap&lt;Weight&gt; ipq; <span class="comment">//最小索引堆</span></span><br><span class="line">    <span class="keyword">private</span> Edge&lt;Weight&gt;[] edgeTo;   <span class="comment">//访问的点所对应的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;       <span class="comment">//标记数组,在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst; <span class="comment">//最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;        <span class="comment">//最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(WeightedGraph graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        G = graph;</span><br><span class="line">        <span class="keyword">if</span>(!(graph.E() &gt;= <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Edges of graph should &gt;= 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ipq = <span class="keyword">new</span> IndexMinHeap&lt;&gt;(graph.V());  <span class="comment">//开辟顶点个数的空间就可以</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G.V() ; i ++)&#123;</span><br><span class="line">            marked[i] = <span class="keyword">false</span>;</span><br><span class="line">            edgeTo[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mst = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Prim</span></span><br><span class="line">        visit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!ipq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 使用最小索引堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            <span class="comment">// 最小索引堆中存储的是点的索引, 通过点的索引找到相对应的边</span></span><br><span class="line">            <span class="keyword">int</span> v = ipq.extractMinIndex();</span><br><span class="line">            <span class="keyword">if</span>(edgeTo[v] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Edge should&#x27;t be null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mst.add(edgeTo[v]);</span><br><span class="line">            visit(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; mst.size() ; i ++)&#123;</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问节点v</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( marked[v] )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;this point has been visited!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将和节点v相连接的未访问的另一端点, 和与之相连接的边, 放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span>(Object item :G.adj(v))&#123;</span><br><span class="line">            Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="comment">//如果边的另一端点未被访问</span></span><br><span class="line">            <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">                <span class="comment">//如果从没有考虑过这个端点，直接将这个端点和与之相连接的边加入索引堆，即它是横切边</span></span><br><span class="line">                <span class="keyword">if</span>(edgeTo[w] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.insert(w,e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果曾经考虑这个端点,但现在的边比之前考虑的边更短,则进行替换</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(e.wt().compareTo(edgeTo[w].wt())&lt; <span class="number">0</span> )&#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.change(w,e.wt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 Prim</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(V, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Prim MST</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Prim MST:&quot;</span>);</span><br><span class="line">        PrimMST&lt;Double&gt; primMST = <span class="keyword">new</span> PrimMST&lt;Double&gt;(g);</span><br><span class="line">        Vector&lt;Edge&lt;Double&gt;&gt; mst = primMST.mstEdges();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; mst.size() ; i ++ )</span><br><span class="line">            System.out.println(mst.elementAt(i));</span><br><span class="line">        System.out.println(<span class="string">&quot;The MST weight is: &quot;</span> + primMST.result());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/44.png" alt="测试结果"></p>
<h1 id="附录3"><a href="#附录3" class="headerlink" title="附录3"></a>附录3</h1><p><code>UnionFind.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Union-Find</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">    <span class="comment">// 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span></span><br><span class="line">    <span class="comment">// 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;    <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path compression 1</span></span><br><span class="line">        <span class="keyword">while</span>( p != parent[p] )&#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">        <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">        <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MinHeap.java</code>:<br>见附录1</p>
<p><code>KruskalMST.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span>&lt;<span class="title">Weight</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Edge&lt;Weight&gt;&gt; mst;    <span class="comment">//最小生成树所包含的所有边</span></span><br><span class="line">    <span class="keyword">private</span> Number mstWeight;           <span class="comment">//最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，使用Kruskal算法计算graph的最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(WeightedGraph graph)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        mst  = <span class="keyword">new</span> Vector&lt;Edge&lt;Weight&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有的边进行排序，使用堆排序，将所有的边放入一个最小堆中</span></span><br><span class="line">        MinHeap&lt;Edge&lt;Weight&gt;&gt; pq = <span class="keyword">new</span> MinHeap&lt;Edge&lt;Weight&gt;&gt;(graph.E());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; graph.V(); i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Object item : graph.adj(i))&#123;</span><br><span class="line">                Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;) item;</span><br><span class="line">                <span class="keyword">if</span>( e.v() &lt;= e.w() )  <span class="comment">//防止存入两次同一条边(比如边1-2和边2-1，只存入边1-2)</span></span><br><span class="line">                    pq.insert(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个并查集，查看已经访问的节点的联通情况</span></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(graph.V());</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; graph.V() - <span class="number">1</span>)&#123;<span class="comment">//pq不为空且最小生成树的边数小于V-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//从最小堆中依次从小到大取出所有的边</span></span><br><span class="line">            Edge&lt;Weight&gt; e = pq.extractMin();</span><br><span class="line">            <span class="comment">//如果该边的两个端点是联通的，说明加入这条边将产生环，扔掉这条边</span></span><br><span class="line">            <span class="keyword">if</span>(uf.isConnected(e.v(),e.w()))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//否则，将这条边加入最小生成树，同时标记边的两个端点联通</span></span><br><span class="line">            mst.add(e);</span><br><span class="line">            uf.unionElements(e.v(),e.w());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst.elementAt(<span class="number">0</span>).wt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; mst.size() ; i ++)&#123;</span><br><span class="line">            mstWeight = mstWeight.doubleValue() + mst.elementAt(i).wt().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    Vector&lt;Edge&lt;Weight&gt;&gt; mstEdges()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Number <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 Kruskal</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String filename = <span class="string">&quot;testG1.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> V = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        SparseWeightedGraph&lt;Double&gt; g = <span class="keyword">new</span> SparseWeightedGraph&lt;Double&gt;(V, <span class="keyword">false</span>);</span><br><span class="line">        ReadWeightedGraph readGraph = <span class="keyword">new</span> ReadWeightedGraph(g, filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Kruskal</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Kruskal:&quot;</span>);</span><br><span class="line">        KruskalMST&lt;Double&gt; kruskalMST = <span class="keyword">new</span> KruskalMST&lt;Double&gt;(g);</span><br><span class="line">        Vector&lt;Edge&lt;Double&gt;&gt; mst = kruskalMST.mstEdges();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; mst.size() ; i ++ )</span><br><span class="line">            System.out.println(mst.elementAt(i));</span><br><span class="line">        System.out.println(<span class="string">&quot;The MST weight is: &quot;</span> + kruskalMST.result());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果:<br><img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/43.png" alt="测试结果"></p>

  <p><a class="classtest-link" href="/tags/%E5%9B%BE/" rel="tag">图</a>, <a class="classtest-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a> — Apr 5, 2019</p>
  


        </div>
        <div class="row mt-2">
  <h3>Search</h3>
  <div><input id="search-text" title="search" class="search-text" type="text" placeholder="search......"></div>
  <div style="margin-top: 1.5rem;">
    <ul id="result"></ul>
  </div>
</div>
        <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
        at <a href="https://en.wikipedia.org/wiki/Earth" target="_blank" rel="noreferrer">Earth</a>.</p>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/homxuwang" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      

      

      

      

    </div>
  
</div>

      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>

  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>